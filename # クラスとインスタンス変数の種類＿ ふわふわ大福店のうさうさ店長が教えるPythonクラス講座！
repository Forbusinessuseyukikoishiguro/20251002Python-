# 🐰 ふわふわ大福店のうさうさ店長が教えるPythonクラス講座！

こんにちは！ふわふわ大福店のうさうさ店長だよ🐰✨
Pythonのクラスについて、お店の例で説明するね！

## 📚 クラスとインスタンス変数の種類

```python
class FuwafuwaDaifukuShop:
    """ふわふわ大福店のクラス"""
    
    # ①クラス変数（全店舗共通）
    shop_chain_name = "ふわふわ大福チェーン"
    total_shops = 0
    menu_items = ["いちご大福", "抹茶大福", "黒ゴマ大福"]
    
    def __init__(self, shop_name, manager_name):
        # ②インスタンス変数（各店舗固有）
        self.shop_name = shop_name           # 店舗名
        self.manager_name = manager_name     # 店長名
        self.daily_sales = 0                 # 本日の売上
        self.inventory = {                   # 在庫
            "いちご大福": 50,
            "抹茶大福": 40,
            "黒ゴマ大福": 30
        }
        
        # クラス変数を更新
        FuwafuwaDaifukuShop.total_shops += 1
    
    # ③インスタンスメソッド
    def sell_daifuku(self, daifuku_type, quantity):
        """大福を販売するメソッド"""
        if daifuku_type in self.inventory:
            if self.inventory[daifuku_type] >= quantity:
                self.inventory[daifuku_type] -= quantity
                self.daily_sales += quantity * 150  # 1個150円
                return f"🎉 {daifuku_type}を{quantity}個販売しました！"
            else:
                return f"😢 在庫不足です。残り{self.inventory[daifuku_type]}個です。"
        return "❌ そのメニューはありません。"
    
    def greet(self):
        """店長の挨拶"""
        return f"🐰 こんにちは！{self.shop_name}の{self.manager_name}です！"
    
    # ④クラスメソッド
    @classmethod
    def get_total_shops(cls):
        """全店舗数を取得"""
        return f"📊 {cls.shop_chain_name}の総店舗数: {cls.total_shops}店"
    
    @classmethod
    def add_new_menu(cls, new_item):
        """新メニューを追加（全店舗共通）"""
        cls.menu_items.append(new_item)
        return f"✨ 新メニュー「{new_item}」を追加しました！"
    
    # ⑤静的メソッド
    @staticmethod
    def calculate_discount(price, discount_rate):
        """割引計算（店舗に依存しない汎用的な機能）"""
        return price * (1 - discount_rate)
    
    # ⑥プロパティ（ゲッター・セッター）
    @property
    def total_inventory(self):
        """総在庫数を計算"""
        return sum(self.inventory.values())
    
    def __str__(self):
        """オブジェクトの文字列表現"""
        return f"🏪 {self.shop_name}（店長: {self.manager_name}）"


# 🐰 使用例
print("=" * 50)
print("🌸 ふわふわ大福店 開店！ 🌸")
print("=" * 50)

# 店舗インスタンスを作成
usausa_shop = FuwafuwaDaifukuShop("渋谷店", "うさうさ店長")
mochimochi_shop = FuwafuwaDaifukuShop("新宿店", "もちもち店長")

# 挨拶
print(usausa_shop.greet())
print(mochimochi_shop.greet())
print()

# 販売
print(usausa_shop.sell_daifuku("いちご大福", 10))
print(f"💰 本日の売上: {usausa_shop.daily_sales}円")
print(f"📦 残り在庫数: {usausa_shop.total_inventory}個")
print()

# クラスメソッドの使用
print(FuwafuwaDaifukuShop.get_total_shops())
print(FuwafuwaDaifukuShop.add_new_menu("きなこ大福"))
print(f"📋 メニュー一覧: {FuwafuwaDaifukuShop.menu_items}")
print()

# 静的メソッドの使用
original_price = 1500
discounted = FuwafuwaDaifukuShop.calculate_discount(original_price, 0.2)
print(f"🎁 特別セール: {original_price}円 → {discounted}円（20%OFF）")
print()

# インスタンス変数の独立性を確認
print(f"🏪 {usausa_shop.shop_name}の在庫: {usausa_shop.inventory['いちご大福']}個")
print(f"🏪 {mochimochi_shop.shop_name}の在庫: {mochimochi_shop.inventory['いちご大福']}個")
```

## 📝 まとめ

| 種類 | 説明 | アクセス方法 |
|------|------|------------|
| **クラス変数** | 全インスタンスで共有 | `クラス名.変数名` |
| **インスタンス変数** | 各インスタンス固有 | `self.変数名` |
| **インスタンスメソッド** | インスタンスの操作 | `self`が必要 |
| **クラスメソッド** | クラス全体の操作 | `@classmethod`, `cls`使用 |
| **静的メソッド** | 汎用的な関数 | `@staticmethod` |
| **プロパティ** | 計算された属性 | `@property` |

うさうさ店長より🐰💕


#######################################

```python
# 多重継承の続き
| **多重継承** | 複数の親クラスから継承 | `class Hybrid(A, B, C):` |
| **ミックスイン** | 機能を追加するクラス | `OnlineService`, `MembershipService` |
| **MRO** | メソッド解決順序 | `Class.__mro__` |
| **isinstance()** | インスタンスの型チェック | `isinstance(obj, Class)` |
| **issubclass()** | サブクラスの確認 | `issubclass(Child, Parent)` |

### 💻 実行方法

1. **コードをコピーしてファイルに保存**
   ```bash
   # inheritance_demo.py として保存
   ```

2. **実行**
   ```bash
   python inheritance_demo.py
   ```

3. **出力例**
   ```
   🐰 うさうさ店長の基本店舗が開店しました！
   💰 5個販売しました（¥750）
   📦 10個補充しました。現在の在庫: 25個
   
   🐰 もちもち店長のプレミアム店舗が開店しました！
   ✨ VIP会員数: 3名
   💰 3個販売しました（¥450）
   💰 2個販売しました（¥450）
   ✨ プレミアム大福を販売しました！
   ```

---

## 📖 補足説明: 重要概念の詳細

### 🔹 1. 継承とは？

**継承（Inheritance）** = 既存のクラスの機能を引き継いで新しいクラスを作ること

```python
# 親クラス（基底クラス、スーパークラス）
class Animal:
    def eat(self):
        print("食べる")

# 子クラス（派生クラス、サブクラス）
class Dog(Animal):  # Animalを継承
    def bark(self):
        print("ワン！")

# 子クラスは親のメソッドも使える
dog = Dog()
dog.eat()   # 親のメソッド
dog.bark()  # 子のメソッド
```

**メリット:**
- コードの再利用
- 保守性の向上
- 階層構造で整理

**使う場面:**
- 「is-a関係」が成り立つ時
  - 犬は動物である（Dog is an Animal）✓
  - 車は動物である（Car is an Animal）✗

---

### 🔹 2. super()の使い方

**super()** = 親クラスのメソッドを呼び出す特殊な関数

```python
class Parent:
    def __init__(self, name):
        self.name = name
        print(f"親の初期化: {name}")

class Child(Parent):
    def __init__(self, name, age):
        # 親の__init__を呼び出す
        super().__init__(name)  # ← これが重要！
        
        # 子クラス固有の処理
        self.age = age
        print(f"子の初期化: {age}歳")

# 実行
child = Child("太郎", 10)
# 出力:
# 親の初期化: 太郎
# 子の初期化: 10歳
```

**super()を使う理由:**
1. 親の初期化を忘れない
2. 親のコードを再利用
3. 多重継承でも正しく動作

---

### 🔹 3. メソッドのオーバーライド

**オーバーライド（Override）** = 親クラスのメソッドを子クラスで上書き

```python
class Animal:
    def speak(self):
        print("...")

class Dog(Animal):
    def speak(self):  # 親のメソッドを上書き
        print("ワン！")

class Cat(Animal):
    def speak(self):  # 親のメソッドを上書き
        print("ニャー！")

# 同じメソッド名でも動作が異なる
dog = Dog()
cat = Cat()

dog.speak()  # ワン！
cat.speak()  # ニャー！
```

**ポイント:**
- メソッド名は同じ
- 動作は異なる
- これがポリモーフィズムの基礎

---

### 🔹 4. ポリモーフィズム（多態性）

**ポリモーフィズム** = 同じインターフェースで異なる動作をさせる技術

```python
def make_animal_speak(animal):
    """どの動物でも同じ関数で処理できる"""
    animal.speak()  # ← 実際のクラスによって動作が変わる

# 異なるクラスのインスタンスでも同じ関数で処理
animals = [Dog(), Cat(), Bird()]

for animal in animals:
    make_animal_speak(animal)
# 出力:
# ワン！
# ニャー！
# ピーチク！
```

**メリット:**
- 柔軟なコード
- 拡張しやすい
- インターフェースの統一

**使う場面:**
- プラグインシステム
- ゲームのキャラクター
- データベースドライバ

---

### 🔹 5. 多重継承

**多重継承** = 複数の親クラスから同時に継承

```python
class Flyable:
    """飛べる機能"""
    def fly(self):
        print("飛ぶ！")

class Swimmable:
    """泳げる機能"""
    def swim(self):
        print("泳ぐ！")

class Duck(Flyable, Swimmable):
    """アヒル: 飛べて泳げる"""
    pass

# 両方の機能を持つ
duck = Duck()
duck.fly()   # 飛ぶ！
duck.swim()  # 泳ぐ！
```

**注意点:**
1. **ダイヤモンド問題**: 同じメソッドが複数の親にある場合
2. **MROの理解**: どの順番でメソッドを探すか
3. **複雑化**: 深い継承は避ける

---

### 🔹 6. MRO（Method Resolution Order）

**MRO** = メソッドを探す順番

```python
class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")

class C(A):
    def method(self):
        print("C")

class D(B, C):
    pass

# MROを確認
print(D.__mro__)
# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)

# メソッド呼び出し
d = D()
d.method()  # "B" が出力される（MROの順番通り）
```

**C3線形化アルゴリズム:**
- Python 3のMROの仕組み
- 親クラスの順序を保証
- ダイヤモンド問題を解決

---

## 🎓 学習のポイント

### ✅ 初心者が押さえるべきこと

1. **継承の基本**
   - `class Child(Parent):`
   - `super().__init__()`の使い方
   - メソッドのオーバーライド

2. **ポリモーフィズムの理解**
   - 同じメソッド名で異なる動作
   - インターフェースの統一

3. **適切な使い分け**
   - 継承: is-a関係
   - コンポジション: has-a関係

### ⚠️ よくある間違い

```python
# ❌ 悪い例: has-a関係で継承を使う
class Car(Engine):  # 車はエンジンではない
    pass

# ✅ 良い例: has-a関係はコンポジション
class Car:
    def __init__(self):
        self.engine = Engine()  # 車はエンジンを持つ
```

---

## 📝 練習問題

### 問題1: 単一継承
```python
# 動物園システムを作ろう
# Animal（親）→ Lion, Elephant, Penguin（子）
# 各動物は speak() メソッドを持つ

class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        pass  # 子クラスで実装

# ここにLion, Elephant, Penguinクラスを実装してください
```

### 問題2: ポリモーフィズム
```python
# 様々な図形の面積を計算
# Shape（親）→ Circle, Rectangle, Triangle（子）
# すべて area() メソッドを実装

def print_area(shape):
    """どの図形でも面積を表示"""
    print(f"面積: {shape.area()}")

# ここに各図形クラスを実装してください
```

### 問題3: 多重継承
```python
# スマートフォンシステム
# Phone（通話機能）+ Camera（撮影機能）+ GPS（位置情報）
# → SmartPhone（すべての機能）

# ここに実装してください
```

---

## 🎯 まとめ

### 継承の3つの柱

| 概念 | 説明 | キーワード |
|------|------|-----------|
| **継承** | 機能を引き継ぐ | `class Child(Parent):` |
| **ポリモーフィズム** | 同じ名前で異なる動作 | オーバーライド |
| **カプセル化** | 内部を隠す | `_private` |

### 設計の原則

1. **単一責任の原則**: 1クラス1責務
2. **開放閉鎖の原則**: 拡張に開いて、修正に閉じる
3. **リスコフの置換原則**: 子は親の代わりに使える
4. **インターフェース分離の原則**: 使わないメソッドを強制しない
5. **依存性逆転の原則**: 抽象に依存する

---

## 🚀 次のステップ

1. **抽象基底クラス（ABC）を学ぶ**
   ```python
   from abc import ABC, abstractmethod
   
   class Shape(ABC):
       @abstractmethod
       def area(self):
           pass
   ```

2. **デザインパターンを学ぶ**
   - ファクトリーパターン
   - シングルトンパターン
   - オブザーバーパターン

3. **実践的なプロジェクトを作る**
   - ゲーム開発
   - Webアプリケーション
   - データ分析ツール

---

このコードを実行して、1行ずつコメントを読みながら学習してください！🐰✨


############################################

"""
====================================
🐰 ふわふわ大福店 完全版
継承・ポリモーフィズム・多重継承ガイド
新人エンジニア向け - 1行ずつコメント解説
====================================
"""

# ====================================
# 第1部: 基本的な継承（親子関係）
# ====================================

class DaifukuShop:
    """
    大福店の基底クラス（親クラス）
    すべての大福店の基本機能を定義
    """
    
    # クラス変数: すべてのインスタンスで共有
    shop_type = "基本店舗"  # 店舗タイプ
    
    def __init__(self, owner_name, stock=10):
        """
        コンストラクタ: インスタンス作成時に実行される
        
        Parameters:
            owner_name (str): 店長の名前
            stock (int): 初期在庫数
        """
        # インスタンス変数: このインスタンス固有のデータ
        self.owner_name = owner_name  # 店長名
        self.stock = stock  # 在庫数
        self.sold_count = 0  # 累計販売数
        self.revenue = 0  # 累計売上
        
        # 開店メッセージを表示
        print(f"🐰 {self.owner_name}店長の{self.shop_type}が開店しました！")
    
    def sell(self, quantity, price=150):
        """
        大福を販売するメソッド（親クラスの基本機能）
        
        Parameters:
            quantity (int): 販売個数
            price (int): 単価（デフォルト150円）
            
        Returns:
            int: 今回の売上金額
        """
        # 在庫が足りるかチェック
        if quantity > self.stock:
            # 在庫不足なら例外を発生させる
            raise ValueError(f"在庫不足！残り{self.stock}個です")
        
        # 在庫を減らす
        self.stock -= quantity
        
        # 販売数を記録
        self.sold_count += quantity
        
        # 売上を計算
        sale_amount = quantity * price
        
        # 累計売上に追加
        self.revenue += sale_amount
        
        # 販売メッセージを表示
        print(f"💰 {quantity}個販売しました（¥{sale_amount}）")
        
        # 売上金額を返す
        return sale_amount
    
    def restock(self, quantity):
        """
        在庫を補充するメソッド
        
        Parameters:
            quantity (int): 補充する個数
        """
        # 在庫を増やす
        self.stock += quantity
        
        # 補充メッセージ
        print(f"📦 {quantity}個補充しました。現在の在庫: {self.stock}個")
    
    def show_status(self):
        """
        店舗の状況を表示するメソッド
        このメソッドは子クラスでオーバーライドされる
        """
        # 基本情報を表示
        print(f"\n{'='*50}")
        print(f"🏪 {self.shop_type}: {self.owner_name}店長")
        print(f"📦 在庫: {self.stock}個")
        print(f"📊 累計販売: {self.sold_count}個")
        print(f"💰 累計売上: ¥{self.revenue}")
        print(f"{'='*50}\n")


# ====================================
# 第2部: 単一継承（1つの親クラスから継承）
# ====================================

class PremiumDaifukuShop(DaifukuShop):
    """
    プレミアム大福店クラス（子クラス）
    DaifukuShopを継承して機能を拡張
    
    継承関係: PremiumDaifukuShop は DaifukuShop の一種（is-a関係）
    """
    
    # 子クラス固有のクラス変数
    shop_type = "プレミアム店舗"  # 親のクラス変数を上書き
    premium_rate = 1.5  # プレミアム価格倍率
    
    def __init__(self, owner_name, stock=10, vip_members=0):
        """
        子クラスのコンストラクタ
        親の初期化 + 子クラス固有の初期化
        
        Parameters:
            owner_name (str): 店長名
            stock (int): 初期在庫
            vip_members (int): VIP会員数（子クラス固有）
        """
        # ----- super()で親クラスの__init__を呼び出す -----
        # super() = 親クラス（DaifukuShop）を指す
        # 親の初期化処理を実行（owner_name, stock, sold_count等を設定）
        super().__init__(owner_name, stock)
        
        # ----- 子クラス固有のインスタンス変数 -----
        self.vip_members = vip_members  # VIP会員数
        self.vip_sales = 0  # VIP向け販売数
        
        # 子クラス固有のメッセージ
        print(f"✨ VIP会員数: {self.vip_members}名")
    
    def sell_premium(self, quantity):
        """
        子クラス固有のメソッド: プレミアム大福の販売
        通常価格の1.5倍で販売
        
        Parameters:
            quantity (int): 販売個数
            
        Returns:
            int: 売上金額
        """
        # プレミアム価格を計算（150円 × 1.5 = 225円）
        premium_price = int(150 * self.premium_rate)
        
        # 親クラスのsellメソッドを呼び出す
        # self.sell() でも呼べるが、super().sell()の方が明示的
        sale_amount = super().sell(quantity, premium_price)
        
        # プレミアム販売メッセージ
        print(f"✨ プレミアム大福を販売しました！")
        
        return sale_amount
    
    def add_vip_member(self, count=1):
        """
        子クラス固有のメソッド: VIP会員を追加
        
        Parameters:
            count (int): 追加する会員数
        """
        # VIP会員数を増やす
        self.vip_members += count
        
        print(f"👑 VIP会員が{count}名増えました！（合計: {self.vip_members}名）")
    
    def show_status(self):
        """
        メソッドのオーバーライド: 親のメソッドを上書き
        親の表示 + 子クラス固有の情報を追加
        """
        # ----- 親クラスのshow_statusを呼び出す -----
        super().show_status()
        
        # ----- 子クラス固有の情報を追加表示 -----
        print(f"👑 VIP会員: {self.vip_members}名")
        print(f"✨ VIP向け販売: {self.vip_sales}個")
        print(f"{'='*50}\n")


# ====================================
# 第3部: ポリモーフィズム（多態性）
# ====================================

class DeliveryDaifukuShop(DaifukuShop):
    """
    配達専門大福店クラス（別の子クラス）
    同じ親から継承しているが、異なる振る舞いを持つ
    """
    
    # 子クラス固有のクラス変数
    shop_type = "配達専門店舗"
    delivery_fee = 300  # 配達料金
    
    def __init__(self, owner_name, stock=10, delivery_range=5):
        """
        配達専門店のコンストラクタ
        
        Parameters:
            owner_name (str): 店長名
            stock (int): 初期在庫
            delivery_range (int): 配達可能範囲（km）
        """
        # 親クラスの初期化
        super().__init__(owner_name, stock)
        
        # 子クラス固有の変数
        self.delivery_range = delivery_range  # 配達可能範囲
        self.delivery_count = 0  # 配達回数
        
        print(f"🚚 配達範囲: {self.delivery_range}km圏内")
    
    def sell(self, quantity, price=150, with_delivery=True):
        """
        メソッドのオーバーライド: sellメソッドを独自実装
        親と同じメソッド名だが、動作が異なる（ポリモーフィズム）
        
        Parameters:
            quantity (int): 販売個数
            price (int): 単価
            with_delivery (bool): 配達するか
            
        Returns:
            int: 売上金額（配達料込み）
        """
        # ----- 親クラスのsellを呼び出して基本販売処理 -----
        sale_amount = super().sell(quantity, price)
        
        # ----- 配達の場合は追加処理 -----
        if with_delivery:
            # 配達料金を追加
            sale_amount += self.delivery_fee
            
            # 配達回数をカウント
            self.delivery_count += 1
            
            # 累計売上に配達料を追加
            self.revenue += self.delivery_fee
            
            # 配達メッセージ
            print(f"🚚 配達します！配達料: ¥{self.delivery_fee}")
        
        return sale_amount
    
    def show_status(self):
        """
        メソッドのオーバーライド: 配達情報を追加
        """
        # 親のshow_statusを呼び出す
        super().show_status()
        
        # 配達専門店固有の情報
        print(f"🚚 配達回数: {self.delivery_count}回")
        print(f"📍 配達範囲: {self.delivery_range}km")
        print(f"{'='*50}\n")


# ====================================
# ポリモーフィズムのデモ関数
# ====================================

def process_sale(shop, quantity):
    """
    どの店舗でも同じインターフェースで販売処理
    これがポリモーフィズム（多態性）の力！
    
    Parameters:
        shop: DaifukuShopまたはその子クラスのインスタンス
        quantity (int): 販売個数
    """
    # どの子クラスでも同じメソッド名で呼び出せる
    # しかし、実際の動作は各クラスの実装によって異なる
    try:
        # ここでshop.sell()を呼ぶと、
        # そのオブジェクトの実際のクラスのsellメソッドが実行される
        shop.sell(quantity)
        
        # 成功メッセージ
        print(f"✅ {shop.owner_name}店長の店舗で処理完了")
    except ValueError as e:
        # エラーメッセージ
        print(f"❌ エラー: {e}")


# ====================================
# 第4部: 多重継承（複数の親クラスから継承）
# ====================================

class OnlineService:
    """
    オンラインサービス機能を提供するミックスインクラス
    単独では使わず、他のクラスと組み合わせて使う
    """
    
    def __init__(self):
        """
        オンラインサービスの初期化
        """
        # オンラインサービス固有の変数
        self.online_orders = 0  # オンライン注文数
        self.website_url = "https://fuwafuwa-daifuku.com"  # ウェブサイトURL
        
        print(f"🌐 オンライン注文システム起動: {self.website_url}")
    
    def receive_online_order(self, quantity, customer_name):
        """
        オンライン注文を受け付けるメソッド
        
        Parameters:
            quantity (int): 注文個数
            customer_name (str): 顧客名
        """
        # オンライン注文数を増やす
        self.online_orders += 1
        
        # 注文受付メッセージ
        print(f"🌐 オンライン注文受付 #{self.online_orders}")
        print(f"   顧客: {customer_name}様")
        print(f"   数量: {quantity}個")
    
    def show_online_stats(self):
        """
        オンライン注文の統計を表示
        """
        print(f"🌐 オンライン注文総数: {self.online_orders}件")


class MembershipService:
    """
    会員サービス機能を提供するミックスインクラス
    """
    
    def __init__(self):
        """
        会員サービスの初期化
        """
        # 会員サービス固有の変数
        self.members = []  # 会員リスト
        self.points_system = True  # ポイントシステムの有無
        
        print(f"💳 会員サービス起動（ポイント制度あり）")
    
    def register_member(self, member_name):
        """
        会員登録するメソッド
        
        Parameters:
            member_name (str): 会員名
        """
        # 会員リストに追加
        self.members.append({
            "name": member_name,
            "points": 0,  # 初期ポイント0
            "member_id": len(self.members) + 1  # 会員ID
        })
        
        # 登録完了メッセージ
        print(f"💳 {member_name}様を会員登録しました（ID: {len(self.members)}）")
    
    def add_points(self, member_name, points):
        """
        会員にポイントを付与
        
        Parameters:
            member_name (str): 会員名
            points (int): 付与ポイント
        """
        # 会員を検索
        for member in self.members:
            if member["name"] == member_name:
                # ポイントを追加
                member["points"] += points
                
                print(f"💳 {member_name}様に{points}ポイント付与（合計: {member['points']}P）")
                return
        
        # 会員が見つからない場合
        print(f"❌ {member_name}様は未登録です")
    
    def show_members(self):
        """
        全会員情報を表示
        """
        print(f"\n💳 登録会員: {len(self.members)}名")
        for member in self.members:
            print(f"   ID:{member['member_id']} {member['name']}様 ({member['points']}P)")


class HybridDaifukuShop(DaifukuShop, OnlineService, MembershipService):
    """
    ハイブリッド大福店クラス（多重継承）
    
    継承関係:
    - DaifukuShop: 基本的な店舗機能
    - OnlineService: オンライン注文機能
    - MembershipService: 会員サービス機能
    
    3つの親クラスの機能をすべて持つ
    """
    
    # クラス変数
    shop_type = "ハイブリッド店舗"
    
    def __init__(self, owner_name, stock=10):
        """
        多重継承のコンストラクタ
        すべての親クラスを初期化する必要がある
        
        Parameters:
            owner_name (str): 店長名
            stock (int): 初期在庫
        """
        # ----- 各親クラスの初期化 -----
        # 方法1: super()を使う（推奨）
        # MRO（Method Resolution Order）に従って順番に初期化される
        
        # DaifukuShopの初期化
        DaifukuShop.__init__(self, owner_name, stock)
        
        # OnlineServiceの初期化
        OnlineService.__init__(self)
        
        # MembershipServiceの初期化
        MembershipService.__init__(self)
        
        # ハイブリッド店舗固有のメッセージ
        print(f"🌟 ハイブリッド店舗として全機能が利用可能です！")
    
    def process_order(self, quantity, customer_name, is_member=False, is_online=False):
        """
        統合注文処理メソッド
        複数の親クラスの機能を組み合わせて使う
        
        Parameters:
            quantity (int): 注文個数
            customer_name (str): 顧客名
            is_member (bool): 会員かどうか
            is_online (bool): オンライン注文かどうか
        """
        print(f"\n{'='*50}")
        print(f"🛒 注文処理開始: {customer_name}様")
        print(f"{'='*50}")
        
        # ----- オンライン注文の処理 -----
        if is_online:
            # OnlineServiceのメソッドを使用
            self.receive_online_order(quantity, customer_name)
        
        # ----- 販売処理 -----
        try:
            # DaifukuShopのメソッドを使用
            sale_amount = self.sell(quantity)
            
            # ----- 会員の場合はポイント付与 -----
            if is_member:
                # 購入金額の10%をポイントとして付与
                points = sale_amount // 10
                
                # MembershipServiceのメソッドを使用
                self.add_points(customer_name, points)
            
            print(f"✅ 注文処理完了！")
            
        except ValueError as e:
            print(f"❌ 注文処理失敗: {e}")
        
        print(f"{'='*50}\n")
    
    def show_status(self):
        """
        メソッドのオーバーライド
        すべての親クラスの情報を統合して表示
        """
        # DaifukuShopのshow_statusを呼び出す
        super().show_status()
        
        # オンライン注文の統計
        self.show_online_stats()
        
        # 会員情報
        self.show_members()
        
        print(f"{'='*50}\n")


# ====================================
# 第5部: MRO（Method Resolution Order）の確認
# ====================================

def show_mro(cls):
    """
    クラスのMRO（メソッド解決順序）を表示
    多重継承時にどの順番でメソッドが探索されるかを確認
    
    Parameters:
        cls: クラスオブジェクト
    """
    print(f"\n{'='*50}")
    print(f"📋 {cls.__name__}のMRO（メソッド解決順序）")
    print(f"{'='*50}")
    
    # MROを順番に表示
    for i, parent in enumerate(cls.__mro__, 1):
        print(f"{i}. {parent.__name__}")
    
    print(f"{'='*50}\n")


# ====================================
# 第6部: 実行とデモンストレーション
# ====================================

def main():
    """
    メイン実行関数
    各機能のデモンストレーション
    """
    
    print("🎯 " + "="*60)
    print("🐰 ふわふわ大福店 - 継承とポリモーフィズムのデモ")
    print("="*60 + "\n")
    
    # ==========================================
    # 1. 基本クラス（親クラス）のテスト
    # ==========================================
    print("【1】基本クラス（親クラス）のテスト")
    print("-" * 60)
    
    # 親クラスのインスタンスを作成
    basic_shop = DaifukuShop("うさうさ", stock=20)
    
    # 親クラスのメソッドを使用
    basic_shop.sell(5)  # 5個販売
    basic_shop.restock(10)  # 10個補充
    basic_shop.show_status()  # 状態表示
    
    # ==========================================
    # 2. 単一継承のテスト
    # ==========================================
    print("\n【2】単一継承（プレミアム店舗）のテスト")
    print("-" * 60)
    
    # 子クラスのインスタンスを作成
    premium_shop = PremiumDaifukuShop("もちもち", stock=15, vip_members=3)
    
    # 親クラスから継承したメソッド
    premium_shop.sell(3)  # 通常販売
    
    # 子クラス固有のメソッド
    premium_shop.sell_premium(2)  # プレミアム販売
    premium_shop.add_vip_member(2)  # VIP会員追加
    
    # オーバーライドしたメソッド
    premium_shop.show_status()  # 拡張された状態表示
    
    # ==========================================
    # 3. ポリモーフィズムのテスト
    # ==========================================
    print("\n【3】ポリモーフィズム（多態性）のテスト")
    print("-" * 60)
    
    # 配達専門店を作成
    delivery_shop = DeliveryDaifukuShop("ぴょんぴょん", stock=25, delivery_range=10)
    
    # 異なるクラスのインスタンスを同じ関数で処理
    # これがポリモーフィズム！
    print("\n同じ関数で異なるクラスを処理:")
    process_sale(basic_shop, 2)  # 基本店舗
    process_sale(premium_shop, 1)  # プレミアム店舗
    process_sale(delivery_shop, 3)  # 配達専門店
    
    # 配達専門店の状態表示
    delivery_shop.show_status()
    
    # ==========================================
    # 4. 多重継承のテスト
    # ==========================================
    print("\n【4】多重継承（ハイブリッド店舗）のテスト")
    print("-" * 60)
    
    # 多重継承のインスタンスを作成
    hybrid_shop = HybridDaifukuShop("ハイブリうさ", stock=30)
    
    # 会員登録（MembershipServiceの機能）
    hybrid_shop.register_member("田中太郎")
    hybrid_shop.register_member("佐藤花子")
    hybrid_shop.register_member("鈴木一郎")
    
    print("\n" + "-" * 60)
    
    # 統合注文処理（複数の親クラスの機能を組み合わせ）
    hybrid_shop.process_order(5, "田中太郎", is_member=True, is_online=False)
    hybrid_shop.process_order(3, "佐藤花子", is_member=True, is_online=True)
    hybrid_shop.process_order(2, "山田次郎", is_member=False, is_online=True)
    
    # ハイブリッド店舗の総合状態表示
    hybrid_shop.show_status()
    
    # ==========================================
    # 5. MRO（メソッド解決順序）の確認
    # ==========================================
    print("\n【5】MRO（メソッド解決順序）の確認")
    print("-" * 60)
    
    # 各クラスのMROを表示
    show_mro(DaifukuShop)
    show_mro(PremiumDaifukuShop)
    show_mro(HybridDaifukuShop)
    
    # ==========================================
    # 6. 継承関係の確認
    # ==========================================
    print("\n【6】継承関係の確認（isinstance と issubclass）")
    print("-" * 60)
    
    # isinstance: インスタンスが特定のクラスのインスタンスかチェック
    print(f"hybrid_shopはDaifukuShopのインスタンス？ {isinstance(hybrid_shop, DaifukuShop)}")
    print(f"hybrid_shopはOnlineServiceのインスタンス？ {isinstance(hybrid_shop, OnlineService)}")
    print(f"hybrid_shopはMembershipServiceのインスタンス？ {isinstance(hybrid_shop, MembershipService)}")
    
    print()
    
    # issubclass: クラスが特定のクラスのサブクラスかチェック
    print(f"HybridDaifukuShopはDaifukuShopのサブクラス？ {issubclass(HybridDaifukuShop, DaifukuShop)}")
    print(f"PremiumDaifukuShopはDaifukuShopのサブクラス？ {issubclass(PremiumDaifukuShop, DaifukuShop)}")
    print(f"DaifukuShopはHybridDaifukuShopのサブクラス？ {issubclass(DaifukuShop, HybridDaifukuShop)}")
    
    print("\n" + "="*60)
    print("🎉 デモンストレーション完了！")
    print("="*60)


# ====================================
# プログラムのエントリーポイント
# ====================================

if __name__ == "__main__":
    # このファイルが直接実行された場合のみmain()を実行
    main()



##############################
