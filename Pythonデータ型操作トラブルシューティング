# ==========================================================
# Pythonデータ型操作トラブルシューティング完全ガイド
# ==========================================================

"""
【よくあるデータ型のトラブル】

1. IndexError - リストの範囲外アクセス
2. KeyError - 辞書のキーが存在しない
3. TypeError - 型が違う
4. ValueError - 値が不正
5. AttributeError - 存在しないメソッド
6. 文字列と数値の混在
7. リストのコピー問題
8. 辞書の順序問題
9. セットの順序がない
10. タプルが変更できない
"""

print("=" * 70)
print("Pythonデータ型操作トラブルシューティング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】IndexError - リストの範囲外アクセス
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル1】IndexError: list index out of range")
print("=" * 70)

trouble1 = """
■ エラーメッセージ：
  IndexError: list index out of range

■ 原因：
  存在しないインデックスにアクセスしようとした

■ 悪い例：
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]
print(fruits[3])  # エラー！インデックスは0-2まで
-----------------------------------------------------------

■ 解決方法1：インデックスを確認
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]

# リストの長さを確認
print(f"要素数: {len(fruits)}")  # 3

# 最後の要素にアクセス
print(fruits[len(fruits) - 1])  # オレンジ
print(fruits[-1])  # オレンジ（負のインデックス）
-----------------------------------------------------------

■ 解決方法2：範囲チェック
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]
index = 5

# 安全なアクセス
if index < len(fruits):
    print(fruits[index])
else:
    print(f"インデックス {index} は範囲外です")
-----------------------------------------------------------

■ 解決方法3：try-except
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]

try:
    print(fruits[5])
except IndexError:
    print("インデックスが範囲外です")
    print(f"有効な範囲: 0-{len(fruits)-1}")
-----------------------------------------------------------

■ 解決方法4：get関数（リストにはないが自作可能）
-----------------------------------------------------------
def safe_get(lst, index, default=None):
    '''安全にリストの要素を取得'''
    try:
        return lst[index]
    except IndexError:
        return default

fruits = ["りんご", "バナナ", "オレンジ"]
print(safe_get(fruits, 5, "なし"))  # なし
print(safe_get(fruits, 1, "なし"))  # バナナ
-----------------------------------------------------------

■ よくある間違い：
-----------------------------------------------------------
# ❌ 間違い1：範囲を超えたループ
fruits = ["りんご", "バナナ", "オレンジ"]
for i in range(5):  # 5回ループ（範囲外！）
    print(fruits[i])  # エラー

# ✅ 正しい方法
for i in range(len(fruits)):  # 3回ループ
    print(fruits[i])

# ✅ もっと良い方法（インデックス不要）
for fruit in fruits:
    print(fruit)

# ❌ 間違い2：空リストへのアクセス
empty = []
print(empty[0])  # エラー

# ✅ 正しい方法
if empty:  # リストが空でないかチェック
    print(empty[0])
else:
    print("リストが空です")
-----------------------------------------------------------
"""

print(trouble1)

# 実際に動作例
print("\n■ 動作例")
fruits = ["りんご", "バナナ", "オレンジ"]
print(f"リスト: {fruits}")
print(f"要素数: {len(fruits)}")
print(f"有効なインデックス: 0-{len(fruits)-1}")

try:
    print(f"fruits[3]: {fruits[3]}")
except IndexError as e:
    print(f"❌ エラー: {e}")
    print(f"✅ 正しい: fruits[2] = {fruits[2]}")

# ==========================================================
# 【2】KeyError - 辞書のキーが存在しない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル2】KeyError: キーが存在しない")
print("=" * 70)

trouble2 = """
■ エラーメッセージ：
  KeyError: 'phone'

■ 原因：
  辞書に存在しないキーにアクセスしようとした

■ 悪い例：
-----------------------------------------------------------
user = {"name": "田中", "age": 30}
print(user["phone"])  # エラー！phoneキーは存在しない
-----------------------------------------------------------

■ 解決方法1：get()メソッド（推奨）
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# getメソッド（存在しなければNoneを返す）
phone = user.get("phone")
print(phone)  # None

# デフォルト値を指定
phone = user.get("phone", "登録なし")
print(phone)  # 登録なし
-----------------------------------------------------------

■ 解決方法2：in 演算子でチェック
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# キーの存在確認
if "phone" in user:
    print(user["phone"])
else:
    print("電話番号が登録されていません")
-----------------------------------------------------------

■ 解決方法3：try-except
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

try:
    print(user["phone"])
except KeyError:
    print("キー 'phone' が存在しません")
-----------------------------------------------------------

■ 解決方法4：setdefault()
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# キーがなければ追加、あれば値を返す
phone = user.setdefault("phone", "未登録")
print(phone)  # 未登録
print(user)   # {'name': '田中', 'age': 30, 'phone': '未登録'}
-----------------------------------------------------------

■ 解決方法5：defaultdict（上級）
-----------------------------------------------------------
from collections import defaultdict

# 存在しないキーは自動的にデフォルト値を返す
user = defaultdict(lambda: "未設定")
user["name"] = "田中"
user["age"] = 30

print(user["phone"])  # 未設定（エラーにならない）
-----------------------------------------------------------

■ よくある間違い：
-----------------------------------------------------------
# ❌ 間違い：キーのスペルミス
user = {"name": "田中", "age": 30}
print(user["neme"])  # KeyError（nameのスペルミス）

# ✅ 正しい方法：getを使う
print(user.get("neme", "キーが見つかりません"))

# ❌ 間違い：大文字小文字の違い
user = {"Name": "田中"}
print(user["name"])  # KeyError（Nが大文字）

# ✅ 正しい方法：キーを確認
print(list(user.keys()))  # ['Name']
print(user["Name"])       # 田中
-----------------------------------------------------------
"""

print(trouble2)

# 実際に動作例
print("\n■ 動作例")
user = {"name": "田中", "age": 30, "email": "tanaka@example.com"}
print(f"ユーザー情報: {user}")

# 安全なアクセス
print(f"名前: {user.get('name', 'なし')}")
print(f"電話: {user.get('phone', '未登録')}")

# キーの存在確認
keys_to_check = ["name", "phone", "email"]
for key in keys_to_check:
    if key in user:
        print(f"✅ {key}: {user[key]}")
    else:
        print(f"❌ {key}: キーが存在しません")

# ==========================================================
# 【3】TypeError - 型が違う
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル3】TypeError: 型が合わない")
print("=" * 70)

trouble3 = """
■ よくあるTypeErrorパターン

パターン1: 文字列と数値の連結
-----------------------------------------------------------
# ❌ エラー
age = 30
message = "年齢は" + age + "歳です"  # TypeError

# ✅ 解決方法1：str()で変換
age = 30
message = "年齢は" + str(age) + "歳です"
print(message)  # 年齢は30歳です

# ✅ 解決方法2：f-string（推奨）
age = 30
message = f"年齢は{age}歳です"
print(message)  # 年齢は30歳です

# ✅ 解決方法3：format()
age = 30
message = "年齢は{}歳です".format(age)
print(message)  # 年齢は30歳です
-----------------------------------------------------------

パターン2: 整数と文字列の計算
-----------------------------------------------------------
# ❌ エラー
num = "10"
result = num + 5  # TypeError

# ✅ 解決：int()で変換
num = "10"
result = int(num) + 5
print(result)  # 15

# 注意：変換できない文字列
try:
    result = int("abc") + 5
except ValueError:
    print("数値に変換できません")
-----------------------------------------------------------

パターン3: リストと文字列の混在
-----------------------------------------------------------
# ❌ エラー
items = ["a", "b", "c"]
result = items + "d"  # TypeError

# ✅ 解決：リストとして追加
items = ["a", "b", "c"]
items.append("d")  # ['a', 'b', 'c', 'd']

# または
items = ["a", "b", "c"]
result = items + ["d"]  # ['a', 'b', 'c', 'd']
-----------------------------------------------------------

パターン4: Noneとの計算
-----------------------------------------------------------
# ❌ エラー
value = None
result = value + 10  # TypeError

# ✅ 解決：Noneチェック
value = None
if value is not None:
    result = value + 10
else:
    result = 10  # デフォルト値
print(result)  # 10

# ✅ または三項演算子
value = None
result = (value if value is not None else 0) + 10
print(result)  # 10
-----------------------------------------------------------

パターン5: イミュータブルな型の変更
-----------------------------------------------------------
# ❌ エラー：タプルは変更できない
my_tuple = (1, 2, 3)
my_tuple[0] = 10  # TypeError

# ✅ 解決：リストに変換して変更
my_tuple = (1, 2, 3)
my_list = list(my_tuple)  # [1, 2, 3]
my_list[0] = 10           # [10, 2, 3]
my_tuple = tuple(my_list) # (10, 2, 3)
-----------------------------------------------------------

パターン6: 関数呼び出しのミス
-----------------------------------------------------------
# ❌ エラー：文字列は呼び出せない
text = "Hello"
result = text()  # TypeError: 'str' object is not callable

# よくある原因：変数名が関数名と同じ
list = [1, 2, 3]  # listという組み込み関数を上書き
result = list("abc")  # エラー

# ✅ 解決：変数名を変える
my_list = [1, 2, 3]
result = list("abc")  # ['a', 'b', 'c']
-----------------------------------------------------------
"""

print(trouble3)

# 実際に動作例
print("\n■ 動作例：型変換")

# 文字列と数値
age = 30
print(f"❌ 連結できない: '年齢は' + {age}")
print(f"✅ f-string: 年齢は{age}歳です")
print(f"✅ str変換: 年齢は{str(age)}歳です")

# 文字列を数値に
num_str = "123"
print(f"\n文字列: '{num_str}' (型: {type(num_str).__name__})")
num_int = int(num_str)
print(f"数値: {num_int} (型: {type(num_int).__name__})")
print(f"計算: {num_int} + 10 = {num_int + 10}")

# ==========================================================
# 【4】ValueError - 値が不正
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル4】ValueError: 値が不正")
print("=" * 70)

trouble4 = """
■ よくあるValueErrorパターン

パターン1: 文字列を数値に変換できない
-----------------------------------------------------------
# ❌ エラー
text = "abc"
number = int(text)  # ValueError

# ✅ 解決：try-except
text = "abc"
try:
    number = int(text)
except ValueError:
    print(f"'{text}' は数値に変換できません")
    number = 0  # デフォルト値

# ✅ 解決：検証関数を作る
def safe_int(value, default=0):
    '''安全に整数に変換'''
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

print(safe_int("123"))    # 123
print(safe_int("abc"))    # 0
print(safe_int("abc", -1))  # -1
-----------------------------------------------------------

パターン2: リストから存在しない要素を削除
-----------------------------------------------------------
# ❌ エラー
fruits = ["りんご", "バナナ"]
fruits.remove("オレンジ")  # ValueError

# ✅ 解決：存在確認
fruits = ["りんご", "バナナ"]
if "オレンジ" in fruits:
    fruits.remove("オレンジ")
else:
    print("オレンジは含まれていません")

# ✅ 解決：try-except
try:
    fruits.remove("オレンジ")
except ValueError:
    print("要素が見つかりません")
-----------------------------------------------------------

パターン3: リストのindex()
-----------------------------------------------------------
# ❌ エラー
numbers = [1, 2, 3, 4, 5]
index = numbers.index(10)  # ValueError

# ✅ 解決：存在確認
numbers = [1, 2, 3, 4, 5]
if 10 in numbers:
    index = numbers.index(10)
else:
    print("値が見つかりません")
    index = -1

# ✅ 解決：安全な関数
def safe_index(lst, value, default=-1):
    '''安全にインデックスを取得'''
    try:
        return lst.index(value)
    except ValueError:
        return default

print(safe_index([1, 2, 3], 2))   # 1
print(safe_index([1, 2, 3], 10))  # -1
-----------------------------------------------------------

パターン4: unpack時の値の数が合わない
-----------------------------------------------------------
# ❌ エラー：値が3つなのに2つの変数
a, b = [1, 2, 3]  # ValueError

# ✅ 解決：変数の数を合わせる
a, b, c = [1, 2, 3]
print(a, b, c)  # 1 2 3

# ✅ 解決：*で残りを受け取る
a, b, *rest = [1, 2, 3, 4, 5]
print(a, b, rest)  # 1 2 [3, 4, 5]

# ✅ 解決：最初と最後だけ取る
first, *middle, last = [1, 2, 3, 4, 5]
print(first, middle, last)  # 1 [2, 3, 4] 5
-----------------------------------------------------------
"""

print(trouble4)

# 実際に動作例
print("\n■ 動作例：安全な変換")

def safe_convert(value, convert_func, default=None):
    """安全に型変換する汎用関数"""
    try:
        return convert_func(value)
    except (ValueError, TypeError) as e:
        print(f"❌ 変換失敗: {value} → {e}")
        return default

# テスト
test_values = ["123", "abc", "45.67", None, ""]
for val in test_values:
    result = safe_convert(val, int, default=0)
    print(f"'{val}' → {result}")

# ==========================================================
# 【5】リストのコピー問題（浅いコピー vs 深いコピー）
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル5】リストのコピー問題")
print("=" * 70)

trouble5 = """
■ 問題：リストをコピーしたつもりが...
-----------------------------------------------------------
# ❌ 間違い：代入は参照のコピー
list1 = [1, 2, 3]
list2 = list1  # 同じリストを指している
list2.append(4)
print(list1)  # [1, 2, 3, 4] ← list1も変わる！
print(list2)  # [1, 2, 3, 4]
-----------------------------------------------------------

■ 解決方法1：浅いコピー（シンプルなリストの場合）
-----------------------------------------------------------
# 方法A：スライス
list1 = [1, 2, 3]
list2 = list1[:]  # 新しいリストを作成
list2.append(4)
print(list1)  # [1, 2, 3] ← 変わらない
print(list2)  # [1, 2, 3, 4]

# 方法B：list()
list1 = [1, 2, 3]
list2 = list(list1)

# 方法C：copy()
list1 = [1, 2, 3]
list2 = list1.copy()
-----------------------------------------------------------

■ 解決方法2：深いコピー（ネストしたリストの場合）
-----------------------------------------------------------
import copy

# 問題：浅いコピーではネストが共有される
list1 = [[1, 2], [3, 4]]
list2 = list1.copy()  # 浅いコピー
list2[0].append(99)
print(list1)  # [[1, 2, 99], [3, 4]] ← 変わる！

# 解決：深いコピー
list1 = [[1, 2], [3, 4]]
list2 = copy.deepcopy(list1)  # 深いコピー
list2[0].append(99)
print(list1)  # [[1, 2], [3, 4]] ← 変わらない
print(list2)  # [[1, 2, 99], [3, 4]]
-----------------------------------------------------------

■ 辞書でも同じ問題
-----------------------------------------------------------
# ❌ 間違い
dict1 = {"name": "田中", "scores": [80, 90]}
dict2 = dict1  # 参照のコピー
dict2["scores"].append(100)
print(dict1)  # {'name': '田中', 'scores': [80, 90, 100]}

# ✅ 解決：浅いコピー
dict1 = {"name": "田中", "age": 30}
dict2 = dict1.copy()
dict2["age"] = 31
print(dict1)  # {'name': '田中', 'age': 30}

# ✅ 解決：深いコピー（ネストがある場合）
import copy
dict1 = {"name": "田中", "scores": [80, 90]}
dict2 = copy.deepcopy(dict1)
dict2["scores"].append(100)
print(dict1)  # {'name': '田中', 'scores': [80, 90]}
-----------------------------------------------------------
"""

print(trouble5)

# 実際に動作例
print("\n■ 動作例：コピーの違い")
import copy

# 参照のコピー（危険）
print("【参照のコピー】")
list1 = [1, 2, [3, 4]]
list2 = list1
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4, 5]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ 両方変わる！")

# 浅いコピー
print("\n【浅いコピー】")
list1 = [1, 2, [3, 4]]
list2 = list1.copy()
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4, 5]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ ネストは共有される")

# 深いコピー
print("\n【深いコピー】")
list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ 完全に独立")

# ==========================================================
# 【6】チートシート：エラー対処法まとめ
# ==========================================================

print("\n" + "=" * 70)
print("【チートシート】エラー対処法まとめ")
print("=" * 70)

cheatsheet = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃           データ型エラー対処法チートシート             ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■ IndexError（リストの範囲外）
┌────────────────────────────────────────────────┐
│ エラー: fruits[3]                             │
│ 解決1: if index < len(fruits):               │
│ 解決2: try-except IndexError                 │
│ 解決3: fruits[-1] で最後の要素               │
└────────────────────────────────────────────────┘

■ KeyError（辞書のキーなし）
┌────────────────────────────────────────────────┐
│ エラー: user["phone"]                         │
│ 解決1: user.get("phone", "デフォルト")  ★推奨│
│ 解決2: if "phone" in user:                   │
│ 解決3: try-except KeyError                   │
└────────────────────────────────────────────────┘

■ TypeError（型が違う）
┌────────────────────────────────────────────────┐
│ エラー: "年齢は" + 30                         │
│ 解決1: f"年齢は{30}歳"  ★推奨                │
│ 解決2: "年齢は" + str(30)                     │
│ 解決3: "年齢は{}歳".format(30)                │
└────────────────────────────────────────────────┘

■ ValueError（値が不正）
┌────────────────────────────────────────────────┐
│ エラー: int("abc")                            │
│ 解決1: try-except ValueError                 │
│ 解決2: if value.isdigit():                   │
│ 解決3: 安全な変換関数を作る                   │
└────────────────────────────────────────────────┘

■ リストのコピー
┌────────────────────────────────────────────────┐
│ ❌: list2 = list1  # 参照のコピー（危険）     │
│ ✅: list2 = list1.copy()  # 浅いコピー        │
│ ✅: list2 = list1[:]      # 浅いコピー        │
│ ✅: list2 = copy.deepcopy(list1)  # 深い      │
└────────────────────────────────────────────────┘

■ 型チェック
┌────────────────────────────────────────────────┐
│ type(x)                 # 型を取得            │
│ isinstance(x, int)      # int型かチェック     │
│ isinstance(x, (int, float))  # 複数型チェック │
└────────────────────────────────────────────────┘

■ 安全な操作パターン
┌────────────────────────────────────────────────┐
│ # リスト                                      │
│ item = lst[i] if i < len(lst) else None      │
│                                               │
│ # 辞書                                        │
│ value = dct.get(key, default)                 │
│                                               │
│ # 変換                                        │
│ try:                                          │
│     num = int(text)                           │
│ except ValueError:                            │
│     num = 0                                   │
└────────────────────────────────────────────────┘
"""

print(cheatsheet)

print("\n" + "=" * 70)
print("これでデータ型のトラブルは解決！")
print("=" * 70)
