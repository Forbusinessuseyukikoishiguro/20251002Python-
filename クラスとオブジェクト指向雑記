クラスとオブジェクト指向について、超詳しいガイドを作成しますね！

# ==========================================================
# Pythonオブジェクト指向プログラミング完全ガイド
# ==========================================================

"""
【オブジェクト指向とは？】

簡単に言うと：
  「モノ」を中心にプログラムを組み立てる考え方
  
例：
  犬という「モノ」は...
  - 属性: 名前、年齢、犬種
  - 行動: 吠える、走る、食べる
  
  これを「クラス」として定義する

重要な概念：
  1. クラス          設計図
  2. インスタンス    実際のモノ
  3. 継承           親子関係
  4. ポリモーフィズム 同じ命令で違う動き
  5. カプセル化      隠蔽（public/private）
"""

print("=" * 70)
print("Pythonオブジェクト指向プログラミング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】クラスとインスタンスの基本
# ==========================================================

print("\n" + "=" * 70)
print("【1】クラスとインスタンス - 設計図と実物")
print("=" * 70)

# --- 最もシンプルなクラス ---
class Dog:
    """犬を表すクラス（設計図）"""
    
    def __init__(self, name, age):
        """
        コンストラクタ: インスタンス作成時に呼ばれる
        self: 自分自身を指す（必須）
        """
        self.name = name  # インスタンス変数（属性）
        self.age = age    # インスタンス変数（属性）
    
    def bark(self):
        """メソッド: インスタンスの行動"""
        return f"{self.name}「ワンワン！」"
    
    def get_info(self):
        """情報を返すメソッド"""
        return f"{self.name}（{self.age}歳）"

# --- インスタンスの作成 ---
print("\n■ インスタンスを作る")
dog1 = Dog("ポチ", 3)      # インスタンス1を作成
dog2 = Dog("タロー", 5)    # インスタンス2を作成

print(f"犬1: {dog1.get_info()}")  # ポチ（3歳）
print(f"犬2: {dog2.get_info()}")  # タロー（5歳）
print(dog1.bark())  # ポチ「ワンワン！」
print(dog2.bark())  # タロー「ワンワン！」

# --- クラス vs インスタンス ---
print("\n■ クラスとインスタンスの違い")
print("""
クラス（Dog）          : 設計図、レシピ
インスタンス（dog1）   : 実際に作られた物

例え：
  クラス      = たい焼きの型
  インスタンス = 実際に焼いたたい焼き
  
  同じ型（クラス）から、
  何個でもたい焼き（インスタンス）を作れる！
""")

# ==========================================================
# 【2】メリット - なぜクラスを使うのか？
# ==========================================================

print("\n" + "=" * 70)
print("【2】クラスを使うメリット")
print("=" * 70)

print("""
■ メリット1: コードの整理
  関連するデータと機能をまとめられる
  
  クラスなし:
    user_name = "田中"
    user_age = 30
    user_email = "tanaka@example.com"
    
    def get_user_info(name, age, email):
        return f"{name}（{age}歳）"
    
    # 関数呼び出しが面倒...
    get_user_info(user_name, user_age, user_email)
  
  クラスあり:
    user = User("田中", 30, "tanaka@example.com")
    user.get_info()  # シンプル！

■ メリット2: 再利用性
  一度クラスを作れば、何度でも使い回せる
  
  user1 = User("田中", 30, "tanaka@xx.com")
  user2 = User("佐藤", 25, "sato@xx.com")
  user3 = User("鈴木", 35, "suzuki@xx.com")

■ メリット3: 保守性
  変更が1箇所で済む
  
  クラスの定義を変えれば、
  全てのインスタンスに反映される

■ メリット4: 現実世界のモデル化
  現実の「モノ」をそのままコードにできる
  
  例: ゲーム
    - プレイヤークラス
    - 敵クラス
    - アイテムクラス

■ メリット5: チーム開発
  クラスごとに担当を分けられる
  インターフェース（使い方）を決めれば、
  中身は別々に作れる
""")

# ==========================================================
# 【3】public と private - カプセル化
# ==========================================================

print("\n" + "=" * 70)
print("【3】public と private - 情報の隠蔽")
print("=" * 70)

class BankAccount:
    """銀行口座クラス - カプセル化の例"""
    
    def __init__(self, owner, initial_balance=0):
        # public属性（普通の属性）
        self.owner = owner  # 誰でもアクセス可能
        
        # protected属性（_で始まる）慣習的に内部使用
        self._account_number = "123-456-789"
        
        # private属性（__で始まる）外部から直接アクセス不可
        self.__balance = initial_balance  # 残高は隠す
    
    # publicメソッド（外部から使える）
    def deposit(self, amount):
        """入金（公開メソッド）"""
        if amount > 0:
            self.__balance += amount  # privateにアクセス
            return f"{amount}円を入金しました"
        return "入金額は正の数である必要があります"
    
    def withdraw(self, amount):
        """出金（公開メソッド）"""
        if amount > self.__balance:
            return "残高不足です"
        self.__balance -= amount
        return f"{amount}円を出金しました"
    
    # getter（privateな値を取得）
    def get_balance(self):
        """残高を取得"""
        return self.__balance
    
    # setter（privateな値を設定）
    def set_balance(self, amount):
        """残高を設定（検証付き）"""
        if amount >= 0:
            self.__balance = amount
        else:
            raise ValueError("残高は0以上である必要があります")
    
    # protectedメソッド（_で始まる）
    def _internal_process(self):
        """内部処理用メソッド"""
        return "内部処理中..."
    
    # privateメソッド（__で始まる）
    def __validate(self, amount):
        """検証用のプライベートメソッド"""
        return amount > 0

# --- 使用例 ---
print("\n■ public と private の動作")
account = BankAccount("田中太郎", 10000)

# public属性はアクセス可能
print(f"口座名義: {account.owner}")  # OK

# publicメソッドで操作
print(account.deposit(5000))         # OK
print(f"残高: {account.get_balance()}円")  # OK

# private属性に直接アクセスしようとすると...
# print(account.__balance)  # エラー！AttributeError

# 正しい方法: getterを使う
print(f"残高（正しい方法）: {account.get_balance()}円")

print("\n■ アクセス制御のまとめ")
print("""
┌─────────────┬────────────┬──────────────┐
│ 記法        │ 名前       │ アクセス     │
├─────────────┼────────────┼──────────────┤
│ name        │ public     │ どこからでも │
│ _name       │ protected  │ 慣習的に内部 │
│ __name      │ private    │ 外部不可     │
└─────────────┴────────────┴──────────────┘

注意: Pythonには厳密なprivateはない
     __name は名前マングリングで隠蔽されるだけ
     _ClassName__name でアクセス可能（非推奨）
""")

# ==========================================================
# 【4】継承 - 親子関係
# ==========================================================

print("\n" + "=" * 70)
print("【4】継承 - 親クラスと子クラス")
print("=" * 70)

# --- 親クラス（基底クラス）---
class Animal:
    """動物クラス（親）"""
    
    def __init__(self, name, age):
        self.name = name  # 名前
        self.age = age    # 年齢
    
    def eat(self):
        """食べる（共通の行動）"""
        return f"{self.name}が食べています"
    
    def sleep(self):
        """寝る（共通の行動）"""
        return f"{self.name}が寝ています"
    
    def speak(self):
        """鳴く（子クラスでオーバーライドされる）"""
        return f"{self.name}が何か音を出しています"

# --- 子クラス1（派生クラス）---
class Cat(Animal):  # Animalを継承
    """猫クラス（子）"""
    
    def __init__(self, name, age, color):
        # 親クラスのコンストラクタを呼ぶ
        super().__init__(name, age)
        # 子クラス独自の属性
        self.color = color
    
    def speak(self):
        """メソッドのオーバーライド（上書き）"""
        return f"{self.name}「ニャー」"
    
    def scratch(self):
        """猫独自のメソッド"""
        return f"{self.name}が爪を研いでいます"

# --- 子クラス2 ---
class Bird(Animal):  # Animalを継承
    """鳥クラス（子）"""
    
    def __init__(self, name, age, can_fly=True):
        super().__init__(name, age)
        self.can_fly = can_fly
    
    def speak(self):
        """メソッドのオーバーライド"""
        return f"{self.name}「ピヨピヨ」"
    
    def fly(self):
        """鳥独自のメソッド"""
        if self.can_fly:
            return f"{self.name}が飛んでいます"
        return f"{self.name}は飛べません"

# --- 使用例 ---
print("\n■ 継承の動作確認")
cat = Cat("タマ", 3, "三毛")
bird = Bird("ピーちゃん", 1, can_fly=True)

# 親クラスのメソッドが使える
print(cat.eat())    # Animalから継承
print(bird.sleep()) # Animalから継承

# 子クラスでオーバーライドされたメソッド
print(cat.speak())  # ニャー
print(bird.speak()) # ピヨピヨ

# 子クラス独自のメソッド
print(cat.scratch())  # 猫だけ
print(bird.fly())     # 鳥だけ

print("\n■ 継承のメリット")
print("""
✅ コードの再利用
   共通部分（eat, sleep）は親に書くだけ
   
✅ 階層構造
   Animal
   ├── Cat
   ├── Dog
   └── Bird
   
✅ 拡張が容易
   新しい動物を追加しやすい
   
✅ 保守性
   共通処理の変更が1箇所で済む
""")

# ==========================================================
# 【5】ポリモーフィズム - 多態性
# ==========================================================

print("\n" + "=" * 70)
print("【5】ポリモーフィズム - 同じ命令で違う動き")
print("=" * 70)

# ポリモーフィズムの実演
def make_sound(animal):
    """どんな動物でも鳴かせる関数"""
    print(animal.speak())  # 同じメソッド名を呼ぶだけ

# 異なる種類の動物を作成
animals = [
    Cat("ミケ", 2, "三毛"),
    Bird("ポッポ", 1, True),
    Cat("クロ", 4, "黒"),
    Bird("ペンペン", 3, False)
]

print("\n■ ポリモーフィズムの実演")
for animal in animals:
    make_sound(animal)  # 同じ関数で違う結果！

print("\n■ ポリモーフィズムとは")
print("""
「同じ命令」で「違う動作」をする仕組み

例：
  make_sound(猫)  → ニャー
  make_sound(鳥)  → ピヨピヨ
  make_sound(犬)  → ワンワン
  
  関数は animal.speak() を呼ぶだけ
  具体的な動作は各クラスが決める

メリット:
  ✅ 柔軟なコード
  ✅ 拡張が容易（新しい動物を追加しやすい）
  ✅ 統一されたインターフェース
""")

# ==========================================================
# 【6】オーバーライド vs オーバーロード
# ==========================================================

print("\n" + "=" * 70)
print("【6】オーバーライド vs オーバーロード")
print("=" * 70)

# --- オーバーライド ---
print("\n■ オーバーライド（上書き）")

class Parent:
    """親クラス"""
    def greet(self):
        return "こんにちは（親）"

class Child(Parent):
    """子クラス"""
    def greet(self):
        """親のメソッドをオーバーライド"""
        return "こんにちは（子）"

parent = Parent()
child = Child()
print(f"親: {parent.greet()}")  # こんにちは（親）
print(f"子: {child.greet()}")   # こんにちは（子）← 上書きされた

# --- オーバーロード（Pythonでは特殊）---
print("\n■ オーバーロード（Pythonの方法）")

class Calculator:
    """計算機クラス"""
    
    # Pythonには厳密なオーバーロードがない
    # デフォルト引数で実現
    def add(self, a, b=0, c=0):
        """
        引数の数に応じて動作が変わる
        add(5)      → 5 + 0 + 0 = 5
        add(5, 3)   → 5 + 3 + 0 = 8
        add(5, 3, 2) → 5 + 3 + 2 = 10
        """
        return a + b + c
    
    # 可変長引数でも実現可能
    def multiply(self, *args):
        """
        任意の個数の引数を掛け算
        multiply(2, 3)       → 6
        multiply(2, 3, 4)    → 24
        multiply(2, 3, 4, 5) → 120
        """
        result = 1
        for num in args:
            result *= num
        return result

calc = Calculator()
print(f"add(5): {calc.add(5)}")           # 5
print(f"add(5, 3): {calc.add(5, 3)}")     # 8
print(f"add(5, 3, 2): {calc.add(5, 3, 2)}")  # 10
print(f"multiply(2, 3): {calc.multiply(2, 3)}")        # 6
print(f"multiply(2, 3, 4): {calc.multiply(2, 3, 4)}")  # 24

print("\n■ オーバーライド vs オーバーロード")
print("""
┌──────────────┬────────────────────────┐
│ オーバーライド │ 親のメソッドを子が上書き │
│ (Override)   │ 継承で使う             │
├──────────────┼────────────────────────┤
│ オーバーロード │ 同じ名前で引数が違う   │
│ (Overload)   │ Pythonは非対応*        │
└──────────────┴────────────────────────┘

*Pythonでは:
  - デフォルト引数
  - 可変長引数（*args, **kwargs）
  で似たことを実現
""")

# ==========================================================
# 【7】チートシート - OOPの全体像
# ==========================================================

print("\n" + "=" * 70)
print("【7】オブジェクト指向チートシート")
print("=" * 70)

cheatsheet = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃        オブジェクト指向プログラミング全体像        ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■ 基本用語
┌─────────────┬──────────────────────────┐
│ クラス      │ 設計図、レシピ、型        │
│ インスタンス│ 実際に作られた物          │
│ 属性        │ データ（変数）            │
│ メソッド    │ 動作（関数）              │
│ self        │ 自分自身を指す            │
│ __init__    │ コンストラクタ（初期化）  │
└─────────────┴──────────────────────────┘

■ アクセス制御
┌────────┬─────────┬──────────────┐
│ 記法   │ 意味    │ 外部アクセス │
├────────┼─────────┼──────────────┤
│ name   │ public  │ ○           │
│ _name  │ protect │ △（慣習）   │
│ __name │ private │ ×           │
└────────┴─────────┴──────────────┘

■ 継承
  class 子クラス(親クラス):
      def __init__(self):
          super().__init__()  # 親の初期化
  
  用語:
    - 親クラス = 基底クラス = スーパークラス
    - 子クラス = 派生クラス = サブクラス
  
  メリット:
    ✅ コードの再利用
    ✅ 階層構造
    ✅ 拡張が容易

■ ポリモーフィズム
  同じメソッド名で違う動作
  
  例:
    animal.speak()
    ├─ 猫なら「ニャー」
    ├─ 犬なら「ワンワン」
    └─ 鳥なら「ピヨピヨ」
  
  実現方法:
    - オーバーライド（メソッドの上書き）

■ オーバーライド vs オーバーロード
  オーバーライド:
    親のメソッドを子が上書き
    class Child(Parent):
        def method(self):  # 親を上書き
            pass
  
  オーバーロード:
    同じ名前で引数違い（Pythonは非対応）
    → デフォルト引数や*argsで代用

■ カプセル化
  データと機能をまとめて、内部を隠す
  
  目的:
    ✅ データ保護
    ✅ 使いやすいインターフェース
    ✅ 変更の影響を最小化
  
  実装:
    - privateな属性（__balance）
    - publicなメソッド（get_balance）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ クラス設計のフローチャート

Q1: 共通する属性や動作がある？
    ├─ YES → クラスを作る
    └─ NO  → 関数で十分

Q2: 似たようなクラスが複数ある？
    ├─ YES → 親クラスに共通部分をまとめる（継承）
    └─ NO  → 単独のクラス

Q3: 外部から直接変更されたくない属性がある？
    ├─ YES → private（__属性）にする
    └─ NO  → publicのまま

Q4: 同じメソッド名で違う動作が必要？
    ├─ YES → オーバーライド
    └─ NO  → 新しいメソッド名

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ よくあるパターン

パターン1: データの管理
  class User:
      def __init__(self, name, email):
          self.name = name
          self.email = email

パターン2: 処理のカプセル化
  class FileManager:
      def read(self, path):
          pass
      def write(self, path, data):
          pass

パターン3: 階層構造
  class Vehicle:        # 乗り物（親）
      pass
  
  class Car(Vehicle):   # 車（子）
      pass
  
  class Bike(Vehicle):  # バイク（子）
      pass

パターン4: 状態管理
  class Game:
      def __init__(self):
          self.__score = 0
      
      def add_score(self, points):
          self.__score += points
      
      def get_score(self):
          return self.__score
"""

print(cheatsheet)

# ==========================================================
# 【8】実践例 - RPGゲーム
# ==========================================================

print("\n" + "=" * 70)
print("【8】実践例 - RPGゲームキャラクター")
print("=" * 70)

class Character:
    """キャラクタークラス（親）"""
    
    def __init__(self, name, hp, attack):
        self.name = name      # 名前
        self.__hp = hp        # HP（private）
        self.attack = attack  # 攻撃力
    
    def get_hp(self):
        """HPを取得"""
        return self.__hp
    
    def take_damage(self, damage):
        """ダメージを受ける"""
        self.__hp -= damage
        if self.__hp < 0:
            self.__hp = 0
        return f"{self.name}は{damage}のダメージを受けた！（残りHP: {self.__hp}）"
    
    def is_alive(self):
        """生きているか"""
        return self.__hp > 0
    
    def special_attack(self):
        """特殊攻撃（子クラスでオーバーライド）"""
        return f"{self.name}の攻撃！"

class Warrior(Character):
    """戦士クラス（子）"""
    
    def special_attack(self):
        """特殊攻撃をオーバーライド"""
        return f"{self.name}の剣技！ダメージ: {self.attack * 2}"

class Mage(Character):
    """魔法使いクラス（子）"""
    
    def __init__(self, name, hp, attack, mp):
        super().__init__(name, hp, attack)
        self.__mp = mp  # 魔法使い独自の属性
    
    def special_attack(self):
        """特殊攻撃をオーバーライド"""
        if self.__mp >= 10:
            self.__mp -= 10
            return f"{self.name}の魔法！ダメージ: {self.attack * 3}"
        return f"{self.name}はMPが足りない！"

# ゲームの実行
print("\n■ バトル開始")
warrior = Warrior("勇者", 100, 20)
mage = Mage("魔法使い", 80, 15, 50)

print(warrior.special_attack())  # ポリモーフィズム
print(mage.special_attack())     # ポリモーフィズム

print(mage.take_damage(30))
print(f"{mage.name}は生きている？: {mage.is_alive()}")

print("\n" + "=" * 70)
print("これでオブジェクト指向マスター！")
print("=" * 70)

Pythonのオブジェクト指向プログラミングについて、超詳しいガイドを作成しました！

## 🎯 超シンプルに理解

### クラス = 設計図、インスタンス = 実物

```python
# クラス（たい焼きの型）
class Dog:
    def __init__(self, name):
        self.name = name

# インスタンス（実際のたい焼き）
dog1 = Dog("ポチ")  # たい焼き1個目
dog2 = Dog("タロー")  # たい焼き2個目
```

## 📋 重要用語チートシート

```
┌──────────────┬────────────────────┐
│ 用語         │ 意味               │
├──────────────┼────────────────────┤
│ クラス       │ 設計図             │
│ インスタンス │ 実物               │
│ 属性         │ データ（変数）     │
│ メソッド     │ 動作（関数）       │
│ self         │ 自分自身           │
│ __init__     │ コンストラクタ     │
└──────────────┴────────────────────┘
```

## 🔐 public / private / protected

```python
class MyClass:
    def __init__(self):
        self.public = "誰でも"        # public
        self._protected = "内部用"    # protected
        self.__private = "完全に隠す" # private

obj = MyClass()
print(obj.public)      # ○ OK
print(obj._protected)  # △ 使える（推奨されない）
print(obj.__private)   # × エラー！
```

**覚え方：**
```
name      → 普通（public）
_name     → アンダーバー1つ（protected）
__name    → アンダーバー2つ（private）
```

## 👨‍👩‍👧 継承 - 親子関係

```python
# 親クラス
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "何か音"

# 子クラス（Animalを継承）
class Dog(Animal):
    def speak(self):
        return "ワンワン"  # 親を上書き

# 使い方
dog = Dog("ポチ")
print(dog.speak())  # ワンワン（子の動作）
```

**メリット：**
- ✅ コードを再利用
- ✅ 共通部分をまとめる
- ✅ 新しいクラスを追加しやすい

## 🎭 ポリモーフィズム - 同じ命令で違う動き

```python
def make_sound(animal):
    print(animal.speak())  # 同じメソッド

cat = Cat("タマ")
dog = Dog("ポチ")

make_sound(cat)  # ニャー
make_sound(dog)  # ワンワン

# 同じ関数で違う結果！これがポリモーフィズム
```

## 🔄 オーバーライド vs オーバーロード

### オーバーライド（Override）- 上書き

```python
class Parent:
    def greet(self):
        return "こんにちは（親）"

class Child(Parent):
    def greet(self):  # 親のメソッドを上書き
        return "こんにちは（子）"

child = Child()
print(child.greet())  # こんにちは（子）← 上書きされた！
```

### オーバーロード（Overload）- Pythonの方法

```python
# Pythonには厳密なオーバーロードがない
# デフォルト引数で実現

class Calculator:
    def add(self, a, b=0, c=0):
        """引数の数で動作が変わる"""
        return a + b + c

calc = Calculator()
print(calc.add(5))        # 5
print(calc.add(5, 3))     # 8
print(calc.add(5, 3, 2))  # 10

# または可変長引数
class Calculator2:
    def multiply(self, *args):
        """任意の個数を掛け算"""
        result = 1
        for n in args:
            result *= n
        return result

calc2 = Calculator2()
print(calc2.multiply(2, 3))      # 6
print(calc2.multiply(2, 3, 4))   # 24
```

## 📊 比較表

```
┌──────────────┬────────────────┬──────────────┐
│ 機能         │ 説明           │ 使う場面     │
├──────────────┼────────────────┼──────────────┤
│ オーバーライド│ 親を上書き     │ 継承で使う   │
│ オーバーロード│ 引数で変化     │ 柔軟な関数   │
│ 継承         │ 親子関係       │ 共通化       │
│ ポリモーフィズム│ 同じ命令違う動作│ 統一I/F    │
│ カプセル化   │ データ隠蔽     │ 保護         │
└──────────────┴────────────────┴──────────────┘
```

## 🎮 実践例：RPGゲーム

```python
# 親クラス
class Character:
    def __init__(self, name, hp, attack):
        self.name = name
        self.__hp = hp  # private
        self.attack = attack
    
    def get_hp(self):
        return self.__hp
    
    def take_damage(self, damage):
        self.__hp -= damage
        return f"{self.name}: HP {self.__hp}"
    
    def special_attack(self):
        """子クラスでオーバーライドされる"""
        return f"{self.name}の攻撃！"

# 子クラス1：戦士
class Warrior(Character):
    def special_attack(self):
        """オーバーライド"""
        return f"{self.name}の剣技！ダメージ{self.attack * 2}"

# 子クラス2：魔法使い
class Mage(Character):
    def __init__(self, name, hp, attack, mp):
        super().__init__(name, hp, attack)  # 親を初期化
        self.mp = mp  # 魔法使い独自
    
    def special_attack(self):
        """オーバーライド"""
        if self.mp >= 10:
            self.mp -= 10
            return f"{self.name}の魔法！ダメージ{self.attack * 3}"
        return f"{self.name}はMPが足りない"

# ポリモーフィズムの実演
def battle(character):
    """どんなキャラでも攻撃できる"""
    print(character.special_attack())

# 使用
warrior = Warrior("勇者", 100, 20)
mage = Mage("魔法使い", 80, 15, 50)

battle(warrior)  # 剣技！ダメージ40
battle(mage)     # 魔法！ダメージ45
```

## 🗺️ クラス設計フローチャート

```
データと動作をまとめたい？
├─ YES
│  └─ クラスを作る
│     └─ 似たクラスが複数ある？
│        ├─ YES → 親クラスを作る（継承）
│        └─ NO  → 単独クラス
│
└─ NO → 関数で十分

外部から変更されたくない？
├─ YES → private (__name)
└─ NO  → public (name)

親のメソッドを変更したい？
├─ YES → オーバーライド
└─ NO  → 新メソッド
```

## 💡 よくあるパターン

### パターン1：データ管理

```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def get_info(self):
        return f"{self.name} ({self.email})"
```

### パターン2：階層構造

```python
class Vehicle:        # 親：乗り物
    def move(self):
        pass

class Car(Vehicle):   # 子：車
    def move(self):
        return "道路を走る"

class Boat(Vehicle):  # 子：船
    def move(self):
        return "水上を進む"
```

### パターン3：状態管理

```python
class Game:
    def __init__(self):
        self.__score = 0  # private
    
    def add_score(self, points):
        self.__score += points
    
    def get_score(self):
        return self.__score
```

## 📝 クイックリファレンス

### クラスの基本形

```python
class ClassName:
    """クラスの説明"""
    
    def __init__(self, param):
        """コンストラクタ"""
        self.attribute = param  # 属性
    
    def method(self):
        """メソッド"""
        return self.attribute

# 使用
obj = ClassName("値")
print(obj.method())
```

### 継承の基本形

```python
class Parent:
    def __init__(self, param):
        self.param = param

class Child(Parent):
    def __init__(self, param, extra):
        super().__init__(param)  # 親を初期化
        self.extra = extra       # 子独自
```

### アクセス制御

```python
class MyClass:
    def __init__(self):
        self.public = 1      # 誰でもOK
        self._protected = 2  # 内部用（慣習）
        self.__private = 3   # 外部NG
    
    def get_private(self):
        """getter経由でアクセス"""
        return self.__private
```

## ✅ チェックリスト

### いつクラスを使う？

- ✅ 関連するデータと機能をまとめたい
- ✅ 同じ構造のオブジェクトを複数作りたい
- ✅ データを保護したい
- ✅ 継承で拡張したい

### いつ継承を使う？

- ✅ 共通の属性・メソッドがある
- ✅ "is-a"の関係（犬は動物である）
- ✅ コードを再利用したい

### いつprivateを使う？

- ✅ 外部から変更されたくない
- ✅ 内部実装を隠したい
- ✅ データの整合性を保ちたい

## 🎓 まとめ：5つの柱

```
1. クラス・インスタンス
   → 設計図と実物

2. 継承
   → 親子関係でコード再利用

3. ポリモーフィズム
   → 同じ命令で違う動き

4. カプセル化
   → データを隠して保護

5. オーバーライド
   → 親のメソッドを上書き
```

## 🚀 実践のコツ

1. **最初は小さく** - シンプルなクラスから始める
2. **共通部分を探す** - 似たコードがあれば親クラスへ
3. **privateを使う** - 重要なデータは`__`で保護
4. **docstringを書く** - 何をするクラスか説明
5. **テストする** - 各メソッドが正しく動くか確認

これでオブジェクト指向プログラミング完全マスター！実際にゲームやアプリを作って試してみましょう 🎉


# ==========================================================
# Pythonデータ型操作トラブルシューティング完全ガイド
# ==========================================================

"""
【よくあるデータ型のトラブル】

1. IndexError - リストの範囲外アクセス
2. KeyError - 辞書のキーが存在しない
3. TypeError - 型が違う
4. ValueError - 値が不正
5. AttributeError - 存在しないメソッド
6. 文字列と数値の混在
7. リストのコピー問題
8. 辞書の順序問題
9. セットの順序がない
10. タプルが変更できない
"""

print("=" * 70)
print("Pythonデータ型操作トラブルシューティング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】IndexError - リストの範囲外アクセス
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル1】IndexError: list index out of range")
print("=" * 70)

trouble1 = """
■ エラーメッセージ：
  IndexError: list index out of range

■ 原因：
  存在しないインデックスにアクセスしようとした

■ 悪い例：
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]
print(fruits[3])  # エラー！インデックスは0-2まで
-----------------------------------------------------------

■ 解決方法1：インデックスを確認
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]

# リストの長さを確認
print(f"要素数: {len(fruits)}")  # 3

# 最後の要素にアクセス
print(fruits[len(fruits) - 1])  # オレンジ
print(fruits[-1])  # オレンジ（負のインデックス）
-----------------------------------------------------------

■ 解決方法2：範囲チェック
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]
index = 5

# 安全なアクセス
if index < len(fruits):
    print(fruits[index])
else:
    print(f"インデックス {index} は範囲外です")
-----------------------------------------------------------

■ 解決方法3：try-except
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]

try:
    print(fruits[5])
except IndexError:
    print("インデックスが範囲外です")
    print(f"有効な範囲: 0-{len(fruits)-1}")
-----------------------------------------------------------

■ 解決方法4：get関数（リストにはないが自作可能）
-----------------------------------------------------------
def safe_get(lst, index, default=None):
    '''安全にリストの要素を取得'''
    try:
        return lst[index]
    except IndexError:
        return default

fruits = ["りんご", "バナナ", "オレンジ"]
print(safe_get(fruits, 5, "なし"))  # なし
print(safe_get(fruits, 1, "なし"))  # バナナ
-----------------------------------------------------------

■ よくある間違い：
-----------------------------------------------------------
# ❌ 間違い1：範囲を超えたループ
fruits = ["りんご", "バナナ", "オレンジ"]
for i in range(5):  # 5回ループ（範囲外！）
    print(fruits[i])  # エラー

# ✅ 正しい方法
for i in range(len(fruits)):  # 3回ループ
    print(fruits[i])

# ✅ もっと良い方法（インデックス不要）
for fruit in fruits:
    print(fruit)

# ❌ 間違い2：空リストへのアクセス
empty = []
print(empty[0])  # エラー

# ✅ 正しい方法
if empty:  # リストが空でないかチェック
    print(empty[0])
else:
    print("リストが空です")
-----------------------------------------------------------
"""

print(trouble1)

# 実際に動作例
print("\n■ 動作例")
fruits = ["りんご", "バナナ", "オレンジ"]
print(f"リスト: {fruits}")
print(f"要素数: {len(fruits)}")
print(f"有効なインデックス: 0-{len(fruits)-1}")

try:
    print(f"fruits[3]: {fruits[3]}")
except IndexError as e:
    print(f"❌ エラー: {e}")
    print(f"✅ 正しい: fruits[2] = {fruits[2]}")

# ==========================================================
# 【2】KeyError - 辞書のキーが存在しない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル2】KeyError: キーが存在しない")
print("=" * 70)

trouble2 = """
■ エラーメッセージ：
  KeyError: 'phone'

■ 原因：
  辞書に存在しないキーにアクセスしようとした

■ 悪い例：
-----------------------------------------------------------
user = {"name": "田中", "age": 30}
print(user["phone"])  # エラー！phoneキーは存在しない
-----------------------------------------------------------

■ 解決方法1：get()メソッド（推奨）
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# getメソッド（存在しなければNoneを返す）
phone = user.get("phone")
print(phone)  # None

# デフォルト値を指定
phone = user.get("phone", "登録なし")
print(phone)  # 登録なし
-----------------------------------------------------------

■ 解決方法2：in 演算子でチェック
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# キーの存在確認
if "phone" in user:
    print(user["phone"])
else:
    print("電話番号が登録されていません")
-----------------------------------------------------------

■ 解決方法3：try-except
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

try:
    print(user["phone"])
except KeyError:
    print("キー 'phone' が存在しません")
-----------------------------------------------------------

■ 解決方法4：setdefault()
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# キーがなければ追加、あれば値を返す
phone = user.setdefault("phone", "未登録")
print(phone)  # 未登録
print(user)   # {'name': '田中', 'age': 30, 'phone': '未登録'}
-----------------------------------------------------------

■ 解決方法5：defaultdict（上級）
-----------------------------------------------------------
from collections import defaultdict

# 存在しないキーは自動的にデフォルト値を返す
user = defaultdict(lambda: "未設定")
user["name"] = "田中"
user["age"] = 30

print(user["phone"])  # 未設定（エラーにならない）
-----------------------------------------------------------

■ よくある間違い：
-----------------------------------------------------------
# ❌ 間違い：キーのスペルミス
user = {"name": "田中", "age": 30}
print(user["neme"])  # KeyError（nameのスペルミス）

# ✅ 正しい方法：getを使う
print(user.get("neme", "キーが見つかりません"))

# ❌ 間違い：大文字小文字の違い
user = {"Name": "田中"}
print(user["name"])  # KeyError（Nが大文字）

# ✅ 正しい方法：キーを確認
print(list(user.keys()))  # ['Name']
print(user["Name"])       # 田中
-----------------------------------------------------------
"""

print(trouble2)

# 実際に動作例
print("\n■ 動作例")
user = {"name": "田中", "age": 30, "email": "tanaka@example.com"}
print(f"ユーザー情報: {user}")

# 安全なアクセス
print(f"名前: {user.get('name', 'なし')}")
print(f"電話: {user.get('phone', '未登録')}")

# キーの存在確認
keys_to_check = ["name", "phone", "email"]
for key in keys_to_check:
    if key in user:
        print(f"✅ {key}: {user[key]}")
    else:
        print(f"❌ {key}: キーが存在しません")

# ==========================================================
# 【3】TypeError - 型が違う
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル3】TypeError: 型が合わない")
print("=" * 70)

trouble3 = """
■ よくあるTypeErrorパターン

パターン1: 文字列と数値の連結
-----------------------------------------------------------
# ❌ エラー
age = 30
message = "年齢は" + age + "歳です"  # TypeError

# ✅ 解決方法1：str()で変換
age = 30
message = "年齢は" + str(age) + "歳です"
print(message)  # 年齢は30歳です

# ✅ 解決方法2：f-string（推奨）
age = 30
message = f"年齢は{age}歳です"
print(message)  # 年齢は30歳です

# ✅ 解決方法3：format()
age = 30
message = "年齢は{}歳です".format(age)
print(message)  # 年齢は30歳です
-----------------------------------------------------------

パターン2: 整数と文字列の計算
-----------------------------------------------------------
# ❌ エラー
num = "10"
result = num + 5  # TypeError

# ✅ 解決：int()で変換
num = "10"
result = int(num) + 5
print(result)  # 15

# 注意：変換できない文字列
try:
    result = int("abc") + 5
except ValueError:
    print("数値に変換できません")
-----------------------------------------------------------

パターン3: リストと文字列の混在
-----------------------------------------------------------
# ❌ エラー
items = ["a", "b", "c"]
result = items + "d"  # TypeError

# ✅ 解決：リストとして追加
items = ["a", "b", "c"]
items.append("d")  # ['a', 'b', 'c', 'd']

# または
items = ["a", "b", "c"]
result = items + ["d"]  # ['a', 'b', 'c', 'd']
-----------------------------------------------------------

パターン4: Noneとの計算
-----------------------------------------------------------
# ❌ エラー
value = None
result = value + 10  # TypeError

# ✅ 解決：Noneチェック
value = None
if value is not None:
    result = value + 10
else:
    result = 10  # デフォルト値
print(result)  # 10

# ✅ または三項演算子
value = None
result = (value if value is not None else 0) + 10
print(result)  # 10
-----------------------------------------------------------

パターン5: イミュータブルな型の変更
-----------------------------------------------------------
# ❌ エラー：タプルは変更できない
my_tuple = (1, 2, 3)
my_tuple[0] = 10  # TypeError

# ✅ 解決：リストに変換して変更
my_tuple = (1, 2, 3)
my_list = list(my_tuple)  # [1, 2, 3]
my_list[0] = 10           # [10, 2, 3]
my_tuple = tuple(my_list) # (10, 2, 3)
-----------------------------------------------------------

パターン6: 関数呼び出しのミス
-----------------------------------------------------------
# ❌ エラー：文字列は呼び出せない
text = "Hello"
result = text()  # TypeError: 'str' object is not callable

# よくある原因：変数名が関数名と同じ
list = [1, 2, 3]  # listという組み込み関数を上書き
result = list("abc")  # エラー

# ✅ 解決：変数名を変える
my_list = [1, 2, 3]
result = list("abc")  # ['a', 'b', 'c']
-----------------------------------------------------------
"""

print(trouble3)

# 実際に動作例
print("\n■ 動作例：型変換")

# 文字列と数値
age = 30
print(f"❌ 連結できない: '年齢は' + {age}")
print(f"✅ f-string: 年齢は{age}歳です")
print(f"✅ str変換: 年齢は{str(age)}歳です")

# 文字列を数値に
num_str = "123"
print(f"\n文字列: '{num_str}' (型: {type(num_str).__name__})")
num_int = int(num_str)
print(f"数値: {num_int} (型: {type(num_int).__name__})")
print(f"計算: {num_int} + 10 = {num_int + 10}")

# ==========================================================
# 【4】ValueError - 値が不正
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル4】ValueError: 値が不正")
print("=" * 70)

trouble4 = """
■ よくあるValueErrorパターン

パターン1: 文字列を数値に変換できない
-----------------------------------------------------------
# ❌ エラー
text = "abc"
number = int(text)  # ValueError

# ✅ 解決：try-except
text = "abc"
try:
    number = int(text)
except ValueError:
    print(f"'{text}' は数値に変換できません")
    number = 0  # デフォルト値

# ✅ 解決：検証関数を作る
def safe_int(value, default=0):
    '''安全に整数に変換'''
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

print(safe_int("123"))    # 123
print(safe_int("abc"))    # 0
print(safe_int("abc", -1))  # -1
-----------------------------------------------------------

パターン2: リストから存在しない要素を削除
-----------------------------------------------------------
# ❌ エラー
fruits = ["りんご", "バナナ"]
fruits.remove("オレンジ")  # ValueError

# ✅ 解決：存在確認
fruits = ["りんご", "バナナ"]
if "オレンジ" in fruits:
    fruits.remove("オレンジ")
else:
    print("オレンジは含まれていません")

# ✅ 解決：try-except
try:
    fruits.remove("オレンジ")
except ValueError:
    print("要素が見つかりません")
-----------------------------------------------------------

パターン3: リストのindex()
-----------------------------------------------------------
# ❌ エラー
numbers = [1, 2, 3, 4, 5]
index = numbers.index(10)  # ValueError

# ✅ 解決：存在確認
numbers = [1, 2, 3, 4, 5]
if 10 in numbers:
    index = numbers.index(10)
else:
    print("値が見つかりません")
    index = -1

# ✅ 解決：安全な関数
def safe_index(lst, value, default=-1):
    '''安全にインデックスを取得'''
    try:
        return lst.index(value)
    except ValueError:
        return default

print(safe_index([1, 2, 3], 2))   # 1
print(safe_index([1, 2, 3], 10))  # -1
-----------------------------------------------------------

パターン4: unpack時の値の数が合わない
-----------------------------------------------------------
# ❌ エラー：値が3つなのに2つの変数
a, b = [1, 2, 3]  # ValueError

# ✅ 解決：変数の数を合わせる
a, b, c = [1, 2, 3]
print(a, b, c)  # 1 2 3

# ✅ 解決：*で残りを受け取る
a, b, *rest = [1, 2, 3, 4, 5]
print(a, b, rest)  # 1 2 [3, 4, 5]

# ✅ 解決：最初と最後だけ取る
first, *middle, last = [1, 2, 3, 4, 5]
print(first, middle, last)  # 1 [2, 3, 4] 5
-----------------------------------------------------------
"""

print(trouble4)

# 実際に動作例
print("\n■ 動作例：安全な変換")

def safe_convert(value, convert_func, default=None):
    """安全に型変換する汎用関数"""
    try:
        return convert_func(value)
    except (ValueError, TypeError) as e:
        print(f"❌ 変換失敗: {value} → {e}")
        return default

# テスト
test_values = ["123", "abc", "45.67", None, ""]
for val in test_values:
    result = safe_convert(val, int, default=0)
    print(f"'{val}' → {result}")

# ==========================================================
# 【5】リストのコピー問題（浅いコピー vs 深いコピー）
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル5】リストのコピー問題")
print("=" * 70)

trouble5 = """
■ 問題：リストをコピーしたつもりが...
-----------------------------------------------------------
# ❌ 間違い：代入は参照のコピー
list1 = [1, 2, 3]
list2 = list1  # 同じリストを指している
list2.append(4)
print(list1)  # [1, 2, 3, 4] ← list1も変わる！
print(list2)  # [1, 2, 3, 4]
-----------------------------------------------------------

■ 解決方法1：浅いコピー（シンプルなリストの場合）
-----------------------------------------------------------
# 方法A：スライス
list1 = [1, 2, 3]
list2 = list1[:]  # 新しいリストを作成
list2.append(4)
print(list1)  # [1, 2, 3] ← 変わらない
print(list2)  # [1, 2, 3, 4]

# 方法B：list()
list1 = [1, 2, 3]
list2 = list(list1)

# 方法C：copy()
list1 = [1, 2, 3]
list2 = list1.copy()
-----------------------------------------------------------

■ 解決方法2：深いコピー（ネストしたリストの場合）
-----------------------------------------------------------
import copy

# 問題：浅いコピーではネストが共有される
list1 = [[1, 2], [3, 4]]
list2 = list1.copy()  # 浅いコピー
list2[0].append(99)
print(list1)  # [[1, 2, 99], [3, 4]] ← 変わる！

# 解決：深いコピー
list1 = [[1, 2], [3, 4]]
list2 = copy.deepcopy(list1)  # 深いコピー
list2[0].append(99)
print(list1)  # [[1, 2], [3, 4]] ← 変わらない
print(list2)  # [[1, 2, 99], [3, 4]]
-----------------------------------------------------------

■ 辞書でも同じ問題
-----------------------------------------------------------
# ❌ 間違い
dict1 = {"name": "田中", "scores": [80, 90]}
dict2 = dict1  # 参照のコピー
dict2["scores"].append(100)
print(dict1)  # {'name': '田中', 'scores': [80, 90, 100]}

# ✅ 解決：浅いコピー
dict1 = {"name": "田中", "age": 30}
dict2 = dict1.copy()
dict2["age"] = 31
print(dict1)  # {'name': '田中', 'age': 30}

# ✅ 解決：深いコピー（ネストがある場合）
import copy
dict1 = {"name": "田中", "scores": [80, 90]}
dict2 = copy.deepcopy(dict1)
dict2["scores"].append(100)
print(dict1)  # {'name': '田中', 'scores': [80, 90]}
-----------------------------------------------------------
"""

print(trouble5)

# 実際に動作例
print("\n■ 動作例：コピーの違い")
import copy

# 参照のコピー（危険）
print("【参照のコピー】")
list1 = [1, 2, [3, 4]]
list2 = list1
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4, 5]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ 両方変わる！")

# 浅いコピー
print("\n【浅いコピー】")
list1 = [1, 2, [3, 4]]
list2 = list1.copy()
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4, 5]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ ネストは共有される")

# 深いコピー
print("\n【深いコピー】")
list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ 完全に独立")

# ==========================================================
# 【6】チートシート：エラー対処法まとめ
# ==========================================================

print("\n" + "=" * 70)
print("【チートシート】エラー対処法まとめ")
print("=" * 70)

cheatsheet = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃           データ型エラー対処法チートシート             ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■ IndexError（リストの範囲外）
┌────────────────────────────────────────────────┐
│ エラー: fruits[3]                             │
│ 解決1: if index < len(fruits):               │
│ 解決2: try-except IndexError                 │
│ 解決3: fruits[-1] で最後の要素               │
└────────────────────────────────────────────────┘

■ KeyError（辞書のキーなし）
┌────────────────────────────────────────────────┐
│ エラー: user["phone"]                         │
│ 解決1: user.get("phone", "デフォルト")  ★推奨│
│ 解決2: if "phone" in user:                   │
│ 解決3: try-except KeyError                   │
└────────────────────────────────────────────────┘

■ TypeError（型が違う）
┌────────────────────────────────────────────────┐
│ エラー: "年齢は" + 30                         │
│ 解決1: f"年齢は{30}歳"  ★推奨                │
│ 解決2: "年齢は" + str(30)                     │
│ 解決3: "年齢は{}歳".format(30)                │
└────────────────────────────────────────────────┘

■ ValueError（値が不正）
┌────────────────────────────────────────────────┐
│ エラー: int("abc")                            │
│ 解決1: try-except ValueError                 │
│ 解決2: if value.isdigit():                   │
│ 解決3: 安全な変換関数を作る                   │
└────────────────────────────────────────────────┘

■ リストのコピー
┌────────────────────────────────────────────────┐
│ ❌: list2 = list1  # 参照のコピー（危険）     │
│ ✅: list2 = list1.copy()  # 浅いコピー        │
│ ✅: list2 = list1[:]      # 浅いコピー        │
│ ✅: list2 = copy.deepcopy(list1)  # 深い      │
└────────────────────────────────────────────────┘

■ 型チェック
┌────────────────────────────────────────────────┐
│ type(x)                 # 型を取得            │
│ isinstance(x, int)      # int型かチェック     │
│ isinstance(x, (int, float))  # 複数型チェック │
└────────────────────────────────────────────────┘

■ 安全な操作パターン
┌────────────────────────────────────────────────┐
│ # リスト                                      │
│ item = lst[i] if i < len(lst) else None      │
│                                               │
│ # 辞書                                        │
│ value = dct.get(key, default)                 │
│                                               │
│ # 変換                                        │
│ try:                                          │
│     num = int(text)                           │
│ except ValueError:                            │
│     num = 0                                   │
└────────────────────────────────────────────────┘
"""

print(cheatsheet)

print("\n" + "=" * 70)
print("これでデータ型のトラブルは解決！")
print("=" * 70)


Pythonのデータ型操作のトラブルシューティングガイドを作成しますね！

# ==========================================================
# Pythonデータ型操作トラブルシューティング完全ガイド
# ==========================================================

"""
【よくあるデータ型のトラブル】

1. IndexError - リストの範囲外アクセス
2. KeyError - 辞書のキーが存在しない
3. TypeError - 型が違う
4. ValueError - 値が不正
5. AttributeError - 存在しないメソッド
6. 文字列と数値の混在
7. リストのコピー問題
8. 辞書の順序問題
9. セットの順序がない
10. タプルが変更できない
"""

print("=" * 70)
print("Pythonデータ型操作トラブルシューティング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】IndexError - リストの範囲外アクセス
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル1】IndexError: list index out of range")
print("=" * 70)

trouble1 = """
■ エラーメッセージ：
  IndexError: list index out of range

■ 原因：
  存在しないインデックスにアクセスしようとした

■ 悪い例：
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]
print(fruits[3])  # エラー！インデックスは0-2まで
-----------------------------------------------------------

■ 解決方法1：インデックスを確認
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]

# リストの長さを確認
print(f"要素数: {len(fruits)}")  # 3

# 最後の要素にアクセス
print(fruits[len(fruits) - 1])  # オレンジ
print(fruits[-1])  # オレンジ（負のインデックス）
-----------------------------------------------------------

■ 解決方法2：範囲チェック
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]
index = 5

# 安全なアクセス
if index < len(fruits):
    print(fruits[index])
else:
    print(f"インデックス {index} は範囲外です")
-----------------------------------------------------------

■ 解決方法3：try-except
-----------------------------------------------------------
fruits = ["りんご", "バナナ", "オレンジ"]

try:
    print(fruits[5])
except IndexError:
    print("インデックスが範囲外です")
    print(f"有効な範囲: 0-{len(fruits)-1}")
-----------------------------------------------------------

■ 解決方法4：get関数（リストにはないが自作可能）
-----------------------------------------------------------
def safe_get(lst, index, default=None):
    '''安全にリストの要素を取得'''
    try:
        return lst[index]
    except IndexError:
        return default

fruits = ["りんご", "バナナ", "オレンジ"]
print(safe_get(fruits, 5, "なし"))  # なし
print(safe_get(fruits, 1, "なし"))  # バナナ
-----------------------------------------------------------

■ よくある間違い：
-----------------------------------------------------------
# ❌ 間違い1：範囲を超えたループ
fruits = ["りんご", "バナナ", "オレンジ"]
for i in range(5):  # 5回ループ（範囲外！）
    print(fruits[i])  # エラー

# ✅ 正しい方法
for i in range(len(fruits)):  # 3回ループ
    print(fruits[i])

# ✅ もっと良い方法（インデックス不要）
for fruit in fruits:
    print(fruit)

# ❌ 間違い2：空リストへのアクセス
empty = []
print(empty[0])  # エラー

# ✅ 正しい方法
if empty:  # リストが空でないかチェック
    print(empty[0])
else:
    print("リストが空です")
-----------------------------------------------------------
"""

print(trouble1)

# 実際に動作例
print("\n■ 動作例")
fruits = ["りんご", "バナナ", "オレンジ"]
print(f"リスト: {fruits}")
print(f"要素数: {len(fruits)}")
print(f"有効なインデックス: 0-{len(fruits)-1}")

try:
    print(f"fruits[3]: {fruits[3]}")
except IndexError as e:
    print(f"❌ エラー: {e}")
    print(f"✅ 正しい: fruits[2] = {fruits[2]}")

# ==========================================================
# 【2】KeyError - 辞書のキーが存在しない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル2】KeyError: キーが存在しない")
print("=" * 70)

trouble2 = """
■ エラーメッセージ：
  KeyError: 'phone'

■ 原因：
  辞書に存在しないキーにアクセスしようとした

■ 悪い例：
-----------------------------------------------------------
user = {"name": "田中", "age": 30}
print(user["phone"])  # エラー！phoneキーは存在しない
-----------------------------------------------------------

■ 解決方法1：get()メソッド（推奨）
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# getメソッド（存在しなければNoneを返す）
phone = user.get("phone")
print(phone)  # None

# デフォルト値を指定
phone = user.get("phone", "登録なし")
print(phone)  # 登録なし
-----------------------------------------------------------

■ 解決方法2：in 演算子でチェック
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# キーの存在確認
if "phone" in user:
    print(user["phone"])
else:
    print("電話番号が登録されていません")
-----------------------------------------------------------

■ 解決方法3：try-except
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

try:
    print(user["phone"])
except KeyError:
    print("キー 'phone' が存在しません")
-----------------------------------------------------------

■ 解決方法4：setdefault()
-----------------------------------------------------------
user = {"name": "田中", "age": 30}

# キーがなければ追加、あれば値を返す
phone = user.setdefault("phone", "未登録")
print(phone)  # 未登録
print(user)   # {'name': '田中', 'age': 30, 'phone': '未登録'}
-----------------------------------------------------------

■ 解決方法5：defaultdict（上級）
-----------------------------------------------------------
from collections import defaultdict

# 存在しないキーは自動的にデフォルト値を返す
user = defaultdict(lambda: "未設定")
user["name"] = "田中"
user["age"] = 30

print(user["phone"])  # 未設定（エラーにならない）
-----------------------------------------------------------

■ よくある間違い：
-----------------------------------------------------------
# ❌ 間違い：キーのスペルミス
user = {"name": "田中", "age": 30}
print(user["neme"])  # KeyError（nameのスペルミス）

# ✅ 正しい方法：getを使う
print(user.get("neme", "キーが見つかりません"))

# ❌ 間違い：大文字小文字の違い
user = {"Name": "田中"}
print(user["name"])  # KeyError（Nが大文字）

# ✅ 正しい方法：キーを確認
print(list(user.keys()))  # ['Name']
print(user["Name"])       # 田中
-----------------------------------------------------------
"""

print(trouble2)

# 実際に動作例
print("\n■ 動作例")
user = {"name": "田中", "age": 30, "email": "tanaka@example.com"}
print(f"ユーザー情報: {user}")

# 安全なアクセス
print(f"名前: {user.get('name', 'なし')}")
print(f"電話: {user.get('phone', '未登録')}")

# キーの存在確認
keys_to_check = ["name", "phone", "email"]
for key in keys_to_check:
    if key in user:
        print(f"✅ {key}: {user[key]}")
    else:
        print(f"❌ {key}: キーが存在しません")

# ==========================================================
# 【3】TypeError - 型が違う
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル3】TypeError: 型が合わない")
print("=" * 70)

trouble3 = """
■ よくあるTypeErrorパターン

パターン1: 文字列と数値の連結
-----------------------------------------------------------
# ❌ エラー
age = 30
message = "年齢は" + age + "歳です"  # TypeError

# ✅ 解決方法1：str()で変換
age = 30
message = "年齢は" + str(age) + "歳です"
print(message)  # 年齢は30歳です

# ✅ 解決方法2：f-string（推奨）
age = 30
message = f"年齢は{age}歳です"
print(message)  # 年齢は30歳です

# ✅ 解決方法3：format()
age = 30
message = "年齢は{}歳です".format(age)
print(message)  # 年齢は30歳です
-----------------------------------------------------------

パターン2: 整数と文字列の計算
-----------------------------------------------------------
# ❌ エラー
num = "10"
result = num + 5  # TypeError

# ✅ 解決：int()で変換
num = "10"
result = int(num) + 5
print(result)  # 15

# 注意：変換できない文字列
try:
    result = int("abc") + 5
except ValueError:
    print("数値に変換できません")
-----------------------------------------------------------

パターン3: リストと文字列の混在
-----------------------------------------------------------
# ❌ エラー
items = ["a", "b", "c"]
result = items + "d"  # TypeError

# ✅ 解決：リストとして追加
items = ["a", "b", "c"]
items.append("d")  # ['a', 'b', 'c', 'd']

# または
items = ["a", "b", "c"]
result = items + ["d"]  # ['a', 'b', 'c', 'd']
-----------------------------------------------------------

パターン4: Noneとの計算
-----------------------------------------------------------
# ❌ エラー
value = None
result = value + 10  # TypeError

# ✅ 解決：Noneチェック
value = None
if value is not None:
    result = value + 10
else:
    result = 10  # デフォルト値
print(result)  # 10

# ✅ または三項演算子
value = None
result = (value if value is not None else 0) + 10
print(result)  # 10
-----------------------------------------------------------

パターン5: イミュータブルな型の変更
-----------------------------------------------------------
# ❌ エラー：タプルは変更できない
my_tuple = (1, 2, 3)
my_tuple[0] = 10  # TypeError

# ✅ 解決：リストに変換して変更
my_tuple = (1, 2, 3)
my_list = list(my_tuple)  # [1, 2, 3]
my_list[0] = 10           # [10, 2, 3]
my_tuple = tuple(my_list) # (10, 2, 3)
-----------------------------------------------------------

パターン6: 関数呼び出しのミス
-----------------------------------------------------------
# ❌ エラー：文字列は呼び出せない
text = "Hello"
result = text()  # TypeError: 'str' object is not callable

# よくある原因：変数名が関数名と同じ
list = [1, 2, 3]  # listという組み込み関数を上書き
result = list("abc")  # エラー

# ✅ 解決：変数名を変える
my_list = [1, 2, 3]
result = list("abc")  # ['a', 'b', 'c']
-----------------------------------------------------------
"""

print(trouble3)

# 実際に動作例
print("\n■ 動作例：型変換")

# 文字列と数値
age = 30
print(f"❌ 連結できない: '年齢は' + {age}")
print(f"✅ f-string: 年齢は{age}歳です")
print(f"✅ str変換: 年齢は{str(age)}歳です")

# 文字列を数値に
num_str = "123"
print(f"\n文字列: '{num_str}' (型: {type(num_str).__name__})")
num_int = int(num_str)
print(f"数値: {num_int} (型: {type(num_int).__name__})")
print(f"計算: {num_int} + 10 = {num_int + 10}")

# ==========================================================
# 【4】ValueError - 値が不正
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル4】ValueError: 値が不正")
print("=" * 70)

trouble4 = """
■ よくあるValueErrorパターン

パターン1: 文字列を数値に変換できない
-----------------------------------------------------------
# ❌ エラー
text = "abc"
number = int(text)  # ValueError

# ✅ 解決：try-except
text = "abc"
try:
    number = int(text)
except ValueError:
    print(f"'{text}' は数値に変換できません")
    number = 0  # デフォルト値

# ✅ 解決：検証関数を作る
def safe_int(value, default=0):
    '''安全に整数に変換'''
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

print(safe_int("123"))    # 123
print(safe_int("abc"))    # 0
print(safe_int("abc", -1))  # -1
-----------------------------------------------------------

パターン2: リストから存在しない要素を削除
-----------------------------------------------------------
# ❌ エラー
fruits = ["りんご", "バナナ"]
fruits.remove("オレンジ")  # ValueError

# ✅ 解決：存在確認
fruits = ["りんご", "バナナ"]
if "オレンジ" in fruits:
    fruits.remove("オレンジ")
else:
    print("オレンジは含まれていません")

# ✅ 解決：try-except
try:
    fruits.remove("オレンジ")
except ValueError:
    print("要素が見つかりません")
-----------------------------------------------------------

パターン3: リストのindex()
-----------------------------------------------------------
# ❌ エラー
numbers = [1, 2, 3, 4, 5]
index = numbers.index(10)  # ValueError

# ✅ 解決：存在確認
numbers = [1, 2, 3, 4, 5]
if 10 in numbers:
    index = numbers.index(10)
else:
    print("値が見つかりません")
    index = -1

# ✅ 解決：安全な関数
def safe_index(lst, value, default=-1):
    '''安全にインデックスを取得'''
    try:
        return lst.index(value)
    except ValueError:
        return default

print(safe_index([1, 2, 3], 2))   # 1
print(safe_index([1, 2, 3], 10))  # -1
-----------------------------------------------------------

パターン4: unpack時の値の数が合わない
-----------------------------------------------------------
# ❌ エラー：値が3つなのに2つの変数
a, b = [1, 2, 3]  # ValueError

# ✅ 解決：変数の数を合わせる
a, b, c = [1, 2, 3]
print(a, b, c)  # 1 2 3

# ✅ 解決：*で残りを受け取る
a, b, *rest = [1, 2, 3, 4, 5]
print(a, b, rest)  # 1 2 [3, 4, 5]

# ✅ 解決：最初と最後だけ取る
first, *middle, last = [1, 2, 3, 4, 5]
print(first, middle, last)  # 1 [2, 3, 4] 5
-----------------------------------------------------------
"""

print(trouble4)

# 実際に動作例
print("\n■ 動作例：安全な変換")

def safe_convert(value, convert_func, default=None):
    """安全に型変換する汎用関数"""
    try:
        return convert_func(value)
    except (ValueError, TypeError) as e:
        print(f"❌ 変換失敗: {value} → {e}")
        return default

# テスト
test_values = ["123", "abc", "45.67", None, ""]
for val in test_values:
    result = safe_convert(val, int, default=0)
    print(f"'{val}' → {result}")

# ==========================================================
# 【5】リストのコピー問題（浅いコピー vs 深いコピー）
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル5】リストのコピー問題")
print("=" * 70)

trouble5 = """
■ 問題：リストをコピーしたつもりが...
-----------------------------------------------------------
# ❌ 間違い：代入は参照のコピー
list1 = [1, 2, 3]
list2 = list1  # 同じリストを指している
list2.append(4)
print(list1)  # [1, 2, 3, 4] ← list1も変わる！
print(list2)  # [1, 2, 3, 4]
-----------------------------------------------------------

■ 解決方法1：浅いコピー（シンプルなリストの場合）
-----------------------------------------------------------
# 方法A：スライス
list1 = [1, 2, 3]
list2 = list1[:]  # 新しいリストを作成
list2.append(4)
print(list1)  # [1, 2, 3] ← 変わらない
print(list2)  # [1, 2, 3, 4]

# 方法B：list()
list1 = [1, 2, 3]
list2 = list(list1)

# 方法C：copy()
list1 = [1, 2, 3]
list2 = list1.copy()
-----------------------------------------------------------

■ 解決方法2：深いコピー（ネストしたリストの場合）
-----------------------------------------------------------
import copy

# 問題：浅いコピーではネストが共有される
list1 = [[1, 2], [3, 4]]
list2 = list1.copy()  # 浅いコピー
list2[0].append(99)
print(list1)  # [[1, 2, 99], [3, 4]] ← 変わる！

# 解決：深いコピー
list1 = [[1, 2], [3, 4]]
list2 = copy.deepcopy(list1)  # 深いコピー
list2[0].append(99)
print(list1)  # [[1, 2], [3, 4]] ← 変わらない
print(list2)  # [[1, 2, 99], [3, 4]]
-----------------------------------------------------------

■ 辞書でも同じ問題
-----------------------------------------------------------
# ❌ 間違い
dict1 = {"name": "田中", "scores": [80, 90]}
dict2 = dict1  # 参照のコピー
dict2["scores"].append(100)
print(dict1)  # {'name': '田中', 'scores': [80, 90, 100]}

# ✅ 解決：浅いコピー
dict1 = {"name": "田中", "age": 30}
dict2 = dict1.copy()
dict2["age"] = 31
print(dict1)  # {'name': '田中', 'age': 30}

# ✅ 解決：深いコピー（ネストがある場合）
import copy
dict1 = {"name": "田中", "scores": [80, 90]}
dict2 = copy.deepcopy(dict1)
dict2["scores"].append(100)
print(dict1)  # {'name': '田中', 'scores': [80, 90]}
-----------------------------------------------------------
"""

print(trouble5)

# 実際に動作例
print("\n■ 動作例：コピーの違い")
import copy

# 参照のコピー（危険）
print("【参照のコピー】")
list1 = [1, 2, [3, 4]]
list2 = list1
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4, 5]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ 両方変わる！")

# 浅いコピー
print("\n【浅いコピー】")
list1 = [1, 2, [3, 4]]
list2 = list1.copy()
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4, 5]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ ネストは共有される")

# 深いコピー
print("\n【深いコピー】")
list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)
list2[2].append(5)
print(f"list1: {list1}")  # [1, 2, [3, 4]]
print(f"list2: {list2}")  # [1, 2, [3, 4, 5]]
print("→ 完全に独立")

# ==========================================================
# 【6】チートシート：エラー対処法まとめ
# ==========================================================

print("\n" + "=" * 70)
print("【チートシート】エラー対処法まとめ")
print("=" * 70)

cheatsheet = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃           データ型エラー対処法チートシート             ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■ IndexError（リストの範囲外）
┌────────────────────────────────────────────────┐
│ エラー: fruits[3]                             │
│ 解決1: if index < len(fruits):               │
│ 解決2: try-except IndexError                 │
│ 解決3: fruits[-1] で最後の要素               │
└────────────────────────────────────────────────┘

■ KeyError（辞書のキーなし）
┌────────────────────────────────────────────────┐
│ エラー: user["phone"]                         │
│ 解決1: user.get("phone", "デフォルト")  ★推奨│
│ 解決2: if "phone" in user:                   │
│ 解決3: try-except KeyError                   │
└────────────────────────────────────────────────┘

■ TypeError（型が違う）
┌────────────────────────────────────────────────┐
│ エラー: "年齢は" + 30                         │
│ 解決1: f"年齢は{30}歳"  ★推奨                │
│ 解決2: "年齢は" + str(30)                     │
│ 解決3: "年齢は{}歳".format(30)                │
└────────────────────────────────────────────────┘

■ ValueError（値が不正）
┌────────────────────────────────────────────────┐
│ エラー: int("abc")                            │
│ 解決1: try-except ValueError                 │
│ 解決2: if value.isdigit():                   │
│ 解決3: 安全な変換関数を作る                   │
└────────────────────────────────────────────────┘

■ リストのコピー
┌────────────────────────────────────────────────┐
│ ❌: list2 = list1  # 参照のコピー（危険）     │
│ ✅: list2 = list1.copy()  # 浅いコピー        │
│ ✅: list2 = list1[:]      # 浅いコピー        │
│ ✅: list2 = copy.deepcopy(list1)  # 深い      │
└────────────────────────────────────────────────┘

■ 型チェック
┌────────────────────────────────────────────────┐
│ type(x)                 # 型を取得            │
│ isinstance(x, int)      # int型かチェック     │
│ isinstance(x, (int, float))  # 複数型チェック │
└────────────────────────────────────────────────┘

■ 安全な操作パターン
┌────────────────────────────────────────────────┐
│ # リスト                                      │
│ item = lst[i] if i < len(lst) else None      │
│                                               │
│ # 辞書                                        │
│ value = dct.get(key, default)                 │
│                                               │
│ # 変換                                        │
│ try:                                          │
│     num = int(text)                           │
│ except ValueError:                            │
│     num = 0                                   │
└────────────────────────────────────────────────┘
"""

print(cheatsheet)

print("\n" + "=" * 70)
print("これでデータ型のトラブルは解決！")
print("=" * 70)

Pythonのデータ型操作トラブルシューティングガイドを作成しました！

## 🚨 超頻出エラー TOP 5

### 1️⃣ **IndexError** - リストの範囲外

```python
# ❌ エラー
fruits = ["りんご", "バナナ"]
print(fruits[2])  # IndexError!

# ✅ 解決法
# 方法1: 範囲チェック
if 2 < len(fruits):
    print(fruits[2])

# 方法2: 負のインデックス（最後から）
print(fruits[-1])  # バナナ

# 方法3: 安全な関数
def safe_get(lst, index, default=None):
    return lst[index] if index < len(lst) else default

print(safe_get(fruits, 2, "なし"))  # なし
```

### 2️⃣ **KeyError** - 辞書のキーがない

```python
# ❌ エラー
user = {"name": "田中", "age": 30}
print(user["phone"])  # KeyError!

# ✅ 解決法（これが最強！）
print(user.get("phone", "未登録"))  # 未登録

# 他の方法
if "phone" in user:
    print(user["phone"])
```

### 3️⃣ **TypeError** - 型が違う

```python
# ❌ エラー
age = 30
print("年齢は" + age + "歳")  # TypeError!

# ✅ 解決法（推奨順）
print(f"年齢は{age}歳")           # f-string ★
print("年齢は" + str(age) + "歳")  # str変換
print("年齢は{}歳".format(age))    # format
```

### 4️⃣ **ValueError** - 値が不正

```python
# ❌ エラー
number = int("abc")  # ValueError!

# ✅ 解決法
try:
    number = int("abc")
except ValueError:
    number = 0  # デフォルト値

# または安全な関数
def safe_int(value, default=0):
    try:
        return int(value)
    except ValueError:
        return default

print(safe_int("123"))  # 123
print(safe_int("abc"))  # 0
```

### 5️⃣ **コピー問題** - 意図しない変更

```python
# ❌ 危険！


```python
list1 = [1, 2, 3]
list2 = list1  # 参照のコピー（同じものを指す）
list2.append(4)
print(list1)  # [1, 2, 3, 4] ← list1も変わる！

# ✅ 解決法1: 浅いコピー（通常はこれでOK）
list1 = [1, 2, 3]
list2 = list1.copy()  # または list1[:]
list2.append(4)
print(list1)  # [1, 2, 3] ← 変わらない

# ✅ 解決法2: 深いコピー（ネストがある場合）
import copy

list1 = [[1, 2], [3, 4]]
list2 = copy.deepcopy(list1)
list2[0].append(99)
print(list1)  # [[1, 2], [3, 4]] ← 変わらない
print(list2)  # [[1, 2, 99], [3, 4]]
```

## 📊 エラー別クイック解決表

```
┌─────────────┬──────────────────┬─────────────────┐
│ エラー      │ 原因             │ 解決法          │
├─────────────┼──────────────────┼─────────────────┤
│ IndexError  │ 範囲外アクセス   │ len()でチェック │
│ KeyError    │ キーが存在しない │ .get()を使う    │
│ TypeError   │ 型が違う         │ 型変換・f-string│
│ ValueError  │ 値が不正         │ try-exceptで処理│
│ AttributeError│ メソッドなし   │ 型を確認        │
└─────────────┴──────────────────┴─────────────────┘
```

## 🛠️ 実践的な安全関数集

```python
# 1. 安全なリストアクセス
def safe_list_get(lst, index, default=None):
    """範囲外アクセスを防ぐ"""
    try:
        return lst[index]
    except IndexError:
        return default

# 使用例
fruits = ["りんご", "バナナ"]
print(safe_list_get(fruits, 0))   # りんご
print(safe_list_get(fruits, 5))   # None
print(safe_list_get(fruits, 5, "なし"))  # なし

# 2. 安全な型変換
def safe_convert(value, convert_type, default=None):
    """型変換エラーを防ぐ"""
    try:
        return convert_type(value)
    except (ValueError, TypeError):
        return default

# 使用例
print(safe_convert("123", int))      # 123
print(safe_convert("abc", int, 0))   # 0
print(safe_convert("3.14", float))   # 3.14

# 3. 安全な辞書取得（ネスト対応）
def safe_dict_get(dct, keys, default=None):
    """ネストした辞書から安全に取得"""
    if isinstance(keys, str):
        keys = [keys]
    
    for key in keys:
        if isinstance(dct, dict) and key in dct:
            dct = dct[key]
        else:
            return default
    return dct

# 使用例
data = {
    "user": {
        "profile": {
            "name": "田中"
        }
    }
}
print(safe_dict_get(data, ["user", "profile", "name"]))  # 田中
print(safe_dict_get(data, ["user", "email"], "なし"))    # なし

# 4. リストから安全に削除
def safe_remove(lst, value):
    """存在しない値の削除を防ぐ"""
    if value in lst:
        lst.remove(value)
        return True
    return False

# 使用例
fruits = ["りんご", "バナナ", "オレンジ"]
safe_remove(fruits, "バナナ")    # True
safe_remove(fruits, "メロン")    # False
print(fruits)  # ['りんご', 'オレンジ']

# 5. 安全なインデックス取得
def safe_index(lst, value, default=-1):
    """値が見つからない時にエラーを防ぐ"""
    try:
        return lst.index(value)
    except ValueError:
        return default

# 使用例
numbers = [10, 20, 30]
print(safe_index(numbers, 20))    # 1
print(safe_index(numbers, 99))    # -1
```

## 🔍 型チェックと変換

```python
# 型の確認方法
value = 123

# 方法1: type()
print(type(value))  # <class 'int'>
print(type(value) == int)  # True

# 方法2: isinstance()（推奨）
print(isinstance(value, int))  # True
print(isinstance(value, (int, float)))  # 複数型チェック

# 型変換の安全パターン
def convert_to_number(value):
    """文字列を数値に安全変換"""
    # 整数変換を試す
    try:
        return int(value)
    except ValueError:
        pass
    
    # 小数変換を試す
    try:
        return float(value)
    except ValueError:
        pass
    
    # 変換できない
    return None

# テスト
print(convert_to_number("123"))    # 123 (int)
print(convert_to_number("3.14"))   # 3.14 (float)
print(convert_to_number("abc"))    # None
```

## ⚠️ よくある落とし穴

### 落とし穴1: 空リストの扱い

```python
# ❌ 間違い
my_list = []
first = my_list[0]  # IndexError!

# ✅ 正しい
my_list = []
if my_list:  # 空でないかチェック
    first = my_list[0]
else:
    first = None

# または
first = my_list[0] if my_list else None
```

### 落とし穴2: 文字列のインデックス

```python
# 文字列もインデックスでアクセス可能
text = "Hello"
print(text[0])   # 'H'
print(text[-1])  # 'o'

# でも変更はできない（イミュータブル）
# text[0] = 'h'  # TypeError!

# 変更したい場合はリストに
chars = list(text)  # ['H', 'e', 'l', 'l', 'o']
chars[0] = 'h'
text = ''.join(chars)  # 'hello'
```

### 落とし穴3: 辞書のキーの型

```python
# キーの型が違うと別物扱い
my_dict = {1: "one", "1": "string one"}

print(my_dict[1])    # "one"
print(my_dict["1"])  # "string one"

# よくある間違い
data = {"age": 30}
print(data.get("Age"))  # None（大文字小文字が違う）
```

### 落とし穴4: リストの * 演算子

```python
# ❌ 危険！ネストしたリストの場合
matrix = [[0] * 3] * 3  # 全部同じリストを参照
matrix[0][0] = 1
print(matrix)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]] ← 全部変わる

# ✅ 正しい方法
matrix = [[0] * 3 for _ in range(3)]  # 別々のリスト
matrix[0][0] = 1
print(matrix)  # [[1, 0, 0], [0, 0, 0], [0, 0, 0]]
```

### 落とし穴5: デフォルト引数のミュータブル

```python
# ❌ 危険！
def add_item(item, lst=[]):  # デフォルト引数にリスト
    lst.append(item)
    return lst

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] ← 前の値が残る！

# ✅ 正しい方法
def add_item(item, lst=None):
    if lst is None:
        lst = []  # 毎回新しいリスト
    lst.append(item)
    return lst

print(add_item(1))  # [1]
print(add_item(2))  # [2] ← 独立
```

## 🎯 デバッグテクニック

```python
# 1. 型と値を確認
value = "123"
print(f"値: {value}, 型: {type(value).__name__}")

# 2. リストの状態確認
my_list = [1, 2, 3]
print(f"リスト: {my_list}")
print(f"長さ: {len(my_list)}")
print(f"最初: {my_list[0]}, 最後: {my_list[-1]}")

# 3. 辞書の内容確認
my_dict = {"name": "田中", "age": 30}
print(f"キー: {list(my_dict.keys())}")
print(f"値: {list(my_dict.values())}")
print(f"ペア: {list(my_dict.items())}")

# 4. 条件分岐での確認
def debug_value(value):
    print(f"値: {value}")
    print(f"型: {type(value).__name__}")
    print(f"真偽値: {bool(value)}")
    print(f"文字列: '{str(value)}'")
    print(f"長さ: {len(value) if hasattr(value, '__len__') else 'なし'}")

# テスト
debug_value([1, 2, 3])
debug_value("")
debug_value(0)
```

## 📝 トラブル対処フローチャート

```
エラーが出た！
│
├─ IndexError?
│  └─ len()で長さ確認 → 範囲内かチェック
│
├─ KeyError?
│  └─ .get()使う → デフォルト値を設定
│
├─ TypeError?
│  ├─ 文字列+数値? → f-string使う
│  ├─ 型が違う? → 型変換（int, str, float）
│  └─ Noneと計算? → None チェック追加
│
├─ ValueError?
│  └─ try-exceptで補足 → デフォルト値を返す
│
└─ 意図しない変更?
   └─ コピーを使う → .copy() or deepcopy()
```

## 💡 予防的プログラミング

```python
# ✅ 良い習慣

# 1. 型ヒントを使う
def add_numbers(a: int, b: int) -> int:
    return a + b

# 2. アサーションでチェック
def divide(a: float, b: float) -> float:
    assert b != 0, "ゼロ除算はできません"
    return a / b

# 3. 入力検証
def process_age(age):
    if not isinstance(age, int):
        raise TypeError("年齢は整数である必要があります")
    if age < 0 or age > 150:
        raise ValueError("年齢が範囲外です")
    return age

# 4. デフォルト値を活用
def get_config(key, default=None):
    config = {"host": "localhost", "port": 8080}
    return config.get(key, default)

# 5. 早期リターン
def calculate(value):
    if value is None:
        return 0
    if not isinstance(value, (int, float)):
        return 0
    return value * 2
```

## 🎓 まとめ：5つの鉄則

```
1. get()を使う
   dict.get(key, default) で安全アクセス

2. len()で確認
   インデックスアクセス前に長さをチェック

3. f-stringを使う
   型混在の問題を回避

4. try-exceptを使う
   予期しないエラーを捕捉

5. copy()を使う
   リストや辞書のコピーは明示的に
```

これでPythonデータ型のトラブルは完全解決！エラーに出会ったらこのガイドを見返してください 🎉
