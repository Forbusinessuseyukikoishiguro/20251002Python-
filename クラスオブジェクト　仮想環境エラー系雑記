クラスとオブジェクト指向について、超詳しいガイドを作成しますね！

# ==========================================================
# Pythonオブジェクト指向プログラミング完全ガイド
# ==========================================================

"""
【オブジェクト指向とは？】

簡単に言うと：
  「モノ」を中心にプログラムを組み立てる考え方
  
例：
  犬という「モノ」は...
  - 属性: 名前、年齢、犬種
  - 行動: 吠える、走る、食べる
  
  これを「クラス」として定義する

重要な概念：
  1. クラス          設計図
  2. インスタンス    実際のモノ
  3. 継承           親子関係
  4. ポリモーフィズム 同じ命令で違う動き
  5. カプセル化      隠蔽（public/private）
"""

print("=" * 70)
print("Pythonオブジェクト指向プログラミング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】クラスとインスタンスの基本
# ==========================================================

print("\n" + "=" * 70)
print("【1】クラスとインスタンス - 設計図と実物")
print("=" * 70)

# --- 最もシンプルなクラス ---
class Dog:
    """犬を表すクラス（設計図）"""
    
    def __init__(self, name, age):
        """
        コンストラクタ: インスタンス作成時に呼ばれる
        self: 自分自身を指す（必須）
        """
        self.name = name  # インスタンス変数（属性）
        self.age = age    # インスタンス変数（属性）
    
    def bark(self):
        """メソッド: インスタンスの行動"""
        return f"{self.name}「ワンワン！」"
    
    def get_info(self):
        """情報を返すメソッド"""
        return f"{self.name}（{self.age}歳）"

# --- インスタンスの作成 ---
print("\n■ インスタンスを作る")
dog1 = Dog("ポチ", 3)      # インスタンス1を作成
dog2 = Dog("タロー", 5)    # インスタンス2を作成

print(f"犬1: {dog1.get_info()}")  # ポチ（3歳）
print(f"犬2: {dog2.get_info()}")  # タロー（5歳）
print(dog1.bark())  # ポチ「ワンワン！」
print(dog2.bark())  # タロー「ワンワン！」

# --- クラス vs インスタンス ---
print("\n■ クラスとインスタンスの違い")
print("""
クラス（Dog）          : 設計図、レシピ
インスタンス（dog1）   : 実際に作られた物

例え：
  クラス      = たい焼きの型
  インスタンス = 実際に焼いたたい焼き
  
  同じ型（クラス）から、
  何個でもたい焼き（インスタンス）を作れる！
""")

# ==========================================================
# 【2】メリット - なぜクラスを使うのか？
# ==========================================================

print("\n" + "=" * 70)
print("【2】クラスを使うメリット")
print("=" * 70)

print("""
■ メリット1: コードの整理
  関連するデータと機能をまとめられる
  
  クラスなし:
    user_name = "田中"
    user_age = 30
    user_email = "tanaka@example.com"
    
    def get_user_info(name, age, email):
        return f"{name}（{age}歳）"
    
    # 関数呼び出しが面倒...
    get_user_info(user_name, user_age, user_email)
  
  クラスあり:
    user = User("田中", 30, "tanaka@example.com")
    user.get_info()  # シンプル！

■ メリット2: 再利用性
  一度クラスを作れば、何度でも使い回せる
  
  user1 = User("田中", 30, "tanaka@xx.com")
  user2 = User("佐藤", 25, "sato@xx.com")
  user3 = User("鈴木", 35, "suzuki@xx.com")

■ メリット3: 保守性
  変更が1箇所で済む
  
  クラスの定義を変えれば、
  全てのインスタンスに反映される

■ メリット4: 現実世界のモデル化
  現実の「モノ」をそのままコードにできる
  
  例: ゲーム
    - プレイヤークラス
    - 敵クラス
    - アイテムクラス

■ メリット5: チーム開発
  クラスごとに担当を分けられる
  インターフェース（使い方）を決めれば、
  中身は別々に作れる
""")

# ==========================================================
# 【3】public と private - カプセル化
# ==========================================================

print("\n" + "=" * 70)
print("【3】public と private - 情報の隠蔽")
print("=" * 70)

class BankAccount:
    """銀行口座クラス - カプセル化の例"""
    
    def __init__(self, owner, initial_balance=0):
        # public属性（普通の属性）
        self.owner = owner  # 誰でもアクセス可能
        
        # protected属性（_で始まる）慣習的に内部使用
        self._account_number = "123-456-789"
        
        # private属性（__で始まる）外部から直接アクセス不可
        self.__balance = initial_balance  # 残高は隠す
    
    # publicメソッド（外部から使える）
    def deposit(self, amount):
        """入金（公開メソッド）"""
        if amount > 0:
            self.__balance += amount  # privateにアクセス
            return f"{amount}円を入金しました"
        return "入金額は正の数である必要があります"
    
    def withdraw(self, amount):
        """出金（公開メソッド）"""
        if amount > self.__balance:
            return "残高不足です"
        self.__balance -= amount
        return f"{amount}円を出金しました"
    
    # getter（privateな値を取得）
    def get_balance(self):
        """残高を取得"""
        return self.__balance
    
    # setter（privateな値を設定）
    def set_balance(self, amount):
        """残高を設定（検証付き）"""
        if amount >= 0:
            self.__balance = amount
        else:
            raise ValueError("残高は0以上である必要があります")
    
    # protectedメソッド（_で始まる）
    def _internal_process(self):
        """内部処理用メソッド"""
        return "内部処理中..."
    
    # privateメソッド（__で始まる）
    def __validate(self, amount):
        """検証用のプライベートメソッド"""
        return amount > 0

# --- 使用例 ---
print("\n■ public と private の動作")
account = BankAccount("田中太郎", 10000)

# public属性はアクセス可能
print(f"口座名義: {account.owner}")  # OK

# publicメソッドで操作
print(account.deposit(5000))         # OK
print(f"残高: {account.get_balance()}円")  # OK

# private属性に直接アクセスしようとすると...
# print(account.__balance)  # エラー！AttributeError

# 正しい方法: getterを使う
print(f"残高（正しい方法）: {account.get_balance()}円")

print("\n■ アクセス制御のまとめ")
print("""
┌─────────────┬────────────┬──────────────┐
│ 記法        │ 名前       │ アクセス     │
├─────────────┼────────────┼──────────────┤
│ name        │ public     │ どこからでも │
│ _name       │ protected  │ 慣習的に内部 │
│ __name      │ private    │ 外部不可     │
└─────────────┴────────────┴──────────────┘

注意: Pythonには厳密なprivateはない
     __name は名前マングリングで隠蔽されるだけ
     _ClassName__name でアクセス可能（非推奨）
""")

# ==========================================================
# 【4】継承 - 親子関係
# ==========================================================

print("\n" + "=" * 70)
print("【4】継承 - 親クラスと子クラス")
print("=" * 70)

# --- 親クラス（基底クラス）---
class Animal:
    """動物クラス（親）"""
    
    def __init__(self, name, age):
        self.name = name  # 名前
        self.age = age    # 年齢
    
    def eat(self):
        """食べる（共通の行動）"""
        return f"{self.name}が食べています"
    
    def sleep(self):
        """寝る（共通の行動）"""
        return f"{self.name}が寝ています"
    
    def speak(self):
        """鳴く（子クラスでオーバーライドされる）"""
        return f"{self.name}が何か音を出しています"

# --- 子クラス1（派生クラス）---
class Cat(Animal):  # Animalを継承
    """猫クラス（子）"""
    
    def __init__(self, name, age, color):
        # 親クラスのコンストラクタを呼ぶ
        super().__init__(name, age)
        # 子クラス独自の属性
        self.color = color
    
    def speak(self):
        """メソッドのオーバーライド（上書き）"""
        return f"{self.name}「ニャー」"
    
    def scratch(self):
        """猫独自のメソッド"""
        return f"{self.name}が爪を研いでいます"

# --- 子クラス2 ---
class Bird(Animal):  # Animalを継承
    """鳥クラス（子）"""
    
    def __init__(self, name, age, can_fly=True):
        super().__init__(name, age)
        self.can_fly = can_fly
    
    def speak(self):
        """メソッドのオーバーライド"""
        return f"{self.name}「ピヨピヨ」"
    
    def fly(self):
        """鳥独自のメソッド"""
        if self.can_fly:
            return f"{self.name}が飛んでいます"
        return f"{self.name}は飛べません"

# --- 使用例 ---
print("\n■ 継承の動作確認")
cat = Cat("タマ", 3, "三毛")
bird = Bird("ピーちゃん", 1, can_fly=True)

# 親クラスのメソッドが使える
print(cat.eat())    # Animalから継承
print(bird.sleep()) # Animalから継承

# 子クラスでオーバーライドされたメソッド
print(cat.speak())  # ニャー
print(bird.speak()) # ピヨピヨ

# 子クラス独自のメソッド
print(cat.scratch())  # 猫だけ
print(bird.fly())     # 鳥だけ

print("\n■ 継承のメリット")
print("""
✅ コードの再利用
   共通部分（eat, sleep）は親に書くだけ
   
✅ 階層構造
   Animal
   ├── Cat
   ├── Dog
   └── Bird
   
✅ 拡張が容易
   新しい動物を追加しやすい
   
✅ 保守性
   共通処理の変更が1箇所で済む
""")

# ==========================================================
# 【5】ポリモーフィズム - 多態性
# ==========================================================

print("\n" + "=" * 70)
print("【5】ポリモーフィズム - 同じ命令で違う動き")
print("=" * 70)

# ポリモーフィズムの実演
def make_sound(animal):
    """どんな動物でも鳴かせる関数"""
    print(animal.speak())  # 同じメソッド名を呼ぶだけ

# 異なる種類の動物を作成
animals = [
    Cat("ミケ", 2, "三毛"),
    Bird("ポッポ", 1, True),
    Cat("クロ", 4, "黒"),
    Bird("ペンペン", 3, False)
]

print("\n■ ポリモーフィズムの実演")
for animal in animals:
    make_sound(animal)  # 同じ関数で違う結果！

print("\n■ ポリモーフィズムとは")
print("""
「同じ命令」で「違う動作」をする仕組み

例：
  make_sound(猫)  → ニャー
  make_sound(鳥)  → ピヨピヨ
  make_sound(犬)  → ワンワン
  
  関数は animal.speak() を呼ぶだけ
  具体的な動作は各クラスが決める

メリット:
  ✅ 柔軟なコード
  ✅ 拡張が容易（新しい動物を追加しやすい）
  ✅ 統一されたインターフェース
""")

# ==========================================================
# 【6】オーバーライド vs オーバーロード
# ==========================================================

print("\n" + "=" * 70)
print("【6】オーバーライド vs オーバーロード")
print("=" * 70)

# --- オーバーライド ---
print("\n■ オーバーライド（上書き）")

class Parent:
    """親クラス"""
    def greet(self):
        return "こんにちは（親）"

class Child(Parent):
    """子クラス"""
    def greet(self):
        """親のメソッドをオーバーライド"""
        return "こんにちは（子）"

parent = Parent()
child = Child()
print(f"親: {parent.greet()}")  # こんにちは（親）
print(f"子: {child.greet()}")   # こんにちは（子）← 上書きされた

# --- オーバーロード（Pythonでは特殊）---
print("\n■ オーバーロード（Pythonの方法）")

class Calculator:
    """計算機クラス"""
    
    # Pythonには厳密なオーバーロードがない
    # デフォルト引数で実現
    def add(self, a, b=0, c=0):
        """
        引数の数に応じて動作が変わる
        add(5)      → 5 + 0 + 0 = 5
        add(5, 3)   → 5 + 3 + 0 = 8
        add(5, 3, 2) → 5 + 3 + 2 = 10
        """
        return a + b + c
    
    # 可変長引数でも実現可能
    def multiply(self, *args):
        """
        任意の個数の引数を掛け算
        multiply(2, 3)       → 6
        multiply(2, 3, 4)    → 24
        multiply(2, 3, 4, 5) → 120
        """
        result = 1
        for num in args:
            result *= num
        return result

calc = Calculator()
print(f"add(5): {calc.add(5)}")           # 5
print(f"add(5, 3): {calc.add(5, 3)}")     # 8
print(f"add(5, 3, 2): {calc.add(5, 3, 2)}")  # 10
print(f"multiply(2, 3): {calc.multiply(2, 3)}")        # 6
print(f"multiply(2, 3, 4): {calc.multiply(2, 3, 4)}")  # 24

print("\n■ オーバーライド vs オーバーロード")
print("""
┌──────────────┬────────────────────────┐
│ オーバーライド │ 親のメソッドを子が上書き │
│ (Override)   │ 継承で使う             │
├──────────────┼────────────────────────┤
│ オーバーロード │ 同じ名前で引数が違う   │
│ (Overload)   │ Pythonは非対応*        │
└──────────────┴────────────────────────┘

*Pythonでは:
  - デフォルト引数
  - 可変長引数（*args, **kwargs）
  で似たことを実現
""")

# ==========================================================
# 【7】チートシート - OOPの全体像
# ==========================================================

print("\n" + "=" * 70)
print("【7】オブジェクト指向チートシート")
print("=" * 70)

cheatsheet = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃        オブジェクト指向プログラミング全体像        ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■ 基本用語
┌─────────────┬──────────────────────────┐
│ クラス      │ 設計図、レシピ、型        │
│ インスタンス│ 実際に作られた物          │
│ 属性        │ データ（変数）            │
│ メソッド    │ 動作（関数）              │
│ self        │ 自分自身を指す            │
│ __init__    │ コンストラクタ（初期化）  │
└─────────────┴──────────────────────────┘

■ アクセス制御
┌────────┬─────────┬──────────────┐
│ 記法   │ 意味    │ 外部アクセス │
├────────┼─────────┼──────────────┤
│ name   │ public  │ ○           │
│ _name  │ protect │ △（慣習）   │
│ __name │ private │ ×           │
└────────┴─────────┴──────────────┘

■ 継承
  class 子クラス(親クラス):
      def __init__(self):
          super().__init__()  # 親の初期化
  
  用語:
    - 親クラス = 基底クラス = スーパークラス
    - 子クラス = 派生クラス = サブクラス
  
  メリット:
    ✅ コードの再利用
    ✅ 階層構造
    ✅ 拡張が容易

■ ポリモーフィズム
  同じメソッド名で違う動作
  
  例:
    animal.speak()
    ├─ 猫なら「ニャー」
    ├─ 犬なら「ワンワン」
    └─ 鳥なら「ピヨピヨ」
  
  実現方法:
    - オーバーライド（メソッドの上書き）

■ オーバーライド vs オーバーロード
  オーバーライド:
    親のメソッドを子が上書き
    class Child(Parent):
        def method(self):  # 親を上書き
            pass
  
  オーバーロード:
    同じ名前で引数違い（Pythonは非対応）
    → デフォルト引数や*argsで代用

■ カプセル化
  データと機能をまとめて、内部を隠す
  
  目的:
    ✅ データ保護
    ✅ 使いやすいインターフェース
    ✅ 変更の影響を最小化
  
  実装:
    - privateな属性（__balance）
    - publicなメソッド（get_balance）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ クラス設計のフローチャート

Q1: 共通する属性や動作がある？
    ├─ YES → クラスを作る
    └─ NO  → 関数で十分

Q2: 似たようなクラスが複数ある？
    ├─ YES → 親クラスに共通部分をまとめる（継承）
    └─ NO  → 単独のクラス

Q3: 外部から直接変更されたくない属性がある？
    ├─ YES → private（__属性）にする
    └─ NO  → publicのまま

Q4: 同じメソッド名で違う動作が必要？
    ├─ YES → オーバーライド
    └─ NO  → 新しいメソッド名

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ よくあるパターン

パターン1: データの管理
  class User:
      def __init__(self, name, email):
          self.name = name
          self.email = email

パターン2: 処理のカプセル化
  class FileManager:
      def read(self, path):
          pass
      def write(self, path, data):
          pass

パターン3: 階層構造
  class Vehicle:        # 乗り物（親）
      pass
  
  class Car(Vehicle):   # 車（子）
      pass
  
  class Bike(Vehicle):  # バイク（子）
      pass

パターン4: 状態管理
  class Game:
      def __init__(self):
          self.__score = 0
      
      def add_score(self, points):
          self.__score += points
      
      def get_score(self):
          return self.__score
"""

print(cheatsheet)

# ==========================================================
# 【8】実践例 - RPGゲーム
# ==========================================================

print("\n" + "=" * 70)
print("【8】実践例 - RPGゲームキャラクター")
print("=" * 70)

class Character:
    """キャラクタークラス（親）"""
    
    def __init__(self, name, hp, attack):
        self.name = name      # 名前
        self.__hp = hp        # HP（private）
        self.attack = attack  # 攻撃力
    
    def get_hp(self):
        """HPを取得"""
        return self.__hp
    
    def take_damage(self, damage):
        """ダメージを受ける"""
        self.__hp -= damage
        if self.__hp < 0:
            self.__hp = 0
        return f"{self.name}は{damage}のダメージを受けた！（残りHP: {self.__hp}）"
    
    def is_alive(self):
        """生きているか"""
        return self.__hp > 0
    
    def special_attack(self):
        """特殊攻撃（子クラスでオーバーライド）"""
        return f"{self.name}の攻撃！"

class Warrior(Character):
    """戦士クラス（子）"""
    
    def special_attack(self):
        """特殊攻撃をオーバーライド"""
        return f"{self.name}の剣技！ダメージ: {self.attack * 2}"

class Mage(Character):
    """魔法使いクラス（子）"""
    
    def __init__(self, name, hp, attack, mp):
        super().__init__(name, hp, attack)
        self.__mp = mp  # 魔法使い独自の属性
    
    def special_attack(self):
        """特殊攻撃をオーバーライド"""
        if self.__mp >= 10:
            self.__mp -= 10
            return f"{self.name}の魔法！ダメージ: {self.attack * 3}"
        return f"{self.name}はMPが足りない！"

# ゲームの実行
print("\n■ バトル開始")
warrior = Warrior("勇者", 100, 20)
mage = Mage("魔法使い", 80, 15, 50)

print(warrior.special_attack())  # ポリモーフィズム
print(mage.special_attack())     # ポリモーフィズム

print(mage.take_damage(30))
print(f"{mage.name}は生きている？: {mage.is_alive()}")

print("\n" + "=" * 70)
print("これでオブジェクト指向マスター！")
print("=" * 70)

Pythonのオブジェクト指向プログラミングについて、超詳しいガイドを作成しました！

## 🎯 超シンプルに理解

### クラス = 設計図、インスタンス = 実物

```python
# クラス（たい焼きの型）
class Dog:
    def __init__(self, name):
        self.name = name

# インスタンス（実際のたい焼き）
dog1 = Dog("ポチ")  # たい焼き1個目
dog2 = Dog("タロー")  # たい焼き2個目
```

## 📋 重要用語チートシート

```
┌──────────────┬────────────────────┐
│ 用語         │ 意味               │
├──────────────┼────────────────────┤
│ クラス       │ 設計図             │
│ インスタンス │ 実物               │
│ 属性         │ データ（変数）     │
│ メソッド     │ 動作（関数）       │
│ self         │ 自分自身           │
│ __init__     │ コンストラクタ     │
└──────────────┴────────────────────┘
```

## 🔐 public / private / protected

```python
class MyClass:
    def __init__(self):
        self.public = "誰でも"        # public
        self._protected = "内部用"    # protected
        self.__private = "完全に隠す" # private

obj = MyClass()
print(obj.public)      # ○ OK
print(obj._protected)  # △ 使える（推奨されない）
print(obj.__private)   # × エラー！
```

**覚え方：**
```
name      → 普通（public）
_name     → アンダーバー1つ（protected）
__name    → アンダーバー2つ（private）
```

## 👨‍👩‍👧 継承 - 親子関係

```python
# 親クラス
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "何か音"

# 子クラス（Animalを継承）
class Dog(Animal):
    def speak(self):
        return "ワンワン"  # 親を上書き

# 使い方
dog = Dog("ポチ")
print(dog.speak())  # ワンワン（子の動作）
```

**メリット：**
- ✅ コードを再利用
- ✅ 共通部分をまとめる
- ✅ 新しいクラスを追加しやすい

## 🎭 ポリモーフィズム - 同じ命令で違う動き

```python
def make_sound(animal):
    print(animal.speak())  # 同じメソッド

cat = Cat("タマ")
dog = Dog("ポチ")

make_sound(cat)  # ニャー
make_sound(dog)  # ワンワン

# 同じ関数で違う結果！これがポリモーフィズム
```

## 🔄 オーバーライド vs オーバーロード

### オーバーライド（Override）- 上書き

```python
class Parent:
    def greet(self):
        return "こんにちは（親）"

class Child(Parent):
    def greet(self):  # 親のメソッドを上書き
        return "こんにちは（子）"

child = Child()
print(child.greet())  # こんにちは（子）← 上書きされた！
```

### オーバーロード（Overload）- Pythonの方法

```python
# Pythonには厳密なオーバーロードがない
# デフォルト引数で実現

class Calculator:
    def add(self, a, b=0, c=0):
        """引数の数で動作が変わる"""
        return a + b + c

calc = Calculator()
print(calc.add(5))        # 5
print(calc.add(5, 3))     # 8
print(calc.add(5, 3, 2))  # 10

# または可変長引数
class Calculator2:
    def multiply(self, *args):
        """任意の個数を掛け算"""
        result = 1
        for n in args:
            result *= n
        return result

calc2 = Calculator2()
print(calc2.multiply(2, 3))      # 6
print(calc2.multiply(2, 3, 4))   # 24
```

## 📊 比較表

```
┌──────────────┬────────────────┬──────────────┐
│ 機能         │ 説明           │ 使う場面     │
├──────────────┼────────────────┼──────────────┤
│ オーバーライド│ 親を上書き     │ 継承で使う   │
│ オーバーロード│ 引数で変化     │ 柔軟な関数   │
│ 継承         │ 親子関係       │ 共通化       │
│ ポリモーフィズム│ 同じ命令違う動作│ 統一I/F    │
│ カプセル化   │ データ隠蔽     │ 保護         │
└──────────────┴────────────────┴──────────────┘
```

## 🎮 実践例：RPGゲーム

```python
# 親クラス
class Character:
    def __init__(self, name, hp, attack):
        self.name = name
        self.__hp = hp  # private
        self.attack = attack
    
    def get_hp(self):
        return self.__hp
    
    def take_damage(self, damage):
        self.__hp -= damage
        return f"{self.name}: HP {self.__hp}"
    
    def special_attack(self):
        """子クラスでオーバーライドされる"""
        return f"{self.name}の攻撃！"

# 子クラス1：戦士
class Warrior(Character):
    def special_attack(self):
        """オーバーライド"""
        return f"{self.name}の剣技！ダメージ{self.attack * 2}"

# 子クラス2：魔法使い
class Mage(Character):
    def __init__(self, name, hp, attack, mp):
        super().__init__(name, hp, attack)  # 親を初期化
        self.mp = mp  # 魔法使い独自
    
    def special_attack(self):
        """オーバーライド"""
        if self.mp >= 10:
            self.mp -= 10
            return f"{self.name}の魔法！ダメージ{self.attack * 3}"
        return f"{self.name}はMPが足りない"

# ポリモーフィズムの実演
def battle(character):
    """どんなキャラでも攻撃できる"""
    print(character.special_attack())

# 使用
warrior = Warrior("勇者", 100, 20)
mage = Mage("魔法使い", 80, 15, 50)

battle(warrior)  # 剣技！ダメージ40
battle(mage)     # 魔法！ダメージ45
```

## 🗺️ クラス設計フローチャート

```
データと動作をまとめたい？
├─ YES
│  └─ クラスを作る
│     └─ 似たクラスが複数ある？
│        ├─ YES → 親クラスを作る（継承）
│        └─ NO  → 単独クラス
│
└─ NO → 関数で十分

外部から変更されたくない？
├─ YES → private (__name)
└─ NO  → public (name)

親のメソッドを変更したい？
├─ YES → オーバーライド
└─ NO  → 新メソッド
```

## 💡 よくあるパターン

### パターン1：データ管理

```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def get_info(self):
        return f"{self.name} ({self.email})"
```

### パターン2：階層構造

```python
class Vehicle:        # 親：乗り物
    def move(self):
        pass

class Car(Vehicle):   # 子：車
    def move(self):
        return "道路を走る"

class Boat(Vehicle):  # 子：船
    def move(self):
        return "水上を進む"
```

### パターン3：状態管理

```python
class Game:
    def __init__(self):
        self.__score = 0  # private
    
    def add_score(self, points):
        self.__score += points
    
    def get_score(self):
        return self.__score
```

## 📝 クイックリファレンス

### クラスの基本形

```python
class ClassName:
    """クラスの説明"""
    
    def __init__(self, param):
        """コンストラクタ"""
        self.attribute = param  # 属性
    
    def method(self):
        """メソッド"""
        return self.attribute

# 使用
obj = ClassName("値")
print(obj.method())
```

### 継承の基本形

```python
class Parent:
    def __init__(self, param):
        self.param = param

class Child(Parent):
    def __init__(self, param, extra):
        super().__init__(param)  # 親を初期化
        self.extra = extra       # 子独自
```

### アクセス制御

```python
class MyClass:
    def __init__(self):
        self.public = 1      # 誰でもOK
        self._protected = 2  # 内部用（慣習）
        self.__private = 3   # 外部NG
    
    def get_private(self):
        """getter経由でアクセス"""
        return self.__private
```

## ✅ チェックリスト

### いつクラスを使う？

- ✅ 関連するデータと機能をまとめたい
- ✅ 同じ構造のオブジェクトを複数作りたい
- ✅ データを保護したい
- ✅ 継承で拡張したい

### いつ継承を使う？

- ✅ 共通の属性・メソッドがある
- ✅ "is-a"の関係（犬は動物である）
- ✅ コードを再利用したい

### いつprivateを使う？

- ✅ 外部から変更されたくない
- ✅ 内部実装を隠したい
- ✅ データの整合性を保ちたい

## 🎓 まとめ：5つの柱

```
1. クラス・インスタンス
   → 設計図と実物

2. 継承
   → 親子関係でコード再利用

3. ポリモーフィズム
   → 同じ命令で違う動き

4. カプセル化
   → データを隠して保護

5. オーバーライド
   → 親のメソッドを上書き
```

## 🚀 実践のコツ

1. **最初は小さく** - シンプルなクラスから始める
2. **共通部分を探す** - 似たコードがあれば親クラスへ
3. **privateを使う** - 重要なデータは`__`で保護
4. **docstringを書く** - 何をするクラスか説明
5. **テストする** - 各メソッドが正しく動くか確認

これでオブジェクト指向プログラミング完全マスター！実際にゲームやアプリを作って試してみましょう 🎉


ーーー
# ==========================================================
# Python仮想環境トラブルシューティング完全ガイド
# ==========================================================

"""
【よくある仮想環境のトラブル】

1. activate できない
2. 仮想環境が有効にならない
3. ModuleNotFoundError
4. pip が動かない
5. VSCodeが仮想環境を認識しない
6. 複数のPythonバージョンで混乱
7. 仮想環境の削除・再作成
8. パスの問題
"""

print("=" * 70)
print("Python仮想環境トラブルシューティング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】activate できない（Windows）
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル1】activate できない（Windows）")
print("=" * 70)

trouble1 = """
■ エラーメッセージ：
  activate : このシステムではスクリプトの実行が無効になっているため、
  ファイル C:\\...\\activate.ps1 を読み込むことができません。

■ 原因：
  PowerShellの実行ポリシーが制限されている

■ 解決方法1：実行ポリシーを変更（推奨）
-----------------------------------------------------------
# PowerShellを管理者として起動
1. Windowsキー → "PowerShell" と検索
2. 右クリック → "管理者として実行"

# 実行ポリシーを変更
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser

# 確認
Get-ExecutionPolicy

# これで activate が使えるようになる
venv\\Scripts\\activate
-----------------------------------------------------------

■ 解決方法2：.batファイルを使う（簡単）
-----------------------------------------------------------
# activate.ps1 の代わりに activate.bat を使う
venv\\Scripts\\activate.bat

# これなら実行ポリシーの変更不要
-----------------------------------------------------------

■ 解決方法3：コマンドプロンプトを使う
-----------------------------------------------------------
# PowerShellではなくコマンドプロンプトを使う
1. Windowsキー → "cmd" と検索
2. コマンドプロンプトを開く

# activateを実行
venv\\Scripts\\activate.bat
-----------------------------------------------------------

■ 解決方法4：VSCodeのターミナル設定を変更
-----------------------------------------------------------
# settings.json に追加
{
    "terminal.integrated.defaultProfile.windows": "Command Prompt"
}

# これでVSCodeのターミナルがコマンドプロンプトになる
-----------------------------------------------------------

■ 確認方法：
  有効化されると、プロンプトに (venv) が表示される
  
  成功例：
    (venv) PS C:\\Users\\...>    ← これが出ればOK！
"""

print(trouble1)

# ==========================================================
# 【2】仮想環境が有効にならない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル2】activate しても (venv) が表示されない")
print("=" * 70)

trouble2 = """
■ 症状：
  activate を実行しても、プロンプトに (venv) が表示されない

■ 確認方法：
-----------------------------------------------------------
# どのPythonを使っているか確認
# Windows:
where python

# Mac/Linux:
which python

# 仮想環境内のPythonを指しているはずが、
# システムのPythonを指している場合は失敗
-----------------------------------------------------------

■ 解決方法1：パスを確認
-----------------------------------------------------------
# 正しいパスで activate しているか確認

# 現在のディレクトリを確認
pwd    # Mac/Linux
cd     # Windows

# プロジェクトのルートディレクトリにいることを確認
# その後、activate

# Windows:
venv\\Scripts\\activate

# Mac/Linux:
source venv/bin/activate
-----------------------------------------------------------

■ 解決方法2：フルパスで実行
-----------------------------------------------------------
# Windows:
C:\\Users\\YourName\\project\\venv\\Scripts\\activate

# Mac/Linux:
source /Users/YourName/project/venv/bin/activate
-----------------------------------------------------------

■ 解決方法3：仮想環境を作り直す
-----------------------------------------------------------
# 古い仮想環境を削除
# Windows:
rmdir /s venv

# Mac/Linux:
rm -rf venv

# 新しく作成
python -m venv venv

# 有効化
# Windows:
venv\\Scripts\\activate

# Mac/Linux:
source venv/bin/activate
-----------------------------------------------------------

■ 解決方法4：Python本体を確認
-----------------------------------------------------------
# Pythonが正しくインストールされているか
python --version

# 複数のPythonがある場合は明示的に指定
python3 -m venv venv    # Python 3を使う
python3.11 -m venv venv # Python 3.11を使う
-----------------------------------------------------------
"""

print(trouble2)

# ==========================================================
# 【3】ModuleNotFoundError
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル3】ModuleNotFoundError: No module named 'xxx'")
print("=" * 70)

trouble3 = """
■ エラーメッセージ：
  ModuleNotFoundError: No module named 'requests'
  （または他のパッケージ名）

■ 原因：
  パッケージがインストールされていない
  または
  仮想環境を有効化していない

■ 解決方法1：仮想環境を有効化してからインストール
-----------------------------------------------------------
# 1. 仮想環境を有効化
venv\\Scripts\\activate    # Windows
source venv/bin/activate  # Mac/Linux

# 2. プロンプトに (venv) が表示されることを確認
(venv) C:\\...>

# 3. パッケージをインストール
pip install requests

# 4. 確認
pip list
-----------------------------------------------------------

■ 解決方法2：requirements.txt からインストール
-----------------------------------------------------------
# プロジェクトに requirements.txt がある場合
(venv) pip install -r requirements.txt

# これで必要なパッケージが全てインストールされる
-----------------------------------------------------------

■ 解決方法3：正しいPythonを使っているか確認
-----------------------------------------------------------
# 仮想環境のPythonを使っているか確認
# Windows:
where python

# Mac/Linux:
which python

# 出力例（正しい場合）:
# C:\\project\\venv\\Scripts\\python.exe    ← venv内
# /Users/name/project/venv/bin/python      ← venv内

# システムのPythonを指している場合は、
# 仮想環境が有効化されていない
-----------------------------------------------------------

■ 解決方法4：VSCodeの設定
-----------------------------------------------------------
# VSCodeが正しいインタープリタを使っているか確認

1. Ctrl + Shift + P
2. "Python: Select Interpreter" を選択
3. "./venv/Scripts/python.exe" を選択（venv内のPython）

# VSCodeを再起動
-----------------------------------------------------------

■ 解決方法5：パッケージ名を確認
-----------------------------------------------------------
# パッケージ名が正しいか確認
# 例：beautifulsoup4 は bs4 としてインポート

pip install beautifulsoup4
import bs4  # ← インポート名が違う！

# 公式ドキュメントでインストール方法を確認
-----------------------------------------------------------
"""

print(trouble3)

# ==========================================================
# 【4】pip が動かない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル4】pip が動かない・認識されない")
print("=" * 70)

trouble4 = """
■ エラーメッセージ：
  'pip' は、内部コマンドまたは外部コマンド...として認識されていません

■ 解決方法1：python -m pip を使う（推奨）
-----------------------------------------------------------
# pip コマンドの代わりに python -m pip を使う
python -m pip install requests
python -m pip list
python -m pip freeze

# これで確実に仮想環境のpipを使える
-----------------------------------------------------------

■ 解決方法2：pipをアップグレード
-----------------------------------------------------------
# pipが古い可能性
python -m pip install --upgrade pip

# エラーが出る場合
python -m ensurepip --upgrade
-----------------------------------------------------------

■ 解決方法3：仮想環境を作り直す
-----------------------------------------------------------
# 仮想環境が壊れている可能性
# 削除
rm -rf venv  # Mac/Linux
rmdir /s venv  # Windows

# 再作成
python -m venv venv

# 有効化
source venv/bin/activate  # Mac/Linux
venv\\Scripts\\activate    # Windows

# pipを更新
python -m pip install --upgrade pip
-----------------------------------------------------------

■ 解決方法4：パスを確認
-----------------------------------------------------------
# pipが正しい場所にあるか確認
# Windows:
where pip

# Mac/Linux:
which pip

# 仮想環境内を指しているべき
# 例: C:\\project\\venv\\Scripts\\pip.exe
-----------------------------------------------------------

■ 解決方法5：SSL証明書エラーの場合
-----------------------------------------------------------
# SSL証明書エラーが出る場合
pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org requests

# または環境変数を設定
set PIP_TRUSTED_HOST=pypi.org files.pythonhosted.org  # Windows
export PIP_TRUSTED_HOST=pypi.org files.pythonhosted.org  # Mac/Linux
-----------------------------------------------------------
"""

print(trouble4)

# ==========================================================
# 【5】VSCodeが仮想環境を認識しない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル5】VSCodeが仮想環境を認識しない")
print("=" * 70)

trouble5 = """
■ 症状：
  VSCodeでプログラムを実行すると、
  仮想環境のパッケージが見つからない

■ 解決方法1：インタープリタを選択（最重要）
-----------------------------------------------------------
1. Ctrl + Shift + P（コマンドパレット）
2. "Python: Select Interpreter" と入力
3. "./venv/Scripts/python.exe" を選択
   （venv内のPythonを選ぶ）

# 右下にPythonのバージョンが表示される
# 例: Python 3.11.0 ('venv')  ← venvと表示されればOK
-----------------------------------------------------------

■ 解決方法2：settings.json で設定
-----------------------------------------------------------
# .vscode/settings.json を作成

{
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/Scripts/python.exe",
    "python.terminal.activateEnvironment": true
}

# Mac/Linuxの場合:
{
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/bin/python",
    "python.terminal.activateEnvironment": true
}
-----------------------------------------------------------

■ 解決方法3：VSCodeを再起動
-----------------------------------------------------------
# 設定を変更したら必ずVSCodeを再起動
# ウィンドウを閉じて、もう一度開く
-----------------------------------------------------------

■ 解決方法4：ターミナルで確認
-----------------------------------------------------------
# VSCodeのターミナルを開く（Ctrl + `）

# プロンプトに (venv) が表示されるか確認
(venv) PS C:\\project>  ← これが出ればOK

# 出ない場合は手動で有効化
venv\\Scripts\\activate

# Pythonのパスを確認
where python  # Windows
which python  # Mac/Linux

# venv内を指しているはず
-----------------------------------------------------------

■ 解決方法5：拡張機能を確認
-----------------------------------------------------------
# Python拡張機能がインストールされているか確認
1. 拡張機能タブ（Ctrl + Shift + X）
2. "Python" で検索
3. Microsoft製のPython拡張機能をインストール

# Pylance もインストール（推奨）
-----------------------------------------------------------

■ 解決方法6：.vscode フォルダを作り直す
-----------------------------------------------------------
# .vscodeフォルダを削除
rm -rf .vscode

# VSCodeでフォルダを開き直す
# File → Open Folder

# インタープリタを再選択
Ctrl + Shift + P → "Python: Select Interpreter"
-----------------------------------------------------------
"""

print(trouble5)

# ==========================================================
# 【6】複数のPythonバージョンで混乱
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル6】複数のPythonバージョンで混乱")
print("=" * 70)

trouble6 = """
■ 症状：
  Python 2.7とPython 3.xが混在している
  python と python3 コマンドが違う

■ 確認方法：
-----------------------------------------------------------
# インストールされているPythonを確認
# Windows:
where python
py --list  # 利用可能なバージョン一覧

# Mac/Linux:
which python
which python3
python --version
python3 --version
-----------------------------------------------------------

■ 解決方法1：明示的にバージョン指定
-----------------------------------------------------------
# Python 3.11を使いたい場合
python3.11 -m venv venv

# Python 3を使う（一般的）
python3 -m venv venv

# Windowsでpyコマンドを使う
py -3.11 -m venv venv  # Python 3.11
py -3 -m venv venv     # Python 3の最新
-----------------------------------------------------------

■ 解決方法2：エイリアスを設定
-----------------------------------------------------------
# Mac/Linux: .bashrc や .zshrc に追加
alias python=python3
alias pip=pip3

# 反映
source ~/.bashrc  # または source ~/.zshrc

# これで python コマンドがPython 3になる
-----------------------------------------------------------

■ 解決方法3：古いPythonをアンインストール
-----------------------------------------------------------
# Python 2.7が不要な場合はアンインストール

# Windows:
# コントロールパネル → プログラムと機能 → Python 2.7

# Mac:
# Homebrewでインストールした場合
brew uninstall python@2

# Linux:
sudo apt remove python2.7  # Ubuntu/Debian
-----------------------------------------------------------

■ 解決方法4：pyenvを使う（上級者向け）
-----------------------------------------------------------
# 複数のPythonバージョンを管理するツール

# インストール（Mac/Linux）
curl https://pyenv.run | bash

# Pythonバージョンをインストール
pyenv install 3.11.0
pyenv install 3.10.0

# プロジェクトごとにバージョン指定
cd my_project
pyenv local 3.11.0  # このプロジェクトは3.11を使う

# 仮想環境作成
python -m venv venv  # pyenvで指定したバージョンが使われる
-----------------------------------------------------------
"""

print(trouble6)

# ==========================================================
# 【7】仮想環境の削除・再作成
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル7】仮想環境を作り直したい")
print("=" * 70)

trouble7 = """
■ 状況：
  仮想環境が壊れた
  パッケージがぐちゃぐちゃになった
  最初からやり直したい

■ 完全な再作成手順：
-----------------------------------------------------------
# ステップ1: 現在の依存関係を保存（重要！）
pip freeze > requirements_backup.txt

# ステップ2: 仮想環境を無効化
deactivate

# ステップ3: 仮想環境フォルダを削除
# Windows:
rmdir /s venv

# Mac/Linux:
rm -rf venv

# ステップ4: 新しい仮想環境を作成
python -m venv venv

# ステップ5: 有効化
# Windows:
venv\\Scripts\\activate

# Mac/Linux:
source venv/bin/activate

# ステップ6: pipを最新化
python -m pip install --upgrade pip

# ステップ7: パッケージを再インストール
pip install -r requirements_backup.txt

# ステップ8: 確認
pip list
python -c "import requests; print('OK')"
-----------------------------------------------------------

■ 注意点：
  ✅ requirements.txt は必ず保存してから削除
  ✅ venvフォルダだけ削除（プロジェクトファイルは残す）
  ✅ .gitignore に venv/ が含まれているか確認
-----------------------------------------------------------
"""

print(trouble7)

# ==========================================================
# 【8】パスの問題
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル8】パスの問題・日本語フォルダ")
print("=" * 70)

trouble8 = """
■ 症状：
  日本語が含まれるパスでエラー
  スペースが含まれるパスでエラー

■ 解決方法1：英語のパスを使う（推奨）
-----------------------------------------------------------
# ❌ 悪い例
C:\\ユーザー\\山田太郎\\プロジェクト\\venv
C:\\My Documents\\project\\venv

# ✅ 良い例
C:\\Users\\yamada\\project\\venv
C:\\projects\\myapp\\venv
-----------------------------------------------------------

■ 解決方法2：既存プロジェクトの移動
-----------------------------------------------------------
# プロジェクトを英語のパスに移動

# 1. プロジェクトをコピー
# 例: C:\\ユーザー\\山田\\プロジェクト
#  →  C:\\projects\\myapp

# 2. 仮想環境を削除
cd C:\\projects\\myapp
rmdir /s venv

# 3. 仮想環境を再作成
python -m venv venv
venv\\Scripts\\activate
pip install -r requirements.txt
-----------------------------------------------------------

■ 解決方法3：引用符で囲む
-----------------------------------------------------------
# パスにスペースがある場合は引用符で囲む
"C:\\My Documents\\project\\venv\\Scripts\\activate"
-----------------------------------------------------------

■ 解決方法4：ホームディレクトリ直下に作る
-----------------------------------------------------------
# ユーザーのホームディレクトリに projects フォルダ

# Windows:
mkdir C:\\Users\\%USERNAME%\\projects
cd C:\\Users\\%USERNAME%\\projects

# Mac/Linux:
mkdir ~/projects
cd ~/projects

# ここにプロジェクトを作る
-----------------------------------------------------------
"""

print(trouble8)

# ==========================================================
# 【9】診断スクリプト
# ==========================================================

print("\n" + "=" * 70)
print("【9】環境診断スクリプト")
print("=" * 70)

print("\n■ 以下のコードで環境を診断できます\n")

# 診断スクリプト
import sys
import os

def diagnose_environment():
    """仮想環境の状態を診断"""
    print("=" * 50)
    print("Python環境診断")
    print("=" * 50)
    
    # Pythonバージョン
    print(f"\n【Pythonバージョン】")
    print(f"  {sys.version}")
    
    # 実行ファイルのパス
    print(f"\n【Pythonの実行パス】")
    print(f"  {sys.executable}")
    
    # 仮想環境内かどうか
    print(f"\n【仮想環境の状態】")
    in_venv = (
        hasattr(sys, 'real_prefix') or
        (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
    )
    
    if in_venv:
        print("  ✅ 仮想環境が有効化されています")
        venv_path = os.environ.get('VIRTUAL_ENV', 'パス不明')
        print(f"  仮想環境のパス: {venv_path}")
    else:
        print("  ❌ 仮想環境が有効化されていません")
        print("  → activate を実行してください")
    
    # モジュール検索パス
    print(f"\n【モジュール検索パス（最初の3つ）】")
    for i, path in enumerate(sys.path[:3], 1):
        print(f"  {i}. {path}")
    
    # pip の確認
    print(f"\n【pip】")
    try:
        import pip
        print(f"  ✅ pipが利用可能")
        print(f"  pipバージョン: {pip.__version__}")
    except ImportError:
        print(f"  ❌ pipが見つかりません")
    
    # インストール済みパッケージ数
    try:
        import pkg_resources
        installed = list(pkg_resources.working_set)
        print(f"\n【インストール済みパッケージ】")
        print(f"  合計: {len(installed)}個")
        print(f"  最初の5個:")
        for pkg in sorted(installed, key=lambda x: x.key)[:5]:
            print(f"    - {pkg.key} {pkg.version}")
    except:
        print(f"  パッケージ情報を取得できません")
    
    print("\n" + "=" * 50)
    
    # 推奨アクション
    if not in_venv:
        print("\n【推奨アクション】")
        print("  1. 仮想環境を作成: python -m venv venv")
        print("  2. 有効化:")
        print("     Windows: venv\\Scripts\\activate")
        print("     Mac/Linux: source venv/bin/activate")
    
    print()

# 診断実行
diagnose_environment()

# ==========================================================
# 【10】まとめ：トラブル対処フローチャート
# ==========================================================

print("\n" + "=" * 70)
print("【10】トラブル対処フローチャート")
print("=" * 70)

flowchart = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃    仮想環境トラブル対処フローチャート      ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Q1: activate できない？
├─ Windows → 実行ポリシーを変更 または .bat使用
├─ Mac/Linux → source venv/bin/activate
└─ パスを確認

Q2: (venv) が表示されない？
├─ 正しいパスで実行？
├─ which python で確認
└─ フルパスで実行してみる

Q3: ModuleNotFoundError？
├─ 仮想環境を有効化した？ → activate
├─ パッケージをインストールした？ → pip install
└─ VSCodeのインタープリタ設定を確認

Q4: pip が動かない？
├─ python -m pip を使う
├─ pipをアップグレード
└─ 仮想環境を作り直す

Q5: VSCodeが認識しない？
├─ インタープリタを選択
├─ settings.jsonを設定
└─ VSCodeを再起動

Q6: 複数のPythonで混乱？
├─ python3 を明示的に使う
├─ py -3 を使う（Windows）
└─ バージョンを確認

Q7: 壊れた？
└─ 削除して再作成
   1. pip freeze > requirements.txt
   2. deactivate
   3. rm -rf venv
   4. python -m venv venv
   5. activate
   6. pip install -r requirements.txt

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 万能コマンド集（困ったらこれ）

# 環境診断
python -c "import sys; print(sys.executable)"
python -c "import sys; print(sys.prefix)"

# 仮想環境の再作成
deactivate
rm -rf venv  # Mac/Linux
rmdir /s venv  # Windows
python -m venv venv
source venv/bin/activate  # Mac/Linux
venv\\Scripts\\activate    # Windows
python -m pip install --upgrade pip

# パッケージの確認
pip list
pip show パッケージ名

# VSCodeでの確認
Ctrl + Shift + P → "Python: Select Interpreter"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 予防策

✅ プロジェクト作成時に必ず仮想環境を作る
✅ requirements.txt をこまめに更新
✅ 英語のパスを使う
✅ .gitignore に venv/ を追加
✅ VSCodeの設定を正しく行う
"""

print(flowchart)

print("\n" + "=" * 70)
print("これで仮想環境のトラブルは解決！")
print("=" * 70)

ーーー

解決方法2：.batファイルを使う（簡単）

解決方法2：.batファイルを使う（簡単）Python仮想環境のトラブルシューティングガイドを作成しますね！

# ==========================================================
# Python仮想環境トラブルシューティング完全ガイド
# ==========================================================

"""
【よくある仮想環境のトラブル】

1. activate できない
2. 仮想環境が有効にならない
3. ModuleNotFoundError
4. pip が動かない
5. VSCodeが仮想環境を認識しない
6. 複数のPythonバージョンで混乱
7. 仮想環境の削除・再作成
8. パスの問題
"""

print("=" * 70)
print("Python仮想環境トラブルシューティング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】activate できない（Windows）
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル1】activate できない（Windows）")
print("=" * 70)

trouble1 = """
■ エラーメッセージ：
  activate : このシステムではスクリプトの実行が無効になっているため、
  ファイル C:\\...\\activate.ps1 を読み込むことができません。

■ 原因：
  PowerShellの実行ポリシーが制限されている

■ 解決方法1：実行ポリシーを変更（推奨）
-----------------------------------------------------------
# PowerShellを管理者として起動
1. Windowsキー → "PowerShell" と検索
2. 右クリック → "管理者として実行"

# 実行ポリシーを変更
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser

# 確認
Get-ExecutionPolicy

# これで activate が使えるようになる
venv\\Scripts\\activate
-----------------------------------------------------------

■ 解決方法2：.batファイルを使う（簡単）
-----------------------------------------------------------
# activate.ps1 の代わりに activate.bat を使う
venv\\Scripts\\activate.bat

# これなら実行ポリシーの変更不要
-----------------------------------------------------------

■ 解決方法3：コマンドプロンプトを使う
-----------------------------------------------------------
# PowerShellではなくコマンドプロンプトを使う
1. Windowsキー → "cmd" と検索
2. コマンドプロンプトを開く

# activateを実行
venv\\Scripts\\activate.bat
-----------------------------------------------------------

■ 解決方法4：VSCodeのターミナル設定を変更
-----------------------------------------------------------
# settings.json に追加
{
    "terminal.integrated.defaultProfile.windows": "Command Prompt"
}

# これでVSCodeのターミナルがコマンドプロンプトになる
-----------------------------------------------------------

■ 確認方法：
  有効化されると、プロンプトに (venv) が表示される
  
  成功例：
    (venv) PS C:\\Users\\...>    ← これが出ればOK！
"""

print(trouble1)

# ==========================================================
# 【2】仮想環境が有効にならない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル2】activate しても (venv) が表示されない")
print("=" * 70)

trouble2 = """
■ 症状：
  activate を実行しても、プロンプトに (venv) が表示されない

■ 確認方法：
-----------------------------------------------------------
# どのPythonを使っているか確認
# Windows:
where python

# Mac/Linux:
which python

# 仮想環境内のPythonを指しているはずが、
# システムのPythonを指している場合は失敗
-----------------------------------------------------------

■ 解決方法1：パスを確認
-----------------------------------------------------------
# 正しいパスで activate しているか確認

# 現在のディレクトリを確認
pwd    # Mac/Linux
cd     # Windows

# プロジェクトのルートディレクトリにいることを確認
# その後、activate

# Windows:
venv\\Scripts\\activate

# Mac/Linux:
source venv/bin/activate
-----------------------------------------------------------

■ 解決方法2：フルパスで実行
-----------------------------------------------------------
# Windows:
C:\\Users\\YourName\\project\\venv\\Scripts\\activate

# Mac/Linux:
source /Users/YourName/project/venv/bin/activate
-----------------------------------------------------------

■ 解決方法3：仮想環境を作り直す
-----------------------------------------------------------
# 古い仮想環境を削除
# Windows:
rmdir /s venv

# Mac/Linux:
rm -rf venv

# 新しく作成
python -m venv venv

# 有効化
# Windows:
venv\\Scripts\\activate

# Mac/Linux:
source venv/bin/activate
-----------------------------------------------------------

■ 解決方法4：Python本体を確認
-----------------------------------------------------------
# Pythonが正しくインストールされているか
python --version

# 複数のPythonがある場合は明示的に指定
python3 -m venv venv    # Python 3を使う
python3.11 -m venv venv # Python 3.11を使う
-----------------------------------------------------------
"""

print(trouble2)

# ==========================================================
# 【3】ModuleNotFoundError
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル3】ModuleNotFoundError: No module named 'xxx'")
print("=" * 70)

trouble3 = """
■ エラーメッセージ：
  ModuleNotFoundError: No module named 'requests'
  （または他のパッケージ名）

■ 原因：
  パッケージがインストールされていない
  または
  仮想環境を有効化していない

■ 解決方法1：仮想環境を有効化してからインストール
-----------------------------------------------------------
# 1. 仮想環境を有効化
venv\\Scripts\\activate    # Windows
source venv/bin/activate  # Mac/Linux

# 2. プロンプトに (venv) が表示されることを確認
(venv) C:\\...>

# 3. パッケージをインストール
pip install requests

# 4. 確認
pip list
-----------------------------------------------------------

■ 解決方法2：requirements.txt からインストール
-----------------------------------------------------------
# プロジェクトに requirements.txt がある場合
(venv) pip install -r requirements.txt

# これで必要なパッケージが全てインストールされる
-----------------------------------------------------------

■ 解決方法3：正しいPythonを使っているか確認
-----------------------------------------------------------
# 仮想環境のPythonを使っているか確認
# Windows:
where python

# Mac/Linux:
which python

# 出力例（正しい場合）:
# C:\\project\\venv\\Scripts\\python.exe    ← venv内
# /Users/name/project/venv/bin/python      ← venv内

# システムのPythonを指している場合は、
# 仮想環境が有効化されていない
-----------------------------------------------------------

■ 解決方法4：VSCodeの設定
-----------------------------------------------------------
# VSCodeが正しいインタープリタを使っているか確認

1. Ctrl + Shift + P
2. "Python: Select Interpreter" を選択
3. "./venv/Scripts/python.exe" を選択（venv内のPython）

# VSCodeを再起動
-----------------------------------------------------------

■ 解決方法5：パッケージ名を確認
-----------------------------------------------------------
# パッケージ名が正しいか確認
# 例：beautifulsoup4 は bs4 としてインポート

pip install beautifulsoup4
import bs4  # ← インポート名が違う！

# 公式ドキュメントでインストール方法を確認
-----------------------------------------------------------
"""

print(trouble3)

# ==========================================================
# 【4】pip が動かない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル4】pip が動かない・認識されない")
print("=" * 70)

trouble4 = """
■ エラーメッセージ：
  'pip' は、内部コマンドまたは外部コマンド...として認識されていません

■ 解決方法1：python -m pip を使う（推奨）
-----------------------------------------------------------
# pip コマンドの代わりに python -m pip を使う
python -m pip install requests
python -m pip list
python -m pip freeze

# これで確実に仮想環境のpipを使える
-----------------------------------------------------------

■ 解決方法2：pipをアップグレード
-----------------------------------------------------------
# pipが古い可能性
python -m pip install --upgrade pip

# エラーが出る場合
python -m ensurepip --upgrade
-----------------------------------------------------------

■ 解決方法3：仮想環境を作り直す
-----------------------------------------------------------
# 仮想環境が壊れている可能性
# 削除
rm -rf venv  # Mac/Linux
rmdir /s venv  # Windows

# 再作成
python -m venv venv

# 有効化
source venv/bin/activate  # Mac/Linux
venv\\Scripts\\activate    # Windows

# pipを更新
python -m pip install --upgrade pip
-----------------------------------------------------------

■ 解決方法4：パスを確認
-----------------------------------------------------------
# pipが正しい場所にあるか確認
# Windows:
where pip

# Mac/Linux:
which pip

# 仮想環境内を指しているべき
# 例: C:\\project\\venv\\Scripts\\pip.exe
-----------------------------------------------------------

■ 解決方法5：SSL証明書エラーの場合
-----------------------------------------------------------
# SSL証明書エラーが出る場合
pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org requests

# または環境変数を設定
set PIP_TRUSTED_HOST=pypi.org files.pythonhosted.org  # Windows
export PIP_TRUSTED_HOST=pypi.org files.pythonhosted.org  # Mac/Linux
-----------------------------------------------------------
"""

print(trouble4)

# ==========================================================
# 【5】VSCodeが仮想環境を認識しない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル5】VSCodeが仮想環境を認識しない")
print("=" * 70)

trouble5 = """
■ 症状：
  VSCodeでプログラムを実行すると、
  仮想環境のパッケージが見つからない

■ 解決方法1：インタープリタを選択（最重要）
-----------------------------------------------------------
1. Ctrl + Shift + P（コマンドパレット）
2. "Python: Select Interpreter" と入力
3. "./venv/Scripts/python.exe" を選択
   （venv内のPythonを選ぶ）

# 右下にPythonのバージョンが表示される
# 例: Python 3.11.0 ('venv')  ← venvと表示されればOK
-----------------------------------------------------------

■ 解決方法2：settings.json で設定
-----------------------------------------------------------
# .vscode/settings.json を作成

{
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/Scripts/python.exe",
    "python.terminal.activateEnvironment": true
}

# Mac/Linuxの場合:
{
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/bin/python",
    "python.terminal.activateEnvironment": true
}
-----------------------------------------------------------

■ 解決方法3：VSCodeを再起動
-----------------------------------------------------------
# 設定を変更したら必ずVSCodeを再起動
# ウィンドウを閉じて、もう一度開く
-----------------------------------------------------------

■ 解決方法4：ターミナルで確認
-----------------------------------------------------------
# VSCodeのターミナルを開く（Ctrl + `）

# プロンプトに (venv) が表示されるか確認
(venv) PS C:\\project>  ← これが出ればOK

# 出ない場合は手動で有効化
venv\\Scripts\\activate

# Pythonのパスを確認
where python  # Windows
which python  # Mac/Linux

# venv内を指しているはず
-----------------------------------------------------------

■ 解決方法5：拡張機能を確認
-----------------------------------------------------------
# Python拡張機能がインストールされているか確認
1. 拡張機能タブ（Ctrl + Shift + X）
2. "Python" で検索
3. Microsoft製のPython拡張機能をインストール

# Pylance もインストール（推奨）
-----------------------------------------------------------

■ 解決方法6：.vscode フォルダを作り直す
-----------------------------------------------------------
# .vscodeフォルダを削除
rm -rf .vscode

# VSCodeでフォルダを開き直す
# File → Open Folder

# インタープリタを再選択
Ctrl + Shift + P → "Python: Select Interpreter"
-----------------------------------------------------------
"""

print(trouble5)

# ==========================================================
# 【6】複数のPythonバージョンで混乱
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル6】複数のPythonバージョンで混乱")
print("=" * 70)

trouble6 = """
■ 症状：
  Python 2.7とPython 3.xが混在している
  python と python3 コマンドが違う

■ 確認方法：
-----------------------------------------------------------
# インストールされているPythonを確認
# Windows:
where python
py --list  # 利用可能なバージョン一覧

# Mac/Linux:
which python
which python3
python --version
python3 --version
-----------------------------------------------------------

■ 解決方法1：明示的にバージョン指定
-----------------------------------------------------------
# Python 3.11を使いたい場合
python3.11 -m venv venv

# Python 3を使う（一般的）
python3 -m venv venv

# Windowsでpyコマンドを使う
py -3.11 -m venv venv  # Python 3.11
py -3 -m venv venv     # Python 3の最新
-----------------------------------------------------------

■ 解決方法2：エイリアスを設定
-----------------------------------------------------------
# Mac/Linux: .bashrc や .zshrc に追加
alias python=python3
alias pip=pip3

# 反映
source ~/.bashrc  # または source ~/.zshrc

# これで python コマンドがPython 3になる
-----------------------------------------------------------

■ 解決方法3：古いPythonをアンインストール
-----------------------------------------------------------
# Python 2.7が不要な場合はアンインストール

# Windows:
# コントロールパネル → プログラムと機能 → Python 2.7

# Mac:
# Homebrewでインストールした場合
brew uninstall python@2

# Linux:
sudo apt remove python2.7  # Ubuntu/Debian
-----------------------------------------------------------

■ 解決方法4：pyenvを使う（上級者向け）
-----------------------------------------------------------
# 複数のPythonバージョンを管理するツール

# インストール（Mac/Linux）
curl https://pyenv.run | bash

# Pythonバージョンをインストール
pyenv install 3.11.0
pyenv install 3.10.0

# プロジェクトごとにバージョン指定
cd my_project
pyenv local 3.11.0  # このプロジェクトは3.11を使う

# 仮想環境作成
python -m venv venv  # pyenvで指定したバージョンが使われる
-----------------------------------------------------------
"""

print(trouble6)

# ==========================================================
# 【7】仮想環境の削除・再作成
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル7】仮想環境を作り直したい")
print("=" * 70)

trouble7 = """
■ 状況：
  仮想環境が壊れた
  パッケージがぐちゃぐちゃになった
  最初からやり直したい

■ 完全な再作成手順：
-----------------------------------------------------------
# ステップ1: 現在の依存関係を保存（重要！）
pip freeze > requirements_backup.txt

# ステップ2: 仮想環境を無効化
deactivate

# ステップ3: 仮想環境フォルダを削除
# Windows:
rmdir /s venv

# Mac/Linux:
rm -rf venv

# ステップ4: 新しい仮想環境を作成
python -m venv venv

# ステップ5: 有効化
# Windows:
venv\\Scripts\\activate

# Mac/Linux:
source venv/bin/activate

# ステップ6: pipを最新化
python -m pip install --upgrade pip

# ステップ7: パッケージを再インストール
pip install -r requirements_backup.txt

# ステップ8: 確認
pip list
python -c "import requests; print('OK')"
-----------------------------------------------------------

■ 注意点：
  ✅ requirements.txt は必ず保存してから削除
  ✅ venvフォルダだけ削除（プロジェクトファイルは残す）
  ✅ .gitignore に venv/ が含まれているか確認
-----------------------------------------------------------
"""

print(trouble7)

# ==========================================================
# 【8】パスの問題
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル8】パスの問題・日本語フォルダ")
print("=" * 70)

trouble8 = """
■ 症状：
  日本語が含まれるパスでエラー
  スペースが含まれるパスでエラー

■ 解決方法1：英語のパスを使う（推奨）
-----------------------------------------------------------
# ❌ 悪い例
C:\\ユーザー\\山田太郎\\プロジェクト\\venv
C:\\My Documents\\project\\venv

# ✅ 良い例
C:\\Users\\yamada\\project\\venv
C:\\projects\\myapp\\venv
-----------------------------------------------------------

■ 解決方法2：既存プロジェクトの移動
-----------------------------------------------------------
# プロジェクトを英語のパスに移動

# 1. プロジェクトをコピー
# 例: C:\\ユーザー\\山田\\プロジェクト
#  →  C:\\projects\\myapp

# 2. 仮想環境を削除
cd C:\\projects\\myapp
rmdir /s venv

# 3. 仮想環境を再作成
python -m venv venv
venv\\Scripts\\activate
pip install -r requirements.txt
-----------------------------------------------------------

■ 解決方法3：引用符で囲む
-----------------------------------------------------------
# パスにスペースがある場合は引用符で囲む
"C:\\My Documents\\project\\venv\\Scripts\\activate"
-----------------------------------------------------------

■ 解決方法4：ホームディレクトリ直下に作る
-----------------------------------------------------------
# ユーザーのホームディレクトリに projects フォルダ

# Windows:
mkdir C:\\Users\\%USERNAME%\\projects
cd C:\\Users\\%USERNAME%\\projects

# Mac/Linux:
mkdir ~/projects
cd ~/projects

# ここにプロジェクトを作る
-----------------------------------------------------------
"""

print(trouble8)

# ==========================================================
# 【9】診断スクリプト
# ==========================================================

print("\n" + "=" * 70)
print("【9】環境診断スクリプト")
print("=" * 70)

print("\n■ 以下のコードで環境を診断できます\n")

# 診断スクリプト
import sys
import os

def diagnose_environment():
    """仮想環境の状態を診断"""
    print("=" * 50)
    print("Python環境診断")
    print("=" * 50)
    
    # Pythonバージョン
    print(f"\n【Pythonバージョン】")
    print(f"  {sys.version}")
    
    # 実行ファイルのパス
    print(f"\n【Pythonの実行パス】")
    print(f"  {sys.executable}")
    
    # 仮想環境内かどうか
    print(f"\n【仮想環境の状態】")
    in_venv = (
        hasattr(sys, 'real_prefix') or
        (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
    )
    
    if in_venv:
        print("  ✅ 仮想環境が有効化されています")
        venv_path = os.environ.get('VIRTUAL_ENV', 'パス不明')
        print(f"  仮想環境のパス: {venv_path}")
    else:
        print("  ❌ 仮想環境が有効化されていません")
        print("  → activate を実行してください")
    
    # モジュール検索パス
    print(f"\n【モジュール検索パス（最初の3つ）】")
    for i, path in enumerate(sys.path[:3], 1):
        print(f"  {i}. {path}")
    
    # pip の確認
    print(f"\n【pip】")
    try:
        import pip
        print(f"  ✅ pipが利用可能")
        print(f"  pipバージョン: {pip.__version__}")
    except ImportError:
        print(f"  ❌ pipが見つかりません")
    
    # インストール済みパッケージ数
    try:
        import pkg_resources
        installed = list(pkg_resources.working_set)
        print(f"\n【インストール済みパッケージ】")
        print(f"  合計: {len(installed)}個")
        print(f"  最初の5個:")
        for pkg in sorted(installed, key=lambda x: x.key)[:5]:
            print(f"    - {pkg.key} {pkg.version}")
    except:
        print(f"  パッケージ情報を取得できません")
    
    print("\n" + "=" * 50)
    
    # 推奨アクション
    if not in_venv:
        print("\n【推奨アクション】")
        print("  1. 仮想環境を作成: python -m venv venv")
        print("  2. 有効化:")
        print("     Windows: venv\\Scripts\\activate")
        print("     Mac/Linux: source venv/bin/activate")
    
    print()

# 診断実行
diagnose_environment()

# ==========================================================
# 【10】まとめ：トラブル対処フローチャート
# ==========================================================

print("\n" + "=" * 70)
print("【10】トラブル対処フローチャート")
print("=" * 70)

flowchart = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃    仮想環境トラブル対処フローチャート      ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Q1: activate できない？
├─ Windows → 実行ポリシーを変更 または .bat使用
├─ Mac/Linux → source venv/bin/activate
└─ パスを確認

Q2: (venv) が表示されない？
├─ 正しいパスで実行？
├─ which python で確認
└─ フルパスで実行してみる

Q3: ModuleNotFoundError？
├─ 仮想環境を有効化した？ → activate
├─ パッケージをインストールした？ → pip install
└─ VSCodeのインタープリタ設定を確認

Q4: pip が動かない？
├─ python -m pip を使う
├─ pipをアップグレード
└─ 仮想環境を作り直す

Q5: VSCodeが認識しない？
├─ インタープリタを選択
├─ settings.jsonを設定
└─ VSCodeを再起動

Q6: 複数のPythonで混乱？
├─ python3 を明示的に使う
├─ py -3 を使う（Windows）
└─ バージョンを確認

Q7: 壊れた？
└─ 削除して再作成
   1. pip freeze > requirements.txt
   2. deactivate
   3. rm -rf venv
   4. python -m venv venv
   5. activate
   6. pip install -r requirements.txt

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 万能コマンド集（困ったらこれ）

# 環境診断
python -c "import sys; print(sys.executable)"
python -c "import sys; print(sys.prefix)"

# 仮想環境の再作成
deactivate
rm -rf venv  # Mac/Linux
rmdir /s venv  # Windows
python -m venv venv
source venv/bin/activate  # Mac/Linux
venv\\Scripts\\activate    # Windows
python -m pip install --upgrade pip

# パッケージの確認
pip list
pip show パッケージ名

# VSCodeでの確認
Ctrl + Shift + P → "Python: Select Interpreter"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 予防策

✅ プロジェクト作成時に必ず仮想環境を作る
✅ requirements.txt をこまめに更新
✅ 英語のパスを使う
✅ .gitignore に venv/ を追加
✅ VSCodeの設定を正しく行う
"""

print(flowchart)

print("\n" + "=" * 70)
print("これで仮想環境のトラブルは解決！")
print("=" * 70)

Python仮想環境のトラブルシューティングガイドを作成しました！

## 🚨 よくあるトラブル TOP 5

### 1️⃣ **activate できない（Windows）**

```powershell
# エラー: スクリプトの実行が無効...

# 解決方法（簡単）
venv\Scripts\activate.bat  # .bat を使う

# または実行ポリシーを変更
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```

### 2️⃣ **ModuleNotFoundError**

```python
# エラー: No module named 'requests'

# 原因: 仮想環境を有効化していない

# 解決
venv\Scripts\activate          # 有効化
pip install requests           # インストール
```

### 3️⃣ **(venv) が表示されない**

```bash
# activate しても何も変わらない

# 確認
where python   # Windows
which python   # Mac/Linux

# venv内を指していなければ失敗
# → 正しいパスで activate する
```

### 4️⃣ **VSCodeが認識しない**

```
# 解決方法
1. Ctrl + Shift + P
2. "Python: Select Interpreter"
3. "./venv/Scripts/python.exe" を選択
4. VSCodeを再起動
```

### 5️⃣ **pip が動かない**

```bash
# エラー: 'pip' は認識されていません

# 解決（確実な方法）
python -m pip install requests
python -m pip list
```

## 🔧 万能解決法：再作成

```bash
# 壊れたら作り直すのが一番確実！

# 1. バックアップ
pip freeze > requirements.txt

# 2. 無効化
deactivate

# 3. 削除
rm -rf venv        # Mac/Linux
rmdir /s venv      # Windows

# 4. 再作成
python -m venv venv

# 5. 有効化
source venv/bin/activate  # Mac/Linux
venv\Scripts\activate     # Windows

# 6. 復元
pip install -r requirements.txt
```

## 📊 トラブル診断チェックリスト

```
□ 仮想環境を作成した？
  → python -m venv venv

□ 有効化した？
  → activate を実行

□ (venv) が表示される？
  → プロンプトを確認

□ 正しいPythonを使っている？
  → where python で確認

□ パッケージをインストールした？
  → pip install パッケージ名

□ VSCodeの設定は正しい？
  → インタープリタを選択

□ requirements.txt がある？
  → pip freeze > requirements.txt
```

## 💡 予防策

```bash
# ✅ 毎回やること
1. プロジェクト作成
   mkdir myproject
   cd myproject

2. 仮想環境作成
   python -m venv venv

3. 有効化
   venv\Scripts\activate

4. パッケージインストール
   pip install パッケージ

5. requirements.txt作成
   pip freeze > requirements.txt

6. .gitignore追加
   echo "venv/" > .gitignore
```

### 🎯 状況別クイック解決

### 状況A：「全く動かない！」

```bash
# まず現状確認
python --version
where python     # Windows
which python     # Mac/Linux

# 仮想環境を作り直す
python -m venv venv --clear  # 強制的に再作成
venv\Scripts\activate
python -m pip install --upgrade pip
```

### 状況B：「昨日まで動いてたのに...」

```bash
# VSCodeを疑う
1. VSCodeを完全終了
2. .vscode フォルダを削除
3. VSCodeを再起動
4. Ctrl + Shift + P → "Python: Select Interpreter"
5. venv内のPythonを選択
```

### 状況C：「requirements.txt からインストールできない」

```bash
# 1つずつインストールしてみる
pip install -r requirements.txt --no-cache-dir

# エラーが出たパッケージを個別に
pip install パッケージ名==バージョン

# バージョン指定を外してみる
pip install パッケージ名
```

### 状況D：「Python 2 と 3 が混在」

```bash
# Python 3を明示的に使う
python3 -m venv venv
python3 -m pip install パッケージ

# Windowsなら py コマンド
py -3 -m venv venv
py -3 -m pip install パッケージ
```

## 🔍 詳細診断コマンド

```bash
# === 環境チェック ===
python --version              # Pythonバージョン
pip --version                # pipバージョン
where python                 # Python実行パス（Windows）
which python                 # Python実行パス（Mac/Linux）

# === 仮想環境チェック ===
echo $VIRTUAL_ENV            # 仮想環境パス（Mac/Linux）
echo %VIRTUAL_ENV%           # 仮想環境パス（Windows）

# === パッケージチェック ===
pip list                     # インストール済み一覧
pip show パッケージ名         # 詳細情報
pip check                    # 依存関係チェック

# === パスチェック ===
python -c "import sys; print(sys.executable)"
python -c "import sys; print(sys.path)"
```

## 📁 正しいフォルダ構成

```
正しい例：
my_project/
├── venv/                    # 仮想環境（Gitに入れない）
├── src/                     # ソースコード
│   └── main.py
├── requirements.txt         # 依存パッケージ
├── .gitignore              # venv/ を除外
└── README.md

間違い例：
C:\ユーザー\山田\プロジェクト\   ← 日本語NG
C:\My Documents\project\        ← スペースNG
```

## ⚙️ VSCode完全設定

### settings.json（プロジェクトルートの .vscode/ に配置）

```json
{
    // Pythonインタープリタ
    "python.defaultInterpreterPath": "${workspaceFolder}/venv/Scripts/python.exe",
    
    // ターミナルで自動有効化
    "python.terminal.activateEnvironment": true,
    
    // Linter設定
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    
    // フォーマッター
    "python.formatting.provider": "black",
    "editor.formatOnSave": true,
    
    // 型チェック
    "python.linting.mypyEnabled": true
}
```

### launch.json（デバッグ設定）

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Current File",
            "type": "python",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal",
            "justMyCode": true,
            "python": "${workspaceFolder}/venv/Scripts/python.exe"
        }
    ]
}
```

## 🆘 緊急時の完全リセット手順

```bash
# ===== STEP 1: バックアップ =====
# 現在のパッケージを保存
pip freeze > backup_requirements.txt

# プロジェクトファイルもバックアップ
# （念のため別フォルダにコピー）

# ===== STEP 2: 完全削除 =====
# 仮想環境を無効化
deactivate

# 仮想環境フォルダを削除
# Windows:
rmdir /s /q venv

# Mac/Linux:
rm -rf venv

# VSCode設定も削除（必要なら）
rm -rf .vscode

# ===== STEP 3: 再作成 =====
# 新しい仮想環境
python -m venv venv

# 有効化
# Windows:
venv\Scripts\activate

# Mac/Linux:
source venv/bin/activate

# ===== STEP 4: セットアップ =====
# pipを最新化
python -m pip install --upgrade pip

# パッケージを再インストール
pip install -r backup_requirements.txt

# 動作確認
python -c "import sys; print('Python:', sys.version)"
pip list

# ===== STEP 5: VSCode再設定 =====
# VSCodeを開く
code .

# インタープリタを選択
# Ctrl + Shift + P → "Python: Select Interpreter"
# → venv/Scripts/python.exe を選択

# ターミナルで確認
# (venv) が表示されることを確認
```

## 📚 エラーメッセージ別対処法

### エラー1: `SSL: CERTIFICATE_VERIFY_FAILED`

```bash
# SSL証明書エラー
pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org パッケージ名

# または証明書を更新
pip install --upgrade certifi
```

### エラー2: `Permission denied`

```bash
# 権限エラー
# 解決1: ユーザー領域にインストール
pip install --user パッケージ名

# 解決2: 仮想環境を使う（推奨）
```

### エラー3: `No space left on device`

```bash
# ディスク容量不足
# キャッシュをクリア
pip cache purge

# または
rm -rf ~/.cache/pip
```

### エラー4: `Failed building wheel`

```bash
# ビルドツールが必要
# Windows: Visual Studio Build Tools をインストール
# Mac: xcode-select --install
# Linux: sudo apt install python3-dev
```

### エラー5: `externally-managed-environment`

```bash
# Python 3.11以降でシステムPythonを使った場合
# 解決: 必ず仮想環境を使う
python -m venv venv
source venv/bin/activate
```

## 🎓 ベストプラクティス

### ✅ やるべきこと

```bash
# 1. プロジェクトごとに仮想環境
cd my_project
python -m venv venv

# 2. requirements.txtを管理
pip freeze > requirements.txt

# 3. .gitignoreに追加
echo "venv/" >> .gitignore
echo "__pycache__/" >> .gitignore
echo "*.pyc" >> .gitignore

# 4. 定期的に更新
pip list --outdated
pip install --upgrade パッケージ名

# 5. 作業前に必ず有効化
venv\Scripts\activate
```

### ❌ やってはいけないこと

```bash
# ✗ システムPythonに直接インストール
pip install requests  # 仮想環境なしで

# ✗ 仮想環境をGitにコミット
git add venv/  # NG！

# ✗ 複数プロジェクトで1つの仮想環境を共有
# 各プロジェクト専用の環境を作る

# ✗ 仮想環境の名前を複雑にする
python -m venv my_super_long_venv_name_v2  # NG
# → シンプルに "venv" でOK
```

## 💾 requirements.txt の管理

```bash
# === 作成 ===
pip freeze > requirements.txt

# === 特定パッケージのみ ===
pip install pipreqs
pipreqs . --force
# → 実際にimportされているものだけ

# === バージョン固定 ===
# requirements.txt
requests==2.28.1      # 完全固定
pandas>=1.5.0         # 以上
numpy>=1.20,<2.0      # 範囲指定

# === インストール ===
pip install -r requirements.txt

# === 開発用と本番用を分ける ===
# requirements.txt        # 本番用
# requirements-dev.txt    # 開発用（テスト、Linterなど）

pip install -r requirements.txt
pip install -r requirements-dev.txt
```

## 🎯 まとめ：3つの黄金ルール

```
1. 必ず仮想環境を使う
   → python -m venv venv

2. 必ず有効化してから作業
   → venv\Scripts\activate

3. 必ず requirements.txt を管理
   → pip freeze > requirements.txt
```

## 🔗 困ったときのチェックリスト（コピペ用）

```bash
# 1. 現状確認
python --version
where python

# 2. 仮想環境確認
echo $VIRTUAL_ENV  # Mac/Linux
echo %VIRTUAL_ENV% # Windows

# 3. パッケージ確認
pip list

# 4. 緊急再作成
deactivate
rm -rf venv
python -m venv venv
source venv/bin/activate  # Mac/Linux
venv\Scripts\activate     # Windows
python -m pip install --upgrade pip
pip install -r requirements.txt

# 5. VSCode再設定
# Ctrl + Shift + P → Python: Select Interpreter
```

これで仮想環境のトラブルは完全解決！困ったときはこのガイドを見返してください 🎉
