# ==========================================================
# __init__.py 完全理解ガイド - 新人エンジニア向け
# ==========================================================

"""
【__init__.py とは？】

簡単に言うと：
  「このフォルダはパッケージですよ」とPythonに教えるための特別なファイル

正式名称：
  __init__.py (アンダースコア2つ + init + アンダースコア2つ + .py)
  読み方：「イニット・ドット・パイ」または「アンダーバー・アンダーバー・イニット」

役割：
  1. フォルダをPythonパッケージとして認識させる
  2. パッケージをインポートした時に最初に実行される
  3. パッケージの初期化処理を書ける
"""

# ==========================================================
# 【例1】__init__.py が無い場合 vs ある場合
# ==========================================================

print("=" * 70)
print("【例1】__init__.py の有無による違い")
print("=" * 70)

print("""
■ __init__.py が無い場合のフォルダ構成：
my_folder/
├── module1.py
└── module2.py

↓ この場合...
× import my_folder  # エラー！パッケージとして認識されない
× from my_folder import module1  # エラー！

-----------------------------------------------------------

■ __init__.py がある場合のフォルダ構成：
my_package/
├── __init__.py     # この1行があるだけでOK！（空でもいい）
├── module1.py
└── module2.py

↓ この場合...
○ import my_package  # OK！パッケージとして認識される
○ from my_package import module1  # OK！
""")

# ==========================================================
# 【例2】空の __init__.py（最もシンプル）
# ==========================================================

print("\n" + "=" * 70)
print("【例2】空の __init__.py - 最もシンプルな使い方")
print("=" * 70)

print("""
■ ファイル構成：
simple_package/
├── __init__.py     # 空のファイル（中身なし）
└── greetings.py

■ __init__.py の中身：
# 何も書かなくてOK！空のファイルでも効果あり

■ greetings.py の中身：
def hello():
    return "こんにちは！"

def goodbye():
    return "さようなら！"

■ 使い方：
from simple_package import greetings
print(greetings.hello())  # こんにちは！
""")

# ==========================================================
# 【例3】__init__.py で初期化処理を書く
# ==========================================================

print("\n" + "=" * 70)
print("【例3】__init__.py で初期化処理")
print("=" * 70)

print("""
■ ファイル構成：
config_package/
├── __init__.py
└── settings.py

■ __init__.py の中身：
-----------------------------------------------------------
# パッケージがインポートされた時に自動実行される！
print("config_packageを初期化中...")

# パッケージレベルの変数を定義
VERSION = "1.0.0"
APP_NAME = "マイアプリ"

# 初期化関数
def initialize():
    print(f"{APP_NAME} v{VERSION} を起動しました")
-----------------------------------------------------------

■ 使う時：
import config_package  # この時点で「config_packageを初期化中...」が表示される
print(config_package.VERSION)  # 1.0.0
config_package.initialize()
""")

# ==========================================================
# 【例4】__init__.py で便利な機能を提供
# ==========================================================

print("\n" + "=" * 70)
print("【例4】__init__.py で使いやすくする（重要！）")
print("=" * 70)

print("""
■ ファイル構成：
math_package/
├── __init__.py
├── basic.py        # 基本的な計算
└── advanced.py     # 高度な計算

■ basic.py の中身：
-----------------------------------------------------------
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b
-----------------------------------------------------------

■ advanced.py の中身：
-----------------------------------------------------------
def power(base, exp):
    return base ** exp

def sqrt(n):
    return n ** 0.5
-----------------------------------------------------------

■ __init__.py が無い場合：
-----------------------------------------------------------
# 使う側は長くて面倒...
from math_package.basic import add
from math_package.advanced import power

result1 = add(5, 3)
result2 = power(2, 3)
-----------------------------------------------------------

■ __init__.py がある場合：（こっちが便利！）
-----------------------------------------------------------
# __init__.py の中身：
from .basic import add, subtract       # . は「このパッケージ内」を意味
from .advanced import power, sqrt

# これで以下のように使える！
VERSION = "2.0.0"

# パッケージ全体の情報も提供
def get_info():
    return f"Math Package v{VERSION}"
-----------------------------------------------------------

# 使う側は超シンプル！
-----------------------------------------------------------
import math_package

result1 = math_package.add(5, 3)       # 短い！
result2 = math_package.power(2, 3)     # 短い！
print(math_package.get_info())
-----------------------------------------------------------
""")

# ==========================================================
# 【例5】__all__ で公開する機能を制限
# ==========================================================

print("\n" + "=" * 70)
print("【例5】__all__ で公開する機能を限定")
print("=" * 70)

print("""
■ ファイル構成：
api_package/
├── __init__.py
├── public_api.py
└── internal.py

■ __init__.py の中身：
-----------------------------------------------------------
from .public_api import get_data, send_data
from .internal import _helper_function  # _ で内部関数を示す

# from api_package import * で読み込まれるものを指定
__all__ = ['get_data', 'send_data']

# _helper_function は __all__ に含めないので、
# from api_package import * では読み込まれない
-----------------------------------------------------------

■ 使い方の違い：
-----------------------------------------------------------
# 方法1：from api_package import *
from api_package import *
get_data()    # OK！
send_data()   # OK！
_helper_function()  # エラー！__all__ に含まれていない

# 方法2：明示的にインポート
from api_package import _helper_function
_helper_function()  # OK！明示的ならアクセス可能
-----------------------------------------------------------
""")

# ==========================================================
# 【例6】実践的な __init__.py の例
# ==========================================================

print("\n" + "=" * 70)
print("【例6】実践的な __init__.py の完全な例")
print("=" * 70)

print("""
■ ファイル構成：
my_library/
├── __init__.py
├── utils.py
├── models.py
└── database.py

■ __init__.py の中身（実践例）：
-----------------------------------------------------------
'''
My Library - データ処理ライブラリ
便利な機能をまとめたパッケージです
'''

# パッケージのバージョン情報
__version__ = "1.2.3"
__author__ = "山田太郎"
__license__ = "MIT"

# パッケージがインポートされた時のメッセージ（開発時のみ）
import os
if os.getenv('DEBUG'):  # 環境変数DEBUGがある時だけ表示
    print(f"my_library v{__version__} をロードしました")

# サブモジュールから便利な機能をインポート
from .utils import format_text, parse_data
from .models import User, Product
from .database import connect, disconnect

# 公開するAPIを明示
__all__ = [
    'format_text',
    'parse_data', 
    'User',
    'Product',
    'connect',
    'disconnect',
    'get_version'
]

# パッケージレベルのユーティリティ関数
def get_version():
    '''バージョン情報を返す'''
    return f"v{__version__} by {__author__}"

# パッケージレベルの定数
DEFAULT_TIMEOUT = 30
MAX_RETRY = 3
-----------------------------------------------------------

■ 使う側のコード：
-----------------------------------------------------------
import my_library

# パッケージの情報を取得
print(my_library.get_version())  # v1.2.3 by 山田太郎

# 簡潔に使える
user = my_library.User("田中", 25)
data = my_library.format_text("hello")

# 定数も使える
timeout = my_library.DEFAULT_TIMEOUT
-----------------------------------------------------------
""")

# ==========================================================
# 【例7】階層的なパッケージ
# ==========================================================

print("\n" + "=" * 70)
print("【例7】階層的なパッケージ（入れ子構造）")
print("=" * 70)

print("""
■ ファイル構成：
web_framework/
├── __init__.py          # トップレベル
├── http/
│   ├── __init__.py     # httpパッケージ
│   ├── request.py
│   └── response.py
└── database/
    ├── __init__.py     # databaseパッケージ
    ├── mysql.py
    └── postgres.py

■ web_framework/__init__.py の中身：
-----------------------------------------------------------
from . import http        # httpサブパッケージをインポート
from . import database    # databaseサブパッケージをインポート

__version__ = "3.0.0"
-----------------------------------------------------------

■ web_framework/http/__init__.py の中身：
-----------------------------------------------------------
from .request import Request
from .response import Response

__all__ = ['Request', 'Response']
-----------------------------------------------------------

■ 使う側のコード：
-----------------------------------------------------------
# 方法1：階層を辿る
from web_framework.http import Request
from web_framework.database import mysql

# 方法2：トップレベルからアクセス
import web_framework
req = web_framework.http.Request()
-----------------------------------------------------------
""")

# ==========================================================
# 【まとめ】__init__.py のポイント
# ==========================================================

print("\n" + "=" * 70)
print("【まとめ】__init__.py の重要ポイント")
print("=" * 70)

summary = """
✅ 1. 役割
   - フォルダをパッケージとして認識させる目印
   - 空でもOK（存在するだけで効果あり）
   
✅ 2. 実行タイミング
   - パッケージが最初にインポートされた時に1回だけ実行される
   
✅ 3. よくある使い方
   ① 空のファイル → 単にパッケージとして認識させるだけ
   ② 初期化処理 → バージョン情報、設定の読み込みなど
   ③ インポートの簡略化 → サブモジュールの機能を使いやすくする
   ④ 公開APIの制限 → __all__ で外部に見せる機能を限定
   
✅ 4. ベストプラクティス
   - 基本は簡潔に（長くしない）
   - パッケージの「顔」として使う
   - 使う側が楽になるような構成にする
   
✅ 5. Python 3.3以降の注意
   - 実は無くてもパッケージとして動く場合がある
   - でも明示的に置くのが推奨！（分かりやすいため）
"""

print(summary)

# ==========================================================
# 【実践演習】実際に試してみよう！
# ==========================================================

print("\n" + "=" * 70)
print("【実践演習】実際に作ってみよう！")
print("=" * 70)

print("""
以下の手順で試してみてください：

1. フォルダを作成
   my_first_package/ というフォルダを作る

2. __init__.py を作成
   my_first_package/__init__.py を作って以下を記述：
   
   -----------------------------------------------------------
   print("パッケージが読み込まれました！")
   
   MESSAGE = "Hello from package!"
   
   def greet(name):
       return f"こんにちは、{name}さん！"
   -----------------------------------------------------------

3. 別のファイルから使ってみる
   main.py を作って以下を実行：
   
   -----------------------------------------------------------
   import my_first_package
   
   print(my_first_package.MESSAGE)
   print(my_first_package.greet("太郎"))
   -----------------------------------------------------------

4. 実行
   python main.py
   
   結果：
   パッケージが読み込まれました！
   Hello from package!
   こんにちは、太郎さん！
""")

print("\n" + "=" * 70)
print("これで __init__.py の理解は完璧！")
print("=" * 70)
