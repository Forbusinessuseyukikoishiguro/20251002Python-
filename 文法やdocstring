# 🐰 Python先生の実践コード解説
**新人エンジニア向け！コメント・docstringの書き方を一行ずつ丁寧に**

---

## 📚 この記事で学べること

1. **コメントとdocstringの違い**
2. **一行ずつのコメントの書き方**
3. **実践的なコツ**
4. **よくある間違いと正しい例**

---

## 1. コメントとdocstringの違い

### 📖 基本ルール

```python
# これは「コメント」 → コードの「なぜ」を説明
def calculate_price():
    """これは「docstring」 → 関数の「何をするか」を説明"""
    pass
```

| 種類 | 記号 | 目的 | 誰が読む？ |
|------|------|------|-----------|
| **コメント** | `#` | コードの意図・理由を説明 | コードを読む人 |
| **docstring** | `"""` | 関数・クラスの使い方を説明 | APIを使う人 |

---

## 2. 実践！一行ずつコメントを書いてみよう

### 🐰 例題：ふわふわ大福店のレジシステム

#### ❌ 悪い例（コメントなし）

```python
from typing import Optional

class DaifukuShop:
    def __init__(self, owner_name: str, stock: int) -> None:
        if stock < 0:
            raise ValueError("在庫数は0以上にしてください")
        self.owner_name = owner_name
        self.stock = stock
        self.sold = 0
        self.revenue = 0
    
    def sell(self, quantity: int, price: int = 150, discount: float = 0) -> Optional[int]:
        if quantity <= 0:
            raise ValueError("個数は1以上にしてください")
        if quantity > self.stock:
            return None
        total = int(quantity * price * (1 - discount))
        self.stock -= quantity
        self.sold += quantity
        self.revenue += total
        return total
```

**問題点：**
- 何をしているかわからない
- なぜその処理をしているか不明
- 数値の意味が不明

---

#### ✅ 良い例（適切なコメント + docstring）

```python
from typing import Optional

class DaifukuShop:
    """
    大福店の在庫・販売管理クラス
    
    Args:
        owner_name: 店長の名前
        stock: 初期在庫数
    
    Attributes:
        owner_name: 店長の名前
        stock: 現在の在庫数
        sold: 累計販売数
        revenue: 累計売上金額
    """
    
    def __init__(self, owner_name: str, stock: int) -> None:
        """
        大福店を初期化する
        
        Args:
            owner_name: 店長の名前
            stock: 初期在庫数（0以上）
        
        Raises:
            ValueError: stockが負の数の場合
        """
        # バリデーション: 在庫数は負にできない
        if stock < 0:
            raise ValueError("在庫数は0以上にしてください")
        
        # インスタンス変数の初期化
        self.owner_name = owner_name  # 店長名を保存
        self.stock = stock            # 現在の在庫数
        self.sold = 0                 # 累計販売数（初期値0）
        self.revenue = 0              # 累計売上（初期値0円）
    
    def sell(
        self,
        quantity: int,
        price: int = 150,      # デフォルト単価: 150円
        discount: float = 0    # デフォルト割引率: 0%
    ) -> Optional[int]:
        """
        大福を販売して売上を計算する
        
        Args:
            quantity: 販売個数
            price: 単価（円）。デフォルトは150円
            discount: 割引率（0.0-1.0）。デフォルトは0
        
        Returns:
            売上金額（円）。在庫不足の場合はNone
        
        Raises:
            ValueError: quantityが0以下の場合
        
        Example:
            >>> shop = DaifukuShop("うさうさ", 20)
            >>> shop.sell(5)
            750
            >>> shop.sell(3, discount=0.1)  # 10%割引
            405
        """
        # バリデーション: 販売個数は1以上必須
        if quantity <= 0:
            raise ValueError("個数は1以上にしてください")
        
        # 在庫チェック: 足りない場合は販売不可
        if quantity > self.stock:
            return None  # Noneを返して在庫不足を通知
        
        # 売上計算: 単価 × 個数 × (1 - 割引率)
        # int()で小数点以下切り捨て
        total = int(quantity * price * (1 - discount))
        
        # 在庫と販売数を更新
        self.stock -= quantity    # 在庫を減らす
        self.sold += quantity     # 累計販売数を増やす
        self.revenue += total     # 累計売上に加算
        
        # 売上金額を返す
        return total
```

---

## 3. コメントを書く5つのコツ

### 💡 コツ1: 「何を」ではなく「なぜ」を書く

#### ❌ 悪い例

```python
# iに1を足す
i = i + 1

# stockが10より大きいかチェック
if stock > 10:
    # discountを0.1にする
    discount = 0.1
```

**問題:** コードを見ればわかることを書いている

#### ✅ 良い例

```python
# カウンターをインクリメント（ループの次の要素へ）
i = i + 1

# 大量購入割引: 11個以上で10%オフ
if stock > 10:
    discount = 0.1  # 10%割引を適用
```

**ポイント:** なぜその処理が必要か、ビジネスロジックを説明

---

### 💡 コツ2: マジックナンバーには必ずコメント

#### ❌ 悪い例

```python
if age >= 20:
    can_buy = True

total = price * 1.1

if score > 80:
    grade = "A"
```

**問題:** 数値の意味が不明

#### ✅ 良い例

```python
LEGAL_AGE = 20  # 成人年齢（日本）
if age >= LEGAL_AGE:
    can_buy = True

TAX_RATE = 1.1  # 消費税10%
total = price * TAX_RATE

A_GRADE_THRESHOLD = 80  # A評価のボーダーライン
if score > A_GRADE_THRESHOLD:
    grade = "A"
```

**ポイント:** 定数化 + コメントで意味を明確に

---

### 💡 コツ3: 複雑なロジックは段階的にコメント

#### ❌ 悪い例

```python
def calculate_shipping_fee(items, weight, distance):
    if len(items) > 10 and weight < 5000:
        base = 500
    elif distance > 100:
        base = 1000 + (distance - 100) * 10
    else:
        base = 800
    
    if weight > 3000:
        base += (weight - 3000) // 1000 * 200
    
    return base
```

**問題:** ロジックが複雑で追いづらい

#### ✅ 良い例

```python
def calculate_shipping_fee(items: list, weight: int, distance: int) -> int:
    """
    配送料を計算する
    
    Args:
        items: 商品リスト
        weight: 総重量（グラム）
        distance: 配送距離（km）
    
    Returns:
        配送料（円）
    """
    # ステップ1: 基本料金を決定
    if len(items) > 10 and weight < 5000:
        # 大量注文 & 軽量 → 割引適用
        base = 500
    elif distance > 100:
        # 遠距離配送 → 距離に応じた追加料金
        base = 1000 + (distance - 100) * 10  # 100km超過分は1kmあたり10円
    else:
        # 通常配送
        base = 800
    
    # ステップ2: 重量による追加料金
    HEAVY_THRESHOLD = 3000  # 3kg以上は追加料金
    if weight > HEAVY_THRESHOLD:
        # 3kgを超える1kgごとに200円追加
        extra_weight = weight - HEAVY_THRESHOLD
        base += (extra_weight // 1000) * 200
    
    return base
```

**ポイント:** 
- ステップごとにコメント
- 定数を使って計算式を説明
- 条件の意味を明記

---

### 💡 コツ4: TODOとFIXMEを使い分ける

```python
class DaifukuShop:
    def sell(self, quantity: int) -> Optional[int]:
        """大福を販売する"""
        
        # TODO: ポイント還元機能を追加予定（2025年4月リリース）
        # 購入金額の1%をポイントとして付与
        
        # FIXME: 在庫が0の時のエラーメッセージが不親切
        # 「在庫なし」だけでなく、次回入荷日も表示したい
        if quantity > self.stock:
            return None
        
        # HACK: 暫定対応。本来はDBから取得すべき
        # チケット #1234 で対応予定
        price = 150
        
        # NOTE: この計算式は経理部門と合意済み（2024/12/01）
        total = quantity * price
        
        return total
```

**コメントタグの使い分け:**

| タグ | 意味 | 使う場面 |
|------|------|---------|
| `TODO` | やるべきこと | 将来実装する機能 |
| `FIXME` | 修正が必要 | 既知のバグや改善点 |
| `HACK` | 暫定対応 | 本来の実装ではない |
| `NOTE` | 重要な注意 | 特別な理由や背景 |
| `XXX` | 危険・注意 | 特に注意が必要な箇所 |

---

### 💡 コツ5: 関数・クラスには必ずdocstring

#### ✅ 完璧な例

```python
from typing import Optional, List, Dict

class DaifukuShop:
    """
    大福専門店の在庫・販売管理システム
    
    このクラスは大福の在庫管理、販売処理、売上集計を行います。
    
    Attributes:
        owner_name: 店長の名前
        stock: 現在の在庫数
        sold: 累計販売数
        revenue: 累計売上金額（円）
    
    Example:
        >>> shop = DaifukuShop("うさうさ", 20)
        >>> shop.sell(5)
        750
        >>> shop.get_stats()
        {'owner': 'うさうさ', 'stock': 15, 'sold': 5, 'revenue': 750}
    """
    
    # クラス定数: 全店舗共通の設定
    DEFAULT_PRICE = 150      # デフォルト単価（円）
    TAX_RATE = 1.1          # 消費税率
    BULK_DISCOUNT = 0.1     # 大量購入割引率（10%）
    
    def __init__(self, owner_name: str, stock: int) -> None:
        """
        大福店を初期化する
        
        Args:
            owner_name: 店長の名前
            stock: 初期在庫数（0以上の整数）
        
        Raises:
            ValueError: stockが負の数の場合
        
        Example:
            >>> shop = DaifukuShop("うさうさ", 20)
        """
        # バリデーション
        if stock < 0:
            raise ValueError("在庫数は0以上にしてください")
        
        # 初期化
        self.owner_name = owner_name
        self.stock = stock
        self.sold = 0
        self.revenue = 0
    
    def sell(
        self,
        quantity: int,
        price: int = DEFAULT_PRICE,
        discount: float = 0
    ) -> Optional[int]:
        """
        大福を販売して売上を計算する
        
        在庫から指定個数を減らし、売上を計算します。
        在庫不足の場合は販売せずNoneを返します。
        
        Args:
            quantity: 販売個数（1以上）
            price: 単価（円）。省略時はDEFAULT_PRICE
            discount: 割引率（0.0-1.0）。0で割引なし
        
        Returns:
            売上金額（円）。在庫不足の場合はNone
        
        Raises:
            ValueError: quantityが0以下の場合
        
        Example:
            >>> shop = DaifukuShop("うさうさ", 20)
            >>> shop.sell(5)
            750
            >>> shop.sell(10, discount=0.1)  # 10%割引
            1350
            >>> shop.sell(100)  # 在庫不足
            None
        
        Note:
            - 在庫不足の場合、在庫数は変更されません
            - 割引後の金額は小数点以下切り捨て
        """
        # ステップ1: バリデーション
        if quantity <= 0:
            raise ValueError("個数は1以上にしてください")
        
        # ステップ2: 在庫チェック
        if quantity > self.stock:
            # 在庫不足: 何も変更せずNoneを返す
            return None
        
        # ステップ3: 売上計算
        # 計算式: 個数 × 単価 × (1 - 割引率)
        total = int(quantity * price * (1 - discount))
        
        # ステップ4: 在庫と売上を更新
        self.stock -= quantity     # 在庫を減らす
        self.sold += quantity      # 累計販売数を増やす
        self.revenue += total      # 累計売上に加算
        
        # ステップ5: 売上金額を返す
        return total
    
    def restock(self, quantity: int) -> None:
        """
        在庫を補充する
        
        Args:
            quantity: 補充個数（1以上）
        
        Raises:
            ValueError: quantityが0以下の場合
        
        Example:
            >>> shop = DaifukuShop("うさうさ", 10)
            >>> shop.restock(20)
            >>> shop.stock
            30
        """
        if quantity <= 0:
            raise ValueError("補充個数は1以上にしてください")
        
        # 在庫に加算
        self.stock += quantity
    
    def get_stats(self) -> Dict[str, any]:
        """
        店舗の統計情報を取得する
        
        Returns:
            以下のキーを持つ辞書:
                - owner: 店長名
                - stock: 現在の在庫数
                - sold: 累計販売数
                - revenue: 累計売上（円）
        
        Example:
            >>> shop = DaifukuShop("うさうさ", 20)
            >>> shop.sell(5)
            750
            >>> shop.get_stats()
            {'owner': 'うさうさ', 'stock': 15, 'sold': 5, 'revenue': 750}
        """
        return {
            'owner': self.owner_name,
            'stock': self.stock,
            'sold': self.sold,
            'revenue': self.revenue
        }
    
    def apply_bulk_discount(self, quantity: int) -> float:
        """
        大量購入割引を適用すべきか判定する
        
        10個以上の購入で10%割引を適用します。
        
        Args:
            quantity: 購入個数
        
        Returns:
            適用する割引率（0.0-1.0）
        
        Example:
            >>> shop = DaifukuShop("うさうさ", 20)
            >>> shop.apply_bulk_discount(5)
            0.0
            >>> shop.apply_bulk_discount(15)
            0.1
        """
        # 大量購入の閾値
        BULK_THRESHOLD = 10
        
        # 10個以上で割引適用
        if quantity >= BULK_THRESHOLD:
            return self.BULK_DISCOUNT
        else:
            return 0.0
```

---

## 4. よくある間違いと正しい書き方

### ❌ 間違い1: コメントアウトしたコードを残す

```python
def calculate_total(quantity: int, price: int) -> int:
    # 古い計算方法（削除予定）
    # total = quantity * price
    # tax = total * 0.08
    # return total + tax
    
    # 新しい計算方法
    return int(quantity * price * 1.1)
```

**問題:** コードが読みにくくなる

#### ✅ 正しい書き方

```python
def calculate_total(quantity: int, price: int) -> int:
    """
    合計金額を計算する（消費税10%込み）
    
    Note:
        2024年10月から消費税率を8%→10%に変更
    """
    TAX_RATE = 1.1  # 消費税10%
    return int(quantity * price * TAX_RATE)
```

**ポイント:** 
- 古いコードは削除
- 変更理由はdocstringに記載
- Git履歴で過去のコードは確認可能

---

### ❌ 間違い2: 冗長なコメント

```python
# DaifukuShopクラスを定義
class DaifukuShop:
    # __init__メソッドを定義
    def __init__(self, owner_name, stock):
        # owner_nameをself.owner_nameに代入
        self.owner_name = owner_name
        # stockをself.stockに代入
        self.stock = stock
```

**問題:** コードを見ればわかることを書いている

#### ✅ 正しい書き方

```python
class DaifukuShop:
    """大福店の在庫・販売管理クラス"""
    
    def __init__(self, owner_name: str, stock: int) -> None:
        """
        店舗を初期化する
        
        Args:
            owner_name: 店長の名前
            stock: 初期在庫数
        """
        self.owner_name = owner_name
        self.stock = stock
```

**ポイント:** コメントではなくdocstringで「何をするか」を説明

---

### ❌ 間違い3: コメントが古くなっている

```python
def sell(self, quantity: int) -> Optional[int]:
    # 在庫から引く（2023年版）
    # 割引は適用しない
    self.stock -= quantity
    
    # 2024年追加: 割引機能
    discount = 0.1
    total = int(quantity * 150 * (1 - discount))
    
    return total
```

**問題:** コメントとコードが一致していない

#### ✅ 正しい書き方

```python
def sell(self, quantity: int, discount: float = 0.1) -> Optional[int]:
    """
    大福を販売する（割引適用版）
    
    Args:
        quantity: 販売個数
        discount: 割引率。デフォルトは0.1（10%オフ）
    
    Returns:
        売上金額（割引後）
    
    Note:
        2024年4月より全商品10%割引キャンペーン実施中
    """
    # 在庫を減らす
    self.stock -= quantity
    
    # 割引後の売上を計算
    DEFAULT_PRICE = 150
    total = int(quantity * DEFAULT_PRICE * (1 - discount))
    
    return total
```

**ポイント:** コードを変更したらコメントも必ず更新

---

## 5. 実践チェックリスト

### ✅ コメントを書く前にチェック

```
【必須】
□ docstringは書いたか？
□ マジックナンバーに定数名をつけたか？
□ 複雑なロジックに段階的コメントをつけたか？
□ TODOやFIXMEで課題を記録したか？

【禁止】
□ コードと同じことを書いていないか？
□ 古いコメントアウトを残していないか？
□ コメントとコードが矛盾していないか？

【推奨】
□ 「なぜ」を書いているか？（「何を」ではなく）
□ ビジネスロジックを説明しているか？
□ 将来の自分が読んでわかるか？
```

---

## 6. 練習問題

### 問題1: このコードにコメントとdocstringを追加してください

```python
def calculate_point(price, is_member):
    if is_member:
        if price >= 10000:
            return int(price * 0.05)
        else:
            return int(price * 0.03)
    else:
        return int(price * 0.01)
```

<details>
<summary>解答例を見る</summary>

```python
def calculate_point(price: int, is_member: bool) -> int:
    """
    購入金額に応じたポイントを計算する
    
    会員ステータスと購入金額に応じて、以下のポイント還元率を適用:
    - 会員 & 10,000円以上: 5%
    - 会員 & 10,000円未満: 3%
    - 非会員: 1%
    
    Args:
        price: 購入金額（円）
        is_member: 会員かどうか
    
    Returns:
        付与ポイント数（小数点以下切り捨て）
    
    Example:
        >>> calculate_point(15000, True)   # 会員・高額
        750
        >>> calculate_point(5000, True)    # 会員・通常
        150
        >>> calculate_point(5000, False)   # 非会員
        50
    """
    # ポイント還元率の定数定義
    PREMIUM_RATE = 0.05      # 会員・高額購入: 5%
    MEMBER_RATE = 0.03       # 会員・通常購入: 3%
    GUEST_RATE = 0.01        # 非会員: 1%
    HIGH_PRICE_THRESHOLD = 10000  # 高額購入の基準額
    
    if is_member:
        # 会員の場合: 購入金額で還元率を変える
        if price >= HIGH_PRICE_THRESHOLD:
            # 高額購入 → 5%還元
            return int(price * PREMIUM_RATE)
        else:
            # 通常購入 → 3%還元
            return int(price * MEMBER_RATE)
    else:
        # 非会員 → 1%還元
        return int(price * GUEST_RATE)
```

</details>

---

## 7. まとめ

### 🎯 新人エンジニアが覚えるべき5つのポイント

1. **docstringは必ず書く**
   - 関数・クラスの「何をするか」を説明
   - Googleスタイル + 型ヒントが推奨

2. **コメントは「なぜ」を書く**
   - 「何を」はコードを見ればわかる
   - ビジネスロジックや意図を説明

3. **マジックナンバーは定数化**
   - 数値の意味を名前で表現
   - コメントで補足説明

4. **TODO・FIXMEを活用**
   - 課題を明確に記録
   - チーム全体で共有

5. **コメントも保守する**
   - コード変更時はコメントも更新
   - 古いコメントは削除

### 📝 今日から実践！

```python
# ✅ 今日から使えるテンプレート
def your_function(arg1: type, arg2: type = default) -> return_type:
    """
    1行で関数の目的を説明
    
    詳しい説明（必要に応じて）
    
    Args:
        arg1: 引数の説明
        arg2: 引数の説明。デフォルトは〇〇
    
    Returns:
        返り値の説明
    
    Raises:
        ExceptionType: 例外が発生する条件
    
    Example:
        >>> your_function(1, 2)
        3
    """
    # ステップ1: バリデーション
    # ...
    
    # ステップ2: メイン処理
    # ...
    
    # ステップ3: 結果を返す
    return result
```

**🐰 うさうさ店長より:**

「コメントは将来の自分へのラブレターです！

3ヶ月後に自分のコードを見て
『これ何してるんだっけ？』
とならないように、今のうちに丁寧に書きましょう！

最初は時間がかかりますが、
慣れれば自然に書けるようになります。

頑張ってください！」


ーーーーーーーーーーーーーーーーーーーーーーー
キーワードやクリエイターで検索


703
メニュー
 投稿

あなただけに表示されています
見出し画像を設定してみませんか?
見出し画像があると、もっと作品のイメージが伝わります！
かんたんにオリジナル画像を作ったり、他のクリエイターが提供した画像から選んだりすることもできます。
ぜひ活用してみましょう！


🐰 Pythonの文法注意事項完全ガイド新人エンジニアが絶対におさえるべき！つまずきポイント徹底解説

YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
2025年10月4日 16:16

🐰 Pythonの文法注意事項完全ガイド
新人エンジニアが絶対におさえるべき！つまずきポイント徹底解説



目次
🐰 Pythonの文法注意事項完全ガイド
1. インデント（字下げ）の罠
📖 Pythonの最大の特徴
❌ 間違い例
✅ 正しい例
🎯 インデントのルール
2. 可変オブジェクトと不変オブジェクト
📖 Pythonの重要な概念
📋 オブジェクトの分類
❌ よくある勘違い

すべて表示
1. インデント（字下げ）の罠
📖 Pythonの最大の特徴
Pythonはインデント（字下げ）でブロックを表現します。 他の言語の {} の代わりです。

❌ 間違い例
# ❌ インデントがバラバラ（エラー！）
def calculate_total(items):
    total = 0
    for item in items:
      total += item  # ← 2スペース
        print(total)   # ← 4スペース（エラー！）
    return total

# IndentationError: unexpected indent

copy
# ❌ インデントを忘れた
def greet(name):
print(f"こんにちは、{name}さん")  # ← インデントなし（エラー！）

# IndentationError: expected an indented block

copy
# ❌ タブとスペースが混在（見た目は同じでもエラー）
def sell(quantity):
    price = 150        # ← スペース4つ
	total = price * quantity  # ← タブ（エラー！）
    return total

# TabError: inconsistent use of tabs and spaces in indentation

copy
✅ 正しい例
# ✅ インデントは4スペースで統一（Python推奨）
def calculate_total(items):
    """合計を計算する"""
    total = 0
    for item in items:
        total += item      # ← 4スペース
        print(total)       # ← 4スペース
    return total


# ✅ ネストしたブロックはさらに4スペース
def sell_daifuku(quantity, stock):
    """大福を販売する"""
    if quantity > 0:                    # ← 4スペース
        if quantity <= stock:           # ← 8スペース（ネスト）
            price = 150
            total = quantity * price    # ← 12スペース（さらにネスト）
            return total
        else:
            return None                 # ← 12スペース
    else:
        raise ValueError("個数は1以上")  # ← 8スペース

copy
🎯 インデントのルール
# ルール1: 1階層 = 4スペース（推奨）
def function():
    pass  # ← 4スペース


# ルール2: タブは使わない（スペースのみ）
# エディタの設定で「タブをスペースに変換」をONに


# ルール3: 同じブロック内は同じインデント
if condition:
    action1()  # ← 4スペース
    action2()  # ← 4スペース（同じ深さ）


# ルール4: ネストするごとに+4スペース
if condition1:              # ← 0スペース
    if condition2:          # ← 4スペース
        if condition3:      # ← 8スペース
            action()        # ← 12スペース

copy
2. 可変オブジェクトと不変オブジェクト
📖 Pythonの重要な概念
Pythonのオブジェクトには変更できるものと変更できないものがあります。

📋 オブジェクトの分類
不変オブジェクト（Immutable） 可変オブジェクト（Mutable） int（整数） list（リスト） float（小数） dict（辞書） str（文字列） set（集合） tuple（タプル） カスタムクラス bool（真偽値）

❌ よくある勘違い
# ❌ 文字列は変更できると思っている
name = "うさうさ"
name[0] = "く"  # ← エラー！文字列は不変
# TypeError: 'str' object does not support item assignment


# ❌ 数値も変更できると思っている
x = 5
x += 1  # ← xは「変更」されてない。新しいオブジェクトが作られている


# ❌ タプルは変更できると思っている
point = (10, 20)
point[0] = 15  # ← エラー！タプルは不変
# TypeError: 'tuple' object does not support item assignment

copy
✅ 正しい理解
# ✅ 不変オブジェクトの例
# 文字列：変更したければ新しい文字列を作る
name = "うさうさ"
new_name = "く" + name[1:]  # ← 新しい文字列を作成
print(new_name)  # くさうさ


# ✅ 数値：再代入は新しいオブジェクトを作っている
x = 5
print(id(x))  # 例: 140703348355680（メモリアドレス）

x = x + 1  # ← 新しいオブジェクト6を作ってxに代入
print(id(x))  # 例: 140703348355712（違うアドレス！）


# ✅ 可変オブジェクトの例
# リスト：要素を直接変更できる
items = [1, 2, 3]
print(id(items))  # 例: 2234567890

items[0] = 10  # ← 同じリストの中身を変更
print(id(items))  # 例: 2234567890（同じアドレス！）
print(items)  # [10, 2, 3]


# ✅ 辞書：キーと値を追加・変更できる
shop_data = {'owner': 'うさうさ', 'stock': 20}
shop_data['sold'] = 5  # ← キーを追加
shop_data['stock'] = 15  # ← 値を変更

copy
🎯 なぜ重要か？
# 不変オブジェクト：代入しても元の値は変わらない
a = "hello"
b = a
b = "world"  # ← bだけ変わる
print(a)  # hello（aは変わらない）
print(b)  # world


# 可変オブジェクト：代入すると参照が共有される
list1 = [1, 2, 3]
list2 = list1  # ← 同じリストを参照
list2[0] = 999  # ← list2を変更

print(list1)  # [999, 2, 3] ← list1も変わる！
print(list2)  # [999, 2, 3]

# これを避けるには.copy()を使う
list3 = [1, 2, 3]
list4 = list3.copy()  # ← コピーを作成
list4[0] = 999

print(list3)  # [1, 2, 3] ← 変わらない
print(list4)  # [999, 2, 3]

copy
3. リストの参照とコピー
📖 新人エンジニアが最もハマる罠
❌ 危険な例
# ❌ リストのコピーのつもりが参照になっている
original = [1, 2, 3]
copy = original  # ← これはコピーじゃない！参照！

copy.append(4)  # ← copyに4を追加

print(original)  # [1, 2, 3, 4] ← 元のリストも変わる！
print(copy)      # [1, 2, 3, 4]


# ❌ 関数内でリストを変更すると元のリストも変わる
def add_item(items):
    """アイテムを追加する（危険な例）"""
    items.append(999)  # ← 元のリストを変更してしまう
    return items

my_list = [1, 2, 3]
result = add_item(my_list)

print(my_list)  # [1, 2, 3, 999] ← 元のリストが変わった！
print(result)   # [1, 2, 3, 999]


# ❌ 2次元リストのコピー（浅いコピーの罠）
matrix1 = [[1, 2], [3, 4]]
matrix2 = matrix1.copy()  # ← これは浅いコピー

matrix2[0][0] = 999  # ← 内側のリストを変更

print(matrix1)  # [[999, 2], [3, 4]] ← 元も変わる！
print(matrix2)  # [[999, 2], [3, 4]]

copy
✅ 正しいコピー方法
import copy

# ✅ 方法1: .copy()メソッド（浅いコピー）
original = [1, 2, 3]
shallow_copy = original.copy()
shallow_copy.append(4)

print(original)      # [1, 2, 3] ← 変わらない
print(shallow_copy)  # [1, 2, 3, 4]


# ✅ 方法2: list()コンストラクタ
original = [1, 2, 3]
shallow_copy = list(original)


# ✅ 方法3: スライス記法
original = [1, 2, 3]
shallow_copy = original[:]


# ✅ 方法4: 深いコピー（2次元リストなど）
matrix1 = [[1, 2], [3, 4]]
matrix2 = copy.deepcopy(matrix1)  # ← 深いコピー

matrix2[0][0] = 999

print(matrix1)  # [[1, 2], [3, 4]] ← 変わらない！
print(matrix2)  # [[999, 2], [3, 4]]


# ✅ 関数内で元のリストを変更しない
def add_item_safe(items):
    """アイテムを追加する（安全な例）"""
    new_items = items.copy()  # ← コピーを作る
    new_items.append(999)
    return new_items

my_list = [1, 2, 3]
result = add_item_safe(my_list)

print(my_list)  # [1, 2, 3] ← 変わらない
print(result)   # [1, 2, 3, 999]

copy
🎯 参照とコピーの見分け方
# 参照かコピーかを確認する方法

list1 = [1, 2, 3]
list2 = list1        # 参照
list3 = list1.copy()  # コピー

# id()で確認
print(id(list1))  # 例: 140703348355680
print(id(list2))  # 例: 140703348355680（同じ！参照）
print(id(list3))  # 例: 140703348355712（違う！コピー）

# is演算子で確認
print(list1 is list2)  # True（同じオブジェクト）
print(list1 is list3)  # False（別のオブジェクト）

copy
4. デフォルト引数の罠
📖 中級者でもハマる罠
❌ 危険な例（最も有名なバグ）
# ❌ デフォルト引数にリストを使う（超危険！）
def add_item(item, items=[]):  # ← これが罠！
    """アイテムをリストに追加する（危険な例）"""
    items.append(item)
    return items

# 1回目の呼び出し
result1 = add_item("大福")
print(result1)  # ['大福']

# 2回目の呼び出し
result2 = add_item("どら焼き")
print(result2)  # ['大福', 'どら焼き'] ← え！？

# 3回目の呼び出し
result3 = add_item("たい焼き")
print(result3)  # ['大福', 'どら焼き', 'たい焼き'] ← なんで！？


# ❌ 同様に辞書も危険
def create_shop(name, data={}):  # ← 危険！
    """店舗を作成する（危険な例）"""
    data['name'] = name
    return data

shop1 = create_shop("うさうさ店")
shop2 = create_shop("もちもち店")

print(shop1)  # {'name': 'もちもち店'} ← 上書きされた！
print(shop2)  # {'name': 'もちもち店'}

copy
✅ 正しい書き方
# ✅ デフォルト引数にNoneを使う
def add_item(item, items=None):
    """アイテムをリストに追加する（正しい例）"""
    if items is None:
        items = []  # ← 関数が呼ばれるたびに新しいリスト
    items.append(item)
    return items

# 1回目の呼び出し
result1 = add_item("大福")
print(result1)  # ['大福']

# 2回目の呼び出し
result2 = add_item("どら焼き")
print(result2)  # ['どら焼き'] ← 正しい！

# 3回目の呼び出し
result3 = add_item("たい焼き")
print(result3)  # ['たい焼き'] ← 正しい！


# ✅ 辞書も同様
def create_shop(name, data=None):
    """店舗を作成する（正しい例）"""
    if data is None:
        data = {}  # ← 関数が呼ばれるたびに新しい辞書
    data['name'] = name
    return data

shop1 = create_shop("うさうさ店")
shop2 = create_shop("もちもち店")

print(shop1)  # {'name': 'うさうさ店'} ← 正しい！
print(shop2)  # {'name': 'もちもち店'} ← 正しい！


# ✅ 不変オブジェクトならOK
def greet(name, greeting="こんにちは"):
    """挨拶する（文字列はOK）"""
    return f"{greeting}、{name}さん"

print(greet("うさうさ"))           # こんにちは、うさうささん
print(greet("もちもち", "おはよう"))  # おはよう、もちもちさん


# ✅ 数値もOK
def calculate(x, multiplier=2):
    """計算する（数値はOK）"""
    return x * multiplier

print(calculate(5))     # 10
print(calculate(5, 3))  # 15

copy
🎯 なぜこうなるのか？
# デフォルト引数は関数定義時に1回だけ評価される
def bad_function(items=[]):
    # このリストは関数定義時に1回だけ作られる
    # すべての呼び出しで同じリストを使い回す
    items.append(1)
    return items

# 確認してみる
result1 = bad_function()
result2 = bad_function()
result3 = bad_function()

print(result1)  # [1, 1, 1]
print(result2)  # [1, 1, 1]
print(result3)  # [1, 1, 1]

# すべて同じオブジェクト！
print(result1 is result2)  # True
print(result2 is result3)  # True

copy
5. スコープ（変数の有効範囲）
📖 変数はどこから見えるか？
❌ よくある間違い
# ❌ グローバル変数を関数内で変更しようとする
count = 0

def increment():
    count = count + 1  # ← エラー！
    return count

increment()
# UnboundLocalError: local variable 'count' referenced before assignment


# ❌ ローカル変数とグローバル変数の混同
stock = 100  # グローバル変数

def sell(quantity):
    stock = stock - quantity  # ← エラー！
    return stock

sell(5)
# UnboundLocalError: local variable 'stock' referenced before assignment

copy
✅ 正しい書き方
# ✅ 方法1: globalキーワードを使う（非推奨）
count = 0

def increment():
    global count  # ← グローバル変数を使うと宣言
    count = count + 1
    return count

increment()
print(count)  # 1


# ✅ 方法2: 引数と返り値を使う（推奨）
count = 0

def increment(value):
    """値を1増やす（推奨）"""
    return value + 1

count = increment(count)
print(count)  # 1


# ✅ 方法3: クラスを使う（最推奨）
class Counter:
    """カウンタークラス"""
    
    def __init__(self):
        self.count = 0  # インスタンス変数
    
    def increment(self):
        """カウントを1増やす"""
        self.count += 1
        return self.count

counter = Counter()
counter.increment()
print(counter.count)  # 1

copy
🎯 スコープの種類（LEGB規則）
# L: Local（ローカル）- 関数内
# E: Enclosing（エンクロージング）- 外側の関数
# G: Global（グローバル）- モジュールレベル
# B: Built-in（組み込み）- Pythonの組み込み

x = "グローバル"  # G: Global

def outer():
    """外側の関数"""
    x = "エンクロージング"  # E: Enclosing
    
    def inner():
        """内側の関数"""
        x = "ローカル"  # L: Local
        print(x)  # ローカル（最も近い）
    
    inner()
    print(x)  # エンクロージング

outer()
print(x)  # グローバル

# 出力:
# ローカル
# エンクロージング
# グローバル


# 変数の探索順序
def check_scope():
    # Pythonは以下の順番で変数を探す:
    # 1. Local（関数内）
    # 2. Enclosing（外側の関数）
    # 3. Global（モジュールレベル）
    # 4. Built-in（組み込み関数）
    
    # 例: len()は組み込み関数（Built-in）
    print(len([1, 2, 3]))  # 3

copy
6. ==とisの違い
📖 値の比較 vs オブジェクトの同一性
❌ 混同して使う例
# ❌ 値の比較にisを使う
a = [1, 2, 3]
b = [1, 2, 3]

if a is b:  # ← 間違い！
    print("同じ")
else:
    print("違う")  # ← こっちが実行される

# なぜなら、aとbは「値は同じ」だが「別のオブジェクト」


# ❌ Noneの比較に==を使う
value = None

if value == None:  # ← 動くけど非推奨
    print("Noneです")

# 正しくは is を使う

copy
✅ 正しい使い分け
# ✅ ==：値が等しいか
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # True（値が同じ）
print(a is b)  # False（別のオブジェクト）


# ✅ is：同じオブジェクトか
a = [1, 2, 3]
b = a  # 参照

print(a == b)  # True（値が同じ）
print(a is b)  # True（同じオブジェクト）


# ✅ Noneの比較は必ずisを使う
value = None

if value is None:  # ← 正しい
    print("Noneです")

if value is not None:  # ← not Noneの場合
    print("Noneじゃない")


# ✅ True/Falseの比較
# 直接比較する（is True は使わない）
flag = True

if flag:  # ← 推奨
    print("真です")

if flag is True:  # ← 非推奨（動くけど）
    print("真です")

if flag == True:  # ← 非推奨
    print("真です")

copy
🎯 ==とisの違いまとめ
# ==：値が等しいか（__eq__メソッドを呼ぶ）
# is：同じオブジェクトか（メモリアドレスが同じか）

a = [1, 2, 3]
b = [1, 2, 3]
c = a

# 値の比較
print(a == b)  # True（値が同じ）
print(a == c)  # True（値が同じ）

# オブジェクトの同一性
print(a is b)  # False（別のオブジェクト）
print(a is c)  # True（同じオブジェクト）

# メモリアドレスで確認
print(id(a))  # 例: 140703348355680
print(id(b))  # 例: 140703348355712（違う）
print(id(c))  # 例: 140703348355680（aと同じ）


# 小さい整数の特殊ケース
# Pythonは-5〜256の整数をキャッシュする
x = 100
y = 100
print(x is y)  # True（同じオブジェクト）

x = 1000
y = 1000
print(x is y)  # False（別のオブジェクト）

copy
7. 文字列の落とし穴
📖 文字列は不変
❌ よくある間違い
# ❌ 文字列を変更しようとする
text = "hello"
text[0] = "H"  # ← エラー！文字列は不変
# TypeError: 'str' object does not support item assignment


# ❌ 文字列の連結を繰り返す（非効率）
result = ""
for i in range(1000):
    result += str(i)  # ← 毎回新しい文字列を作成（遅い）


# ❌ 文字列とバイト列の混同
text = "こんにちは"
encoded = text.encode('utf-8')  # バイト列

print(text + encoded)  # ← エラー！
# TypeError: can only concatenate str (not "bytes") to str

copy
✅ 正しい書き方
# ✅ 文字列を変更するには新しい文字列を作る
text = "hello"
new_text = "H" + text[1:]  # ← 新しい文字列
print(new_text)  # Hello


# ✅ 大量の文字列連結はjoin()を使う
# 遅い方法
result = ""
for i in range(1000):
    result += str(i)

# 速い方法
result = "".join(str(i) for i in range(1000))


# ✅ 文字列とバイト列の変換
text = "こんにちは"

# 文字列 → バイト列
encoded = text.encode('utf-8')
print(encoded)  # b'\xe3\x81\x93\xe3\x82\x93\xe3\x81\xab\xe3\x81\xa1\xe3\x81\xaf'

# バイト列 → 文字列
decoded = encoded.decode('utf-8')
print(decoded)  # こんにちは


# ✅ 文字列の大文字・小文字変換
name = "usausa"
print(name.upper())      # USAUSA
print(name.capitalize()) # Usausa
print(name.title())      # Usausa


# ✅ 文字列の分割と結合
text = "大福,どら焼き,たい焼き"
items = text.split(",")  # リストに分割
print(items)  # ['大福', 'どら焼き', 'たい焼き']

text2 = " - ".join(items)  # 結合
print(text2)  # 大福 - どら焼き - たい焼き


# ✅ 文字列の前後の空白除去
text = "  うさうさ  "
print(text.strip())   # "うさうさ"
print(text.lstrip())  # "うさうさ  "（左だけ）
print(text.rstrip())  # "  うさうさ"（右だけ）

copy
8. リスト内包表記の注意点
📖 便利だけど読みにくくなることも
❌ 読みにくい例
# ❌ 複雑すぎるリスト内包表記
result = [x*y for x in range(10) if x % 2 == 0 for y in range(10) if y % 3 == 0 if x + y < 15]
# ← 何してるかわからない！


# ❌ 副作用のある処理をリスト内包表記で
items = []
[items.append(x) for x in range(10)]  # ← 非推奨
# リスト内包表記は値を返すためのもの


# ❌ ネストしすぎ
matrix = [[j for j in range(5) if j % 2 == 0] for i in range(5) if i % 2 == 0]
# ← 読みにくい

copy
✅ 正しい書き方
# ✅ シンプルなリスト内包表記
# 0〜9の2乗のリスト
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]


# ✅ 条件付きリスト内包表記
# 偶数のみ
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8]


# ✅ if-else付き
# 偶数なら2乗、奇数なら3乗
result = [x**2 if x % 2 == 0 else x**3 for x in range(5)]
print(result)  # [0, 1, 4, 27, 16]


# ✅ 複雑な処理は通常のforループで
# 複雑な場合はわかりやすさ優先
result = []
for x in range(10):
    if x % 2 == 0:
        for y in range(10):
            if y % 3 == 0:
                if x + y < 15:
                    result.append(x * y)


# ✅ 辞書内包表記
# リストから辞書を作る
items = ['大福', 'どら焼き', 'たい焼き']
prices = {item: 150 for item in items}
print(prices)  # {'大福': 150, 'どら焼き': 150, 'たい焼き': 150}


# ✅ 集合内包表記
# 重複を除外
numbers = [1, 2, 2, 3, 3, 3, 4]
unique = {x for x in numbers}
print(unique)  # {1, 2, 3, 4}


# ✅ ジェネレータ式（メモリ効率が良い）
# リスト内包表記
big_list = [x**2 for x in range(1000000)]  # メモリを大量に使う

# ジェネレータ式（()を使う）
big_gen = (x**2 for x in range(1000000))  # メモリ効率が良い

# ジェネレータは1つずつ値を生成
for value in big_gen:
    if value > 100:
        break
```

---

### 🎯 リスト内包表記の使い分け

```python
# ルール1: 1行に収まるならリスト内包表記
squares = [x**2 for x in range(10)]  # ✅ OK


# ルール2: 2行以上になるなら通常のforループ
# ❌ 読みにくい
result = [process(x) for x in items if validate(x) and check(x) if x > 0]

# ✅ 読みやすい
result = []
for x in items:
    if x > 0:
        if validate(x) and check(x):
            result.append(process(x))


# ルール3: ネストは2階層まで
# ✅ OK（2階層）
matrix = [[j for j in range(3)] for i in range(3)]

# ❌ NG（3階層以上）
cube = [[[k for k in range(2)] for j in range(2)] for i in range(2)]


# ルール4: 副作用がある処理は通常のforループ
# ❌ NG
[print(x) for x in items]  # printは副作用

# ✅ OK
for x in items:
    print(x)
```

---

## 9. 例外処理のベストプラクティス

### 📖 エラーを正しく扱う

---

### ❌ よくある間違い

```python
# ❌ 全ての例外を握りつぶす（最悪！）
try:
    # 何か処理
    result = risky_operation()
except:  # ← 何の例外かわからない
    pass  # ← エラーを無視（超危険！）


# ❌ 例外の種類を指定しない
try:
    value = int("abc")
except Exception:  # ← 範囲が広すぎる
    print("エラー")


# ❌ 例外メッセージが不親切
try:
    sell_daifuku(-5)
except ValueError:
    print("エラー")  # ← 何が悪いかわからない


# ❌ 例外を再発生させない
def process_data(data):
    try:
        return expensive_operation(data)
    except ValueError:
        return None  # ← エラーを隠してしまう


# ❌ finally節の使い方を間違える
def read_file():
    f = open('data.txt')
    try:
        return f.read()
    finally:
        f.close()  # ← エラー時にfが存在しない可能性
```

---

### ✅ 正しい例外処理

```python
# ✅ 具体的な例外を指定
def sell_daifuku(quantity: int, stock: int) -> int:
    """
    大福を販売する
    
    Args:
        quantity: 販売個数
        stock: 在庫数
    
    Returns:
        売上金額
    
    Raises:
        TypeError: quantityが整数でない場合
        ValueError: quantityが不正な値の場合
    """
    # 型チェック
    if not isinstance(quantity, int):
        raise TypeError(
            f"個数は整数で指定してください。"
            f"受け取った型: {type(quantity).__name__}"
        )
    
    # 値のチェック
    if quantity <= 0:
        raise ValueError(
            f"個数は1以上にしてください。"
            f"指定された値: {quantity}"
        )
    
    if quantity > stock:
        raise ValueError(
            f"在庫が不足しています。"
            f"在庫: {stock}個、注文: {quantity}個"
        )
    
    # 販売処理
    price = 150
    return quantity * price


# ✅ 複数の例外を個別に処理
def process_order(quantity_str: str, stock: int):
    """注文を処理する"""
    try:
        # 文字列を整数に変換
        quantity = int(quantity_str)
        
        # 販売処理
        total = sell_daifuku(quantity, stock)
        
        return {'success': True, 'total': total}
    
    except ValueError as e:
        # ValueError: int()の変換エラー、またはsell_daifuku()のエラー
        return {'success': False, 'error': str(e)}
    
    except TypeError as e:
        # TypeError: 型エラー
        return {'success': False, 'error': str(e)}
    
    except Exception as e:
        # その他の予期しないエラー
        # ログに記録してから再発生
        print(f"予期しないエラー: {e}")
        raise  # ← 例外を再発生させる


# ✅ else節とfinally節の正しい使い方
def read_file(filename: str) -> str:
    """ファイルを読み込む"""
    try:
        # ファイルを開く
        f = open(filename, 'r', encoding='utf-8')
    
    except FileNotFoundError:
        # ファイルが存在しない
        print(f"ファイルが見つかりません: {filename}")
        return ""
    
    except PermissionError:
        # 読み取り権限がない
        print(f"ファイルの読み取り権限がありません: {filename}")
        return ""
    
    else:
        # tryブロックで例外が発生しなかった場合のみ実行
        try:
            content = f.read()
            return content
        finally:
            # 必ず実行される（ファイルを閉じる）
            f.close()


# ✅ with文を使う（推奨）
def read_file_better(filename: str) -> str:
    """ファイルを読み込む（with文使用）"""
    try:
        # with文を使えば自動的にclose()される
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
            return content
    
    except FileNotFoundError:
        print(f"ファイルが見つかりません: {filename}")
        return ""
    
    except PermissionError:
        print(f"ファイルの読み取り権限がありません: {filename}")
        return ""
    
    except Exception as e:
        print(f"予期しないエラー: {e}")
        raise


# ✅ カスタム例外を作る
class InsufficientStockError(Exception):
    """在庫不足エラー"""
    pass

class InvalidQuantityError(Exception):
    """不正な個数エラー"""
    pass

def sell_daifuku_advanced(quantity: int, stock: int) -> int:
    """
    大福を販売する（カスタム例外版）
    
    Raises:
        InvalidQuantityError: 個数が不正な場合
        InsufficientStockError: 在庫不足の場合
    """
    if quantity <= 0:
        raise InvalidQuantityError(
            f"個数は1以上にしてください。指定値: {quantity}"
        )
    
    if quantity > stock:
        raise InsufficientStockError(
            f"在庫不足です。在庫: {stock}個、注文: {quantity}個"
        )
    
    return quantity * 150

# 使用例
try:
    total = sell_daifuku_advanced(10, 5)
except InvalidQuantityError as e:
    print(f"個数エラー: {e}")
except InsufficientStockError as e:
    print(f"在庫エラー: {e}")
```

---

### 🎯 例外処理のルール

```python
# ルール1: 具体的な例外を指定
# ❌ NG
try:
    value = int("abc")
except:  # すべての例外を捕捉（危険）
    pass

# ✅ OK
try:
    value = int("abc")
except ValueError:  # ValueErrorのみ捕捉
    print("数値に変換できません")


# ルール2: 例外を握りつぶさない
# ❌ NG
try:
    risky_operation()
except Exception:
    pass  # 何もしない（エラーが隠れる）

# ✅ OK
try:
    risky_operation()
except Exception as e:
    print(f"エラー: {e}")  # 最低限ログを出す
    # または
    raise  # 例外を再発生させる


# ルール3: 範囲は狭く
# ❌ NG
try:
    data = load_data()
    result = process_data(data)
    save_result(result)
except Exception:  # どこでエラーが起きたか不明
    pass

# ✅ OK
data = load_data()

try:
    result = process_data(data)
except ValueError as e:
    print(f"処理エラー: {e}")
    raise

save_result(result)


# ルール4: リソースはwith文で管理
# ❌ NG
f = open('file.txt')
try:
    content = f.read()
finally:
    f.close()

# ✅ OK
with open('file.txt') as f:
    content = f.read()
# 自動的にclose()される
```

---

## 10. よくある間違いTop10

### 🎯 新人エンジニアが絶対にハマる間違い

---

### 間違い1: 可変オブジェクトをデフォルト引数に

```python
# ❌ NG
def add_item(item, items=[]):
    items.append(item)
    return items

# ✅ OK
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

---

### 間違い2: リストの参照とコピー

```python
# ❌ NG
list1 = [1, 2, 3]
list2 = list1  # 参照
list2.append(4)
print(list1)  # [1, 2, 3, 4] ← 変わる！

# ✅ OK
list1 = [1, 2, 3]
list2 = list1.copy()  # コピー
list2.append(4)
print(list1)  # [1, 2, 3] ← 変わらない
```

---

### 間違い3: インデントの混在

```python
# ❌ NG（タブとスペースが混在）
def function():
    x = 1      # スペース
	y = 2      # タブ
    return x + y

# ✅ OK（スペース4つで統一）
def function():
    x = 1
    y = 2
    return x + y
```

---

### 間違い4: グローバル変数の変更

```python
# ❌ NG
count = 0

def increment():
    count = count + 1  # エラー！
    return count

# ✅ OK（方法1: 引数で渡す）
def increment(value):
    return value + 1

count = increment(count)

# ✅ OK（方法2: クラスを使う）
class Counter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        self.count += 1
```

---

### 間違い5: ==とisの混同

```python
# ❌ NG
if value == None:  # 動くけど非推奨
    pass

# ✅ OK
if value is None:  # 正しい
    pass
```

---

### 間違い6: 文字列の連結

```python
# ❌ NG（非効率）
result = ""
for i in range(1000):
    result += str(i)

# ✅ OK
result = "".join(str(i) for i in range(1000))
```

---

### 間違い7: 例外の握りつぶし

```python
# ❌ NG
try:
    risky_operation()
except:
    pass  # 何もしない

# ✅ OK
try:
    risky_operation()
except ValueError as e:
    print(f"エラー: {e}")
    raise
```

---

### 間違い8: ループ内での辞書・リストの変更

```python
# ❌ NG
items = [1, 2, 3, 4, 5]
for item in items:
    if item % 2 == 0:
        items.remove(item)  # ループ中に変更（危険）

# ✅ OK
items = [1, 2, 3, 4, 5]
items = [item for item in items if item % 2 != 0]
```

---

### 間違い9: 浮動小数点数の比較

```python
# ❌ NG
a = 0.1 + 0.2
if a == 0.3:  # False!（誤差がある）
    print("等しい")

# ✅ OK
import math

a = 0.1 + 0.2
if math.isclose(a, 0.3):  # 誤差を考慮
    print("ほぼ等しい")
```

---

### 間違い10: 閉じ括弧の数

```python
# ❌ NG
result = ((1 + 2) * (3 + 4)  # 括弧が閉じてない

# ✅ OK
result = ((1 + 2) * (3 + 4))


# ❌ NG
my_list = [1, 2, 3,  # カンマはあるが閉じ括弧がない

# ✅ OK
my_list = [
    1,
    2,
    3,
]  # 最後のカンマはあってもOK
```

---

## 11. 実践チェックリスト

### ✅ コードを書く前にチェック

```
【インデント】
□ スペース4つで統一しているか？
□ タブを使っていないか？
□ 同じブロック内で深さが揃っているか？

【変数・オブジェクト】
□ リストや辞書のデフォルト引数をNoneにしたか？
□ リストのコピーが必要な場合、.copy()を使ったか？
□ グローバル変数を関数内で変更していないか？

【比較演算】
□ Noneの比較に is を使ったか？
□ 値の比較に == を使ったか？

【文字列】
□ 大量の文字列連結にjoin()を使ったか？
□ 文字列を変更しようとしていないか？

【例外処理】
□ 具体的な例外を指定したか？
□ 例外を握りつぶしていないか？
□ ファイル操作にwith文を使ったか？

【リスト内包表記】
□ 1行に収まる長さか？
□ ネストは2階層以下か？
□ 副作用のある処理を入れていないか？
```

---

## 12. まとめ：新人が覚えるべき10のルール

```python
# ルール1: インデントはスペース4つ
def function():
    pass  # ← 4スペース


# ルール2: デフォルト引数に可変オブジェクトを使わない
def func(items=None):  # ← Noneを使う
    if items is None:
        items = []


# ルール3: リストはコピーして使う
new_list = old_list.copy()


# ルール4: Noneの比較は is
if value is None:
    pass


# ルール5: グローバル変数は避ける
# 引数と返り値、またはクラスを使う


# ルール6: 文字列連結はjoin()
result = "".join(items)


# ルール7: 例外は具体的に指定
try:
    something()
except ValueError as e:
    print(e)


# ルール8: with文でリソース管理
with open('file.txt') as f:
    content = f.read()


# ルール9: リスト内包表記はシンプルに
squares = [x**2 for x in range(10)]


# ルール10: 浮動小数点数の比較はisclose()
import math
if math.isclose(a, b):
    pass
```

---

**🐰 うさうさ店長からの最終メッセージ:**

「Pythonの文法は**シンプルで読みやすい**のが特徴ですが、
細かい落とし穴がたくさんあります。

**特に重要なのは:**

1. **インデントを正しく** → エディタの設定を確認
2. **可変オブジェクトの扱い** → コピーと参照の違い
3. **デフォルト引数の罠** → Noneを使う
4. **例外処理** → 具体的に、握りつぶさない

この4つを押さえれば、
新人エンジニアが陥りやすいバグの8割は防げます！

最初は完璧を目指さず、
少しずつ良いコードを書けるようになりましょう。

**困ったときは:**
- 公式ドキュメントを読む
- PEP 8（Pythonのスタイルガイド）を参考に
- linterツール（pylint, flake8）を使う

頑張ってください！🎉」

---

## 付録：便利なツール

### 🛠️ コード品質チェックツール

```bash
# pylint: コードの問題を検出
pip install pylint
pylint your_file.py

# flake8: スタイルガイド違反を検出
pip install flake8
flake8 your_file.py

# black: 自動フォーマッタ
pip install black
black your_file.py

# mypy: 型チェック
pip install mypy
mypy your_file.py
```

---

**📎 関連記事:**
- [PEP 8 -- Style Guide for Python Code](https://pep8.org/)
- [Python公式ドキュメント](https://docs.python.org/ja/3/)
- [The Zen of Python（Pythonの禅）](https://pep20-ja.python.org/)

copy





YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
生成AIパスポート試験合格に向けて学習中！
Python3エンジニア認定試験合格
2025年7月：BIの学習中です！

【技術】
Python/Django/スクレイピング/業務自動化



noteプレミアム
note pro
よくある質問・noteの使い方
プライバシー
クリエイターへのお問い合わせ
フィードバック
ご利用規約
通常ポイント利用特約
加盟店規約
資⾦決済法に基づく表⽰
特商法表記
投資情報の免責事項
🐰 Pythonの文法注意事項完全ガイド新人エンジニアが絶対におさえるべき！つまずきポイント徹底解説｜YUKIKO@BI＆AIを極めたい（転職活動中スカウト歓迎）
