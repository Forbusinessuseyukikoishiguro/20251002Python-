# 🧬 継承・インスタンス・メモリ：完全図解ガイド

## 📚 目次
1. [クラスとインスタンスの基本](#1-クラスとインスタンスの基本)
2. [継承の仕組み](#2-継承の仕組み)
3. [メソッド呼び出し](#3-メソッド呼び出し)
4. [メモリの動き](#4-メモリの動き)
5. [実践例](#5-実践例)

---

## 1️⃣ クラスとインスタンスの基本

### クラスとは？

```python
# クラス = 設計図
class 従業員:
    """従業員の設計図"""
    
    def __init__(self, 名前, 給料):
        # ↑ コンストラクタ（初期化メソッド）
        self.名前 = 名前  # ← インスタンス変数
        self.給料 = 給料
```

**図解：**
```
┌─────────────────┐
│  従業員クラス    │  ← 設計図（1つ）
│  （設計図）      │
├─────────────────┤
│ - 名前          │
│ - 給料          │
│                 │
│ メソッド:       │
│ + __init__()    │
└─────────────────┘
```

---

### インスタンスとは？

```python
# インスタンス = 設計図から作った実物

# インスタンスを作る
太郎 = 従業員("山田太郎", 300000)  # ← インスタンス1
# ↑ 変数名    ↑ クラス名  ↑ 引数

花子 = 従業員("佐藤花子", 350000)  # ← インスタンス2

# それぞれ別のオブジェクト
print(太郎.名前)  # 山田太郎
print(花子.名前)  # 佐藤花子
```

**図解：**
```
         設計図
    ┌─────────────┐
    │  従業員クラス│
    └─────────────┘
           ↓ インスタンス化
    ┌──────┴──────┐
    ↓              ↓
┌────────┐    ┌────────┐
│ 太郎    │    │ 花子    │  ← インスタンス（実物）
├────────┤    ├────────┤
│名前:山田│    │名前:佐藤│
│給料:30万│    │給料:35万│
└────────┘    └────────┘
  実体1         実体2
```

---

### メモリ上の配置

```python
太郎 = 従業員("山田太郎", 300000)
花子 = 従業員("佐藤花子", 350000)
```

**メモリ図：**
```
メモリアドレス
0x1000  ┌──────────────────┐
        │  従業員クラス     │  ← クラスオブジェクト（1つ）
        │  - __init__       │
        │  - その他メソッド  │
        └──────────────────┘

0x2000  ┌──────────────────┐
        │  太郎のインスタンス│  ← インスタンス1
        │  名前: "山田太郎"  │
        │  給料: 300000      │
        └──────────────────┘
        ↑
        太郎（変数）が参照

0x3000  ┌──────────────────┐
        │  花子のインスタンス│  ← インスタンス2
        │  名前: "佐藤花子"  │
        │  給料: 350000      │
        └──────────────────┘
        ↑
        花子（変数）が参照
```

---

## 2️⃣ 継承の仕組み

### 親クラスと子クラス

```python
# ========== 親クラス ==========

class 従業員:  # ← 親クラス（基底クラス）
    """すべての従業員の基本"""
    
    def __init__(self, 名前, ID, 給料):
        # ↑ 親のコンストラクタ
        print(f"【親】従業員.__init__() 実行")
        self.名前 = 名前  # ← 親が定義した属性
        self.ID = ID
        self.給料 = 給料
    
    def 挨拶(self):  # ← 親のメソッド
        """親クラスのメソッド"""
        print(f"【親】こんにちは、{self.名前}です")


# ========== 子クラス ==========

class 正社員(従業員):  # ← 継承（従業員を継承）
    """正社員は従業員の一種"""
    # ↑ class 子クラス(親クラス):
    
    def __init__(self, 名前, ID, 給料, 部署):
        # ↑ 子のコンストラクタ
        
        print(f"【子】正社員.__init__() 開始")
        
        # 親のコンストラクタを呼ぶ
        super().__init__(名前, ID, 給料)
        # ↑ super() = 親クラスを参照
        # ↑ 親の__init__を実行
        
        # 子独自の属性
        self.部署 = 部署  # ← 子が追加した属性
        
        print(f"【子】正社員.__init__() 完了")
    
    def 挨拶(self):  # ← メソッドのオーバーライド
        """親のメソッドを上書き"""
        print(f"【子】こんにちは、{self.部署}の{self.名前}です")
    
    def 残業(self):  # ← 子独自のメソッド
        """子クラスだけのメソッド"""
        print(f"【子】{self.名前}が残業します")
```

**図解：**
```
┌─────────────────────┐
│  従業員（親クラス）  │  ← 親
├─────────────────────┤
│ - 名前              │
│ - ID                │
│ - 給料              │
│                     │
│ + __init__()        │
│ + 挨拶()            │
└─────────────────────┘
          ↑ 継承
          │
┌─────────────────────┐
│  正社員（子クラス）  │  ← 子
├─────────────────────┤
│ 親から継承:          │
│ - 名前              │
│ - ID                │
│ - 給料              │
│                     │
│ 子が追加:           │
│ - 部署              │
│                     │
│ + __init__()  ※上書き│
│ + 挨拶()      ※上書き│
│ + 残業()      ※新規 │
└─────────────────────┘
```

---

### 継承のメモリ構造

```python
# インスタンス作成
社員 = 正社員("山田太郎", "E001", 300000, "営業部")
```

**メモリ図：**
```
クラス階層（メモリ上）

0x1000  ┌──────────────────┐
        │  従業員クラス     │  ← 親クラスオブジェクト
        │                  │
        │  メソッド:        │
        │  - __init__()    │
        │  - 挨拶()        │
        └──────────────────┘
                ↑ 継承
                │
0x1100  ┌──────────────────┐
        │  正社員クラス     │  ← 子クラスオブジェクト
        │                  │
        │  親への参照: 0x1000│  ← 親を参照
        │                  │
        │  メソッド:        │
        │  - __init__()    │  ← オーバーライド
        │  - 挨拶()        │  ← オーバーライド
        │  - 残業()        │  ← 新規
        └──────────────────┘

インスタンス

0x2000  ┌──────────────────┐
        │  社員のインスタンス│  ← 正社員のインスタンス
        │                  │
        │  クラス: 0x1100  │  ← 正社員クラスを参照
        │                  │
        │  属性:            │
        │  名前: "山田太郎" │  ← 親から継承した属性
        │  ID: "E001"      │
        │  給料: 300000    │
        │  部署: "営業部"   │  ← 子が追加した属性
        └──────────────────┘
        ↑
        社員（変数）が参照
```

---

## 3️⃣ メソッド呼び出し

### 呼び出しの流れ

```python
# インスタンス作成
社員 = 正社員("山田太郎", "E001", 300000, "営業部")

# メソッド呼び出し
社員.挨拶()
```

**1行ずつ解説：**
```python
社員 = 正社員("山田太郎", "E001", 300000, "営業部")
# ↓ 何が起きる？

# STEP 1: 正社員.__init__() が呼ばれる
print(f"【子】正社員.__init__() 開始")
# ↓

# STEP 2: super().__init__() で親を呼ぶ
super().__init__(名前, ID, 給料)
# ↓ これは以下と同じ
従業員.__init__(self, "山田太郎", "E001", 300000)
# ↓

# STEP 3: 親の__init__()が実行される
print(f"【親】従業員.__init__() 実行")
self.名前 = "山田太郎"  # ← インスタンスに保存
self.ID = "E001"
self.給料 = 300000
# ↓

# STEP 4: 親から戻る
# ↓

# STEP 5: 子の処理を続ける
self.部署 = "営業部"  # ← 子独自の属性追加
print(f"【子】正社員.__init__() 完了")
# ↓

# 完成！
```

**実行結果：**
```
【子】正社員.__init__() 開始
【親】従業員.__init__() 実行
【子】正社員.__init__() 完了
```

---

### メソッド探索（Method Resolution Order: MRO）

```python
社員.挨拶()  # ← このメソッドはどこ？
```

**探索の流れ：**
```
1. 社員のインスタンスを見る
   └─ 挨拶()メソッドなし
      ↓
2. 社員のクラス（正社員）を見る
   └─ 挨拶()メソッド発見！
      ↓
3. 正社員.挨拶()を実行
   出力: "【子】こんにちは、営業部の山田太郎です"
```

**もし子クラスになければ：**
```python
class 正社員(従業員):
    def __init__(self, ...):
        super().__init__(...)
    
    # 挨拶()をオーバーライドしない
```

```
1. 社員のインスタンスを見る
   └─ 挨拶()メソッドなし
      ↓
2. 社員のクラス（正社員）を見る
   └─ 挨拶()メソッドなし
      ↓
3. 親クラス（従業員）を見る
   └─ 挨拶()メソッド発見！
      ↓
4. 従業員.挨拶()を実行
   出力: "【親】こんにちは、山田太郎です"
```

**MRO確認：**
```python
print(正社員.mro())
# [<class '正社員'>, <class '従業員'>, <class 'object'>]
# ↑ この順番で探す
```

---

### 親のメソッドを呼ぶ方法

```python
class 正社員(従業員):
    def 挨拶(self):
        """子のメソッドから親のメソッドを呼ぶ"""
        
        # 方法1: super()を使う（推奨）
        print("【子】まず親の挨拶：")
        super().挨拶()  # ← 親の挨拶()を呼ぶ
        # ↑ 従業員.挨拶(self) と同じ
        
        print("【子】次に自己紹介：")
        print(f"部署は{self.部署}です")


# 使う
社員 = 正社員("山田太郎", "E001", 300000, "営業部")
社員.挨拶()
```

**出力：**
```
【子】まず親の挨拶：
【親】こんにちは、山田太郎です
【子】次に自己紹介：
部署は営業部です
```

**フロー図：**
```
社員.挨拶()
    ↓
正社員.挨拶()  ← 子のメソッド
    ↓
    print("まず親の挨拶")
    ↓
    super().挨拶()  ← 親を呼ぶ
        ↓
        従業員.挨拶()  ← 親のメソッド
            ↓
            print("こんにちは...")
        ↓
        戻る
    ↓
    print("次に自己紹介")
    print("部署は...")
    ↓
    戻る
```

---

## 4️⃣ メモリの動き

### インスタンス作成時

```python
社員 = 正社員("山田太郎", "E001", 300000, "営業部")
```

**メモリの変化を追う：**

**STEP 1: メモリ確保**
```
0x2000  ┌──────────────────┐
        │  空のメモリ領域   │  ← まだ何もない
        └──────────────────┘
```

**STEP 2: 親の__init__()実行**
```python
super().__init__(名前, ID, 給料)
# ↓ 親が属性を設定

0x2000  ┌──────────────────┐
        │  名前: "山田太郎" │  ← 親が追加
        │  ID: "E001"      │  ← 親が追加
        │  給料: 300000    │  ← 親が追加
        └──────────────────┘
```

**STEP 3: 子の__init__()実行**
```python
self.部署 = "営業部"
# ↓ 子が属性を追加

0x2000  ┌──────────────────┐
        │  名前: "山田太郎" │
        │  ID: "E001"      │
        │  給料: 300000    │
        │  部署: "営業部"   │  ← 子が追加
        └──────────────────┘
```

**STEP 4: 参照を保存**
```
社員 ────────→ 0x2000
    （参照）
```

---

### 参照とは？

```python
社員 = 正社員("山田太郎", "E001", 300000, "営業部")
```

**図解：**
```
変数（スタック）           オブジェクト（ヒープ）

┌────────┐
│  社員   │ ──参照──→  ┌──────────────┐
│        │             │ 正社員インスタンス│
│ 0x2000 │             │ 名前: 山田太郎   │
└────────┘             │ ID: E001        │
                       │ 給料: 300000    │
                       │ 部署: 営業部     │
                       └──────────────┘
                       メモリアドレス: 0x2000
```

**変数は「箱」ではなく「矢印」**
```python
# 社員という変数は、オブジェクトそのものではない
# オブジェクトがある場所（アドレス）を指している

社員     ─────→  [実際のオブジェクト]
↑ 参照            ↑ 実体
```

---

### 複数の参照

```python
社員1 = 正社員("山田太郎", "E001", 300000, "営業部")
社員2 = 社員1  # ← コピーではなく参照のコピー

print(id(社員1))  # 140234567890
print(id(社員2))  # 140234567890  ← 同じ！
# ↑ id() = オブジェクトのメモリアドレス

# 社員2で変更すると...
社員2.名前 = "鈴木次郎"

print(社員1.名前)  # 鈴木次郎  ← 社員1も変わる！
print(社員2.名前)  # 鈴木次郎
```

**メモリ図：**
```
┌────────┐
│ 社員1   │ ─┐
└────────┘  │
            ├──→  ┌──────────────┐
┌────────┐  │      │ 正社員インスタンス│
│ 社員2   │ ─┘      │ 名前: 鈴木次郎   │
└────────┘         │ ID: E001        │
                   └──────────────┘
両方とも同じオブジェクトを指している
```

---

## 5️⃣ 実践例

### 完全な例：従業員システム

```python
# ========================================
# 親クラス：従業員
# ========================================

class 従業員:
    """すべての従業員の基底クラス"""
    
    # クラス変数（すべてのインスタンスで共有）
    会社名 = "ABC株式会社"
    従業員数 = 0
    
    def __init__(self, 名前: str, ID: str, 給料: int):
        """コンストラクタ"""
        # ↑ インスタンス作成時に自動実行される
        
        print(f"\n【親】従業員.__init__() 開始")
        print(f"  引数: 名前={名前}, ID={ID}, 給料={給料}")
        
        # インスタンス変数（各インスタンス固有）
        self.名前 = 名前  # ← self = このインスタンス
        self.ID = ID
        self.給料 = 給料
        
        # クラス変数を更新
        従業員.従業員数 += 1  # ← クラス名.変数名
        # または self.__class__.従業員数 += 1
        
        print(f"【親】従業員.__init__() 完了")
        print(f"  現在の従業員数: {従業員.従業員数}人")
    
    def 挨拶(self):
        """自己紹介"""
        print(f"【親メソッド】こんにちは、{self.名前}です")
        print(f"  ID: {self.ID}")
    
    def 給料明細(self):
        """給料を表示"""
        print(f"【親メソッド】{self.名前}の給料: ¥{self.給料:,}")
    
    def __str__(self):
        """print()時の表示"""
        return f"従業員({self.名前}, {self.ID})"
    
    def __repr__(self):
        """デバッグ時の表示"""
        return f"従業員(名前='{self.名前}', ID='{self.ID}', 給料={self.給料})"


# ========================================
# 子クラス1：正社員
# ========================================

class 正社員(従業員):  # ← 従業員を継承
    """正社員クラス"""
    
    def __init__(self, 名前: str, ID: str, 給料: int, 部署: str):
        """正社員のコンストラクタ"""
        # ↑ 親より引数が1つ多い（部署）
        
        print(f"\n【子1】正社員.__init__() 開始")
        
        # 親のコンストラクタを呼ぶ
        super().__init__(名前, ID, 給料)
        # ↑ super() = 親クラス（従業員）を参照
        # ↑ 親の__init__を実行して、名前・ID・給料を設定
        
        # 子独自の属性
        self.部署 = 部署  # ← 正社員だけの属性
        
        print(f"【子1】正社員.__init__() 完了")
        print(f"  部署: {self.部署}")
    
    def 挨拶(self):
        """オーバーライド：親のメソッドを上書き"""
        print(f"【子1メソッド】こんにちは、{self.部署}の{self.名前}です")
        print(f"  ID: {self.ID}")
        print(f"  よろしくお願いします")
    
    def 残業(self, 時間: int):
        """正社員だけのメソッド"""
        残業代 = 時間 * 2000
        print(f"【子1メソッド】{self.名前}が{時間}時間残業")
        print(f"  残業代: ¥{残業代:,}")
    
    def 親の挨拶も呼ぶ(self):
        """親のメソッドも使う例"""
        print(f"【子1メソッド】まず親の挨拶：")
        super().挨拶()  # ← 親の挨拶()を呼ぶ
        
        print(f"【子1メソッド】次に自分の情報：")
        print(f"  部署: {self.部署}")


# ========================================
# 子クラス2：アルバイト
# ========================================

class アルバイト(従業員):  # ← 従業員を継承
    """アルバイトクラス"""
    
    def __init__(self, 名前: str, ID: str, 時給: int, 勤務時間: int):
        """アルバイトのコンストラクタ"""
        
        print(f"\n【子2】アルバイト.__init__() 開始")
        
        # 給料を計算してから親を呼ぶ
        月給 = 時給 * 勤務時間 * 4  # ← 週の時間 × 4週
        super().__init__(名前, ID, 月給)
        
        # 子独自の属性
        self.時給 = 時給
        self.勤務時間 = 勤務時間
        
        print(f"【子2】アルバイト.__init__() 完了")
        print(f"  時給: ¥{self.時給}, 週{self.勤務時間}時間")
    
    def 挨拶(self):
        """オーバーライド"""
        print(f"【子2メソッド】こんにちは、バイトの{self.名前}です")
        print(f"  時給¥{self.時給}で頑張ります！")
    
    def 給料明細(self):
        """オーバーライド：詳細な明細"""
        print(f"【子2メソッド】{self.名前}の給料明細")
        print(f"  時給: ¥{self.時給}")
        print(f"  週の勤務時間: {self.勤務時間}時間")
        print(f"  月給: ¥{self.給料:,}")


# ========================================
# メモリの動きを追跡する関数
# ========================================

def メモリアドレス表示(オブジェクト, 名前):
    """オブジェクトのメモリアドレスを表示"""
    print(f"\n【メモリ】{名前}")
    print(f"  アドレス: {hex(id(オブジェクト))}")
    print(f"  型: {type(オブジェクト)}")
    print(f"  値: {オブジェクト}")


# ========================================
# 実行例
# ========================================

if __name__ == "__main__":
    print("=" * 50)
    print("継承・インスタンス・メモリのデモ")
    print("=" * 50)
    
    # ===== 正社員を作成 =====
    print("\n" + "=" * 50)
    print("1. 正社員のインスタンス作成")
    print("=" * 50)
    
    社員 = 正社員("山田太郎", "E001", 350000, "営業部")
    メモリアドレス表示(社員, "社員")
    
    # ===== メソッド呼び出し =====
    print("\n" + "=" * 50)
    print("2. メソッド呼び出し")
    print("=" * 50)
    
    社員.挨拶()  # ← 子のメソッド
    社員.給料明細()  # ← 親のメソッド
    社員.残業(5)  # ← 子だけのメソッド
    
    # ===== 親のメソッドも呼ぶ =====
    print("\n" + "=" * 50)
    print("3. 親のメソッドも呼ぶ")
    print("=" * 50)
    
    社員.親の挨拶も呼ぶ()
    
    # ===== アルバイトを作成 =====
    print("\n" + "=" * 50)
    print("4. アルバイトのインスタンス作成")
    print("=" * 50)
    
    バイト = アルバイト("佐藤花子", "P001", 1200, 20)
    メモリアドレス表示(バイト, "バイト")
    
    # ===== メソッド呼び出し =====
    print("\n" + "=" * 50)
    print("5. アルバイトのメソッド")
    print("=" * 50)
    
    バイト.挨拶()  # ← 子のメソッド
    バイト.給料明細()  # ← 子のメソッド（オーバーライド）
    
    # ===== クラス変数 =====
    print("\n" + "=" * 50)
    print("6. クラス変数の確認")
    print("=" * 50)
    
    print(f"会社名: {従業員.会社名}")
    print(f"従業員数: {従業員.従業員数}人")
    
    # ===== 参照の確認 =====
    print("\n" + "=" * 50)
    print("7. 参照のコピー")
    print("=" * 50)
    
    社員2 = 社員  # ← 参照のコピー
    print(f"社員のアドレス: {hex(id(社員))}")
    print(f"社員2のアドレス: {hex(id(社員2))}")
    print(f"同じオブジェクト？: {社員 is 社員2}")
    
    # ===== MRO確認 =====
    print("\n" + "=" * 50)
    print("8. メソッド探索順序（MRO）")
    print("=" * 50)
    
    print("正社員のMRO:")
    for i, cls in enumerate(正社員.mro(), 1):
        print(f"  {i}. {cls}")
    
    # ===== 属性の確認 =====
    print("\n" + "=" * 50)
    print("9. インスタンスの属性")
    print("=" * 50)
    
    print("社員の属性:")
    for 属性名, 値 in 社員.__dict__.items():
        print(f"  {属性名}: {値}")
```

---

### 実行結果

```
==================================================
継承・インスタンス・メモリのデモ
==================================================

==================================================
1. 正社員のインスタンス作成
==================================================

【子1】正社員.__init__() 開始

【親】従業員.__init__() 開始
  引数: 名前=山田太郎, ID=E001, 給料=350000
【親】従業員.__init__() 完了
  現在の従業員数: 1人
【子1】正社員.__init__() 完了
  部署: 営業部

【メモリ】社員
  アドレス: 0x7f8b2c3d4e10
  型: <class '__main__.正社員'>
  値: 従業員(山田太郎, E001)

==================================================
2. メソッド呼び出し
==================================================
【子1メソッド】こんにちは、営業部の山田太郎です
  ID: E001
  よろしくお願いします
【親メソッド】山田太郎の給料: ¥350,000
【子1メソッド】山田太郎が5時間残業
  残業代: ¥10,000

==================================================
3. 親のメソッドも呼ぶ
==================================================
【子1メソッド】まず親の挨拶：
【親メソッド】こんにちは、山田太郎です
  ID: E001
【子1メソッド】次に自分の情報：
  部署: 営業部

==================================================
4. アルバイトのインスタンス作成
==================================================

【子2】アルバイト.__init__() 開始

【親】従業員.__init__() 開始
  引数: 名前=佐藤花子, ID=P001, 給料=96000
【親】従業員.__init__() 完了
  現在の従業員数: 2人
【子2】アルバイト.__init__() 完了
  時給: ¥1200, 週20時間

【メモリ】バイト
  アドレス: 0x7f8b2c3d4f20
  型: <class '__main__.アルバイト'>
  値: 従業員(佐藤花子, P001)

==================================================
9. インスタンスの属性
==================================================
社員の属性:
  名前: 山田太郎
  ID: E001
  給料: 350000
  部署: 営業部
```

---

## 📊 図解まとめ

### 継承の全体像

```
┌──────────────────────┐
│    従業員（親）       │
│                      │
│  + 名前              │
│  + ID                │
│  + 給料              │
│                      │
│  + __init__()        │
│  + 挨拶()            │
│  + 給料明細()        │
└──────────────────────┘
          ↑ 継承
    ┌─────┴─────┐
    │             │
┌───────────┐ ┌───────────┐
│ 正社員（子）│ │アルバイト（子）│
│           │ │           │
│親から継承: │ │親から継承: │
│ + 名前    │ │ + 名前    │
│ + ID      │ │ + ID      │
│ + 給料    │ │ + 給料    │
│           │ │           │
│子が追加:  │ │子が追加:  │
│ + 部署    │ │ + 時給    │
│           │ │ + 勤務時間│
│           │ │           │
│メソッド:  │ │メソッド:  │
│挨拶()※上書│ │挨拶()※上書│
│残業()※新規│ │給料明細()※上書│
└───────────┘ └───────────┘
```

---

## 🎯 重要ポイント

### 継承
```python
class 子クラス(親クラス):  # ← 継承の書き方
    def __init__(self, ...):
        super().__init__(...)  # ← 親を呼ぶ
```

### インスタンス化
```python
インスタンス = クラス名(引数)  # ← インスタンス作成
# ↑ __init__()が自動実行される
```

### メソッド呼び出し
```python
インスタンス.メソッド()  # ← 子→親の順で探す
super().メソッド()       # ← 親を明示的に呼ぶ
```

### メモリ
```python
変数 = インスタンス  # ← 参照（矢印）
# 変数はオブジェクトのアドレスを保持
```

---

これで継承・インスタンス・メモリの仕組みが完全に理解できましたか？🎓

実際にコードを写経して、print()で動きを確認してみてください！💪
