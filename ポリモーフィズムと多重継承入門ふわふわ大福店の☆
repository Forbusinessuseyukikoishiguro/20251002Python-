"""
====================================
🐰 ポリモーフィズムと多重継承 超入門
====================================
日常の例で理解する！新人エンジニア向け
"""

print("=" * 70)
print("🎯 第1部: ポリモーフィズムって何？")
print("=" * 70)
print()

# ====================================
# ポリモーフィズムとは？
# ====================================
"""
ポリモーフィズム = 「同じ命令で、違うことをする」能力

【日常の例】
「鳴いて！」という命令に対して...
- 犬 → 「ワン！」
- 猫 → 「ニャー！」
- 鳥 → 「ピーピー！」

同じ「鳴いて」という命令なのに、動物によって鳴き方が違う！
これがポリモーフィズム！
"""

# ====================================
# 例1: ポリモーフィズムなし（悪い例）
# ====================================
print("【悪い例】ポリモーフィズムを使わない場合")
print("-" * 70)

class Dog:
    """犬クラス"""
    def __init__(self, name):
        # 犬の名前を保存
        self.name = name
    
    def dog_bark(self):  # 犬専用のメソッド名
        """犬の鳴き声"""
        print(f"{self.name}: ワンワン！🐕")


class Cat:
    """猫クラス"""
    def __init__(self, name):
        # 猫の名前を保存
        self.name = name
    
    def cat_meow(self):  # 猫専用のメソッド名
        """猫の鳴き声"""
        print(f"{self.name}: ニャー！🐱")


class Bird:
    """鳥クラス"""
    def __init__(self, name):
        # 鳥の名前を保存
        self.name = name
    
    def bird_chirp(self):  # 鳥専用のメソッド名
        """鳥の鳴き声"""
        print(f"{self.name}: ピーピー！🐦")


# 動物を作る
pochi = Dog("ポチ")
tama = Cat("タマ")
piyo = Bird("ピヨ")

# 鳴かせる（メソッド名がバラバラで面倒...）
pochi.dog_bark()   # 犬用のメソッド
tama.cat_meow()    # 猫用のメソッド
piyo.bird_chirp()  # 鳥用のメソッド

print("\n❌ 問題点:")
print("  - メソッド名がバラバラ（dog_bark, cat_meow, bird_chirp）")
print("  - 新しい動物を追加するたびに、呼び出し方を変える必要がある")
print("  - コードが複雑になる")
print()

# ====================================
# 例2: ポリモーフィズムあり（良い例）
# ====================================
print("\n【良い例】ポリモーフィズムを使う場合")
print("-" * 70)

class Animal:
    """動物の親クラス（基底クラス）"""
    def __init__(self, name):
        # すべての動物に共通の属性
        self.name = name
    
    def speak(self):
        """鳴く（子クラスで具体的な鳴き方を実装）"""
        # この親クラスでは何もしない
        # 子クラスで上書き（オーバーライド）される
        pass


class Dog2(Animal):
    """犬クラス（Animalを継承）"""
    def speak(self):
        """犬の鳴き方"""
        # 親クラスのメソッドを上書き
        print(f"{self.name}: ワンワン！🐕")


class Cat2(Animal):
    """猫クラス（Animalを継承）"""
    def speak(self):
        """猫の鳴き方"""
        # 親クラスのメソッドを上書き
        print(f"{self.name}: ニャー！🐱")


class Bird2(Animal):
    """鳥クラス（Animalを継承）"""
    def speak(self):
        """鳥の鳴き方"""
        # 親クラスのメソッドを上書き
        print(f"{self.name}: ピーピー！🐦")


# 動物を作る
pochi2 = Dog2("ポチ")
tama2 = Cat2("タマ")
piyo2 = Bird2("ピヨ")

# すべて同じメソッド名で呼び出せる！
pochi2.speak()  # すべて speak() で統一！
tama2.speak()   # すべて speak() で統一！
piyo2.speak()   # すべて speak() で統一！

print("\n✅ メリット:")
print("  - メソッド名が統一（すべて speak()）")
print("  - 新しい動物を追加しても、呼び出し方は同じ")
print("  - コードがシンプル")
print()


# ====================================
# ポリモーフィズムの本当の力
# ====================================
print("\n" + "=" * 70)
print("✨ ポリモーフィズムの真の力！")
print("=" * 70)

def make_sound(animal):
    """
    どんな動物でも鳴かせる関数
    
    ポイント:
    - この関数は、犬か猫か鳥か知らなくていい
    - ただ speak() を呼ぶだけ
    - でも、実際には正しい鳴き方をする
    
    これがポリモーフィズムの力！
    """
    print(f"📢 {animal.name}さん、鳴いてください！")
    # どの動物でも同じように呼び出せる
    animal.speak()


print("\n【デモ】1つの関数で、すべての動物を処理")
print("-" * 70)

# いろんな動物を作る
dog = Dog2("ポチ")
cat = Cat2("タマ")
bird = Bird2("ピヨ")

# 同じ関数で処理できる！
make_sound(dog)   # 犬を渡す
print()
make_sound(cat)   # 猫を渡す
print()
make_sound(bird)  # 鳥を渡す
print()

# リストにまとめて処理することも可能！
print("【デモ】リストで一括処理")
print("-" * 70)

# いろんな動物をリストに入れる
animals = [
    Dog2("ポチ"),
    Cat2("タマ"),
    Bird2("ピヨ"),
    Dog2("シロ"),
    Cat2("ミケ")
]

# すべての動物を鳴かせる
for animal in animals:
    # 犬か猫か鳥か気にしなくていい！
    # ただ speak() を呼ぶだけ
    animal.speak()

print()


# ====================================
# 実践例: ふわふわ大福店
# ====================================
print("\n" + "=" * 70)
print("🐰 実践例: ふわふわ大福店でのポリモーフィズム")
print("=" * 70)

class DaifukuShop:
    """大福店の親クラス"""
    def __init__(self, shop_name):
        # 店名を保存
        self.shop_name = shop_name
    
    def sell(self, quantity):
        """販売メソッド（子クラスで上書きされる）"""
        pass


class NormalShop(DaifukuShop):
    """通常店舗"""
    def sell(self, quantity):
        """通常価格で販売"""
        price = quantity * 150  # 1個150円
        print(f"🏪 {self.shop_name}: {quantity}個を¥{price}で販売しました")
        return price


class PremiumShop(DaifukuShop):
    """プレミアム店舗"""
    def sell(self, quantity):
        """プレミアム価格で販売"""
        price = quantity * 200  # 1個200円（高級）
        print(f"✨ {self.shop_name}: プレミアム大福{quantity}個を¥{price}で販売しました")
        return price


class DiscountShop(DaifukuShop):
    """ディスカウント店舗"""
    def sell(self, quantity):
        """割引価格で販売"""
        price = quantity * 100  # 1個100円（安い）
        print(f"💰 {self.shop_name}: お得な大福{quantity}個を¥{price}で販売しました")
        return price


def process_order(shop, quantity):
    """
    どの店舗でも同じ方法で注文処理
    これがポリモーフィズム！
    """
    print(f"\n📝 {shop.shop_name}で注文処理開始...")
    # どの店舗でも sell() を呼ぶだけ
    # でも、実際の価格は店舗によって違う
    total = shop.sell(quantity)
    print(f"✅ 注文完了: 合計¥{total}")


print("\n【デモ】いろんな店舗で注文")
print("-" * 70)

# 3種類の店舗を作る
normal = NormalShop("うさうさ店")
premium = PremiumShop("もちもち店")
discount = DiscountShop("安い店")

# すべて同じ関数で処理できる！
process_order(normal, 5)    # 通常店舗
process_order(premium, 3)   # プレミアム店舗
process_order(discount, 10) # ディスカウント店舗

print()


# ====================================
# 第2部: 多重継承って何？
# ====================================
print("\n" + "=" * 70)
print("🎯 第2部: 多重継承って何？")
print("=" * 70)
print()

"""
多重継承 = 「複数の親から能力を受け継ぐ」こと

【日常の例】
スマートフォン = 電話 + カメラ + 音楽プレーヤー + GPS

- 電話の機能（通話）
- カメラの機能（撮影）
- 音楽プレーヤーの機能（音楽再生）
- GPSの機能（位置情報）

これらすべての機能を1つの機器に統合 → これが多重継承の考え方！
"""

# ====================================
# 例1: 多重継承なし（悪い例）
# ====================================
print("【悪い例】多重継承を使わない場合")
print("-" * 70)

class OldPhone:
    """古い携帯電話（通話だけ）"""
    def __init__(self):
        print("📱 携帯電話を作成")
    
    def call(self, number):
        """電話をかける"""
        print(f"📞 {number}に電話しています...")


# 古い携帯は通話しかできない...
old_phone = OldPhone()
old_phone.call("090-1234-5678")
# old_phone.take_photo()  # カメラ機能なし！
# old_phone.play_music()  # 音楽機能なし！

print("\n❌ 問題点: 機能が限定的")
print()


# ====================================
# 例2: 多重継承あり（良い例）
# ====================================
print("\n【良い例】多重継承を使う場合")
print("-" * 70)

# 機能ごとにクラスを分ける

class Phone:
    """電話の機能"""
    def call(self, number):
        """電話をかける"""
        print(f"📞 {number}に電話しています...")


class Camera:
    """カメラの機能"""
    def take_photo(self):
        """写真を撮る"""
        print(f"📷 写真を撮りました！")


class MusicPlayer:
    """音楽プレーヤーの機能"""
    def play_music(self, song):
        """音楽を再生"""
        print(f"🎵 「{song}」を再生しています...")


class GPS:
    """GPS機能"""
    def get_location(self):
        """現在地を取得"""
        print(f"📍 現在地: 東京タワー付近")


# スマートフォン = すべての機能を持つ！
class SmartPhone(Phone, Camera, MusicPlayer, GPS):
    """
    スマートフォン（多重継承）
    
    継承元:
    - Phone（電話機能）
    - Camera（カメラ機能）
    - MusicPlayer（音楽機能）
    - GPS（位置情報機能）
    
    → 4つの親クラスから全機能を継承！
    """
    def __init__(self, model):
        # スマホのモデル名
        self.model = model
        print(f"📱 {self.model}を起動しました")


# スマートフォンを作る
iphone = SmartPhone("iPhone 15")
print()

# すべての機能が使える！
iphone.call("090-1234-5678")        # Phone から継承
iphone.take_photo()                  # Camera から継承
iphone.play_music("春の歌")          # MusicPlayer から継承
iphone.get_location()                # GPS から継承

print("\n✅ メリット: すべての機能を1つに統合！")
print()


# ====================================
# 実践例: ふわふわ大福店（多重継承版）
# ====================================
print("\n" + "=" * 70)
print("🐰 実践例: ふわふわ大福店での多重継承")
print("=" * 70)
print()

# 機能ごとにクラスを分ける

class BasicShop:
    """基本的な店舗機能"""
    def __init__(self):
        # 在庫を初期化
        self.stock = 20
        print("🏪 店舗機能: 在庫管理システム起動")
    
    def sell(self, quantity):
        """大福を販売"""
        if quantity > self.stock:
            print(f"❌ 在庫不足！（残り{self.stock}個）")
            return False
        
        # 在庫を減らす
        self.stock -= quantity
        print(f"💰 {quantity}個販売しました（残り{self.stock}個）")
        return True


class OnlineOrder:
    """オンライン注文機能"""
    def __init__(self):
        # オンライン注文数を初期化
        self.online_orders = 0
        print("🌐 オンライン注文システム起動")
    
    def receive_order(self, customer, quantity):
        """オンライン注文を受け付け"""
        self.online_orders += 1
        print(f"🌐 オンライン注文 #{self.online_orders}: {customer}様 {quantity}個")


class DeliveryService:
    """配達サービス機能"""
    def __init__(self):
        # 配達回数を初期化
        self.deliveries = 0
        print("🚚 配達サービス起動")
    
    def deliver(self, address):
        """配達する"""
        self.deliveries += 1
        print(f"🚚 配達 #{self.deliveries}: {address}へ配達中...")


class MemberSystem:
    """会員システム機能"""
    def __init__(self):
        # 会員リストを初期化
        self.members = []
        print("💳 会員システム起動")
    
    def register(self, name):
        """会員登録"""
        self.members.append(name)
        print(f"💳 {name}様を会員登録しました（会員数: {len(self.members)}名）")


# すべての機能を持つハイブリッド店舗！
class HybridShop(BasicShop, OnlineOrder, DeliveryService, MemberSystem):
    """
    ハイブリッド大福店（多重継承）
    
    継承元:
    - BasicShop（店舗機能）
    - OnlineOrder（オンライン注文）
    - DeliveryService（配達サービス）
    - MemberSystem（会員システム）
    
    → 4つの機能すべてを持つ！
    """
    def __init__(self, shop_name):
        """
        すべての親クラスを初期化
        """
        # 店名を保存
        self.shop_name = shop_name
        
        print(f"\n{'='*50}")
        print(f"🌟 {self.shop_name}を起動中...")
        print(f"{'='*50}")
        
        # すべての親クラスを初期化
        BasicShop.__init__(self)          # 店舗機能
        OnlineOrder.__init__(self)        # オンライン機能
        DeliveryService.__init__(self)    # 配達機能
        MemberSystem.__init__(self)       # 会員機能
        
        print(f"✅ すべての機能が利用可能です！")
        print(f"{'='*50}\n")


# ハイブリッド店舗を作る
print("【デモ】ハイブリッド店舗の全機能")
print("-" * 70)

hybrid = HybridShop("うさうさハイブリッド店")

# すべての機能が使える！
print("\n1️⃣ 会員登録（MemberSystemから継承）")
hybrid.register("田中太郎")
hybrid.register("佐藤花子")

print("\n2️⃣ オンライン注文（OnlineOrderから継承）")
hybrid.receive_order("田中太郎", 5)

print("\n3️⃣ 販売（BasicShopから継承）")
hybrid.sell(5)

print("\n4️⃣ 配達（DeliveryServiceから継承）")
hybrid.deliver("東京都渋谷区")

print("\n✅ 1つのオブジェクトで、4つの機能すべてを実行できた！")
print()


# ====================================
# まとめ
# ====================================
print("\n" + "=" * 70)
print("📚 まとめ")
print("=" * 70)

print("""
【ポリモーフィズム】
- 同じメソッド名で、違うことをする
- 例: speak() → 犬は「ワン」、猫は「ニャー」
- メリット: コードがシンプルで拡張しやすい

【多重継承】
- 複数の親クラスから機能を受け継ぐ
- 例: スマホ = 電話 + カメラ + 音楽 + GPS
- メリット: いろんな機能を1つに統合できる

【使い分け】
- ポリモーフィズム: 「同じやり方で、違う結果」が欲しい時
- 多重継承: 「いろんな機能を組み合わせたい」時
""")

print("=" * 70)
print("🎉 完了！実際に動かして理解を深めましょう！")
print("=" * 70)
