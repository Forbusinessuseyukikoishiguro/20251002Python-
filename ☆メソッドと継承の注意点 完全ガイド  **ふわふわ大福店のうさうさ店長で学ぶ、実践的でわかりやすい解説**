# 🐰 Pythonメソッドと継承の注意点 完全ガイド

**ふわふわ大福店のうさうさ店長で学ぶ、実践的でわかりやすい解説**

---

## 📚 目次

1. [メソッドの種類](#1-メソッドの種類)
2. [アクセス制御（public/private）](#2-アクセス制御publicprivate)
3. [継承での注意点](#3-継承での注意点)
4. [メソッドのオーバーライド](#4-メソッドのオーバーライド)
5. [super()の正しい使い方](#5-superの正しい使い方)
6. [多重継承の落とし穴](#6-多重継承の落とし穴)
7. [ベストプラクティス](#7-ベストプラクティス)

---

## 1. メソッドの種類

### 📖 3つのメソッドタイプ

Pythonには3種類のメソッドがあります：

| 種類 | 第一引数 | 呼び出し方 | 用途 |
|------|---------|-----------|------|
| **インスタンスメソッド** | `self` | `obj.method()` | 個別の処理 |
| **クラスメソッド** | `cls` | `Class.method()` | クラス全体の処理 |
| **スタティックメソッド** | なし | `Class.method()` | 補助関数 |

### 💻 実際のコード

```python
class DaifukuShop:
    """大福店クラス"""
    
    # クラス変数
    total_shops = 0
    tax_rate = 0.10
    
    def __init__(self, owner_name, stock):
        """コンストラクタ"""
        self.owner_name = owner_name
        self.stock = stock
        DaifukuShop.total_shops += 1
    
    # ========================================
    # 1. インスタンスメソッド（最も一般的）
    # ========================================
    def sell(self, quantity):
        """
        個別の店舗で販売処理
        
        特徴:
        - 第一引数は self（自分自身）
        - インスタンス変数にアクセスできる
        - クラス変数にもアクセスできる
        """
        if quantity > self.stock:
            print(f"❌ 在庫不足！")
            return False
        
        self.stock -= quantity  # インスタンス変数を変更
        total = int(quantity * 150 * (1 + DaifukuShop.tax_rate))
        print(f"💰 {self.owner_name}店長: {quantity}個販売（¥{total}）")
        return True
    
    # ========================================
    # 2. クラスメソッド
    # ========================================
    @classmethod
    def get_total_shops(cls):
        """
        クラス全体の情報を取得
        
        特徴:
        - @classmethod デコレーター必須
        - 第一引数は cls（クラス自身）
        - クラス変数にアクセスできる
        - インスタンスを作らずに呼べる
        """
        return f"現在の総店舗数: {cls.total_shops}店"
    
    @classmethod
    def from_dict(cls, data):
        """
        辞書からインスタンスを生成（ファクトリーメソッド）
        
        特徴:
        - 別の方法でインスタンスを作成
        - 代替コンストラクタとして使用
        """
        return cls(
            owner_name=data["owner"],
            stock=data["stock"]
        )
    
    @classmethod
    def change_tax_rate(cls, new_rate):
        """
        税率を変更（全店舗に影響）
        
        特徴:
        - クラス変数を変更
        - 全インスタンスに影響する
        """
        cls.tax_rate = new_rate
        print(f"📢 税率を{new_rate*100}%に変更しました")
    
    # ========================================
    # 3. スタティックメソッド
    # ========================================
    @staticmethod
    def calculate_total(quantity, price=150):
        """
        合計金額を計算（補助関数）
        
        特徴:
        - @staticmethod デコレーター必須
        - self も cls も不要
        - インスタンスやクラスのデータにアクセスしない
        - ただの関数だが、クラスに属する
        """
        return quantity * price
    
    @staticmethod
    def validate_stock(stock):
        """
        在庫数のバリデーション
        
        特徴:
        - 検証ロジックなど、独立した処理
        - クラスに関連するが、データは使わない
        """
        return isinstance(stock, int) and stock >= 0


# ========================================
# 使用例
# ========================================

# インスタンスメソッド
shop = DaifukuShop("うさうさ", 20)
shop.sell(5)  # インスタンスから呼ぶ

# クラスメソッド（インスタンス不要）
print(DaifukuShop.get_total_shops())  # クラスから直接呼べる

# ファクトリーメソッド
data = {"owner": "もちもち", "stock": 15}
shop2 = DaifukuShop.from_dict(data)

# スタティックメソッド（インスタンス不要）
total = DaifukuShop.calculate_total(10, 150)
print(f"合計: ¥{total}")
```

### ⚠️ メソッドの種類での注意点

#### 注意1: selfを忘れる
```python
class Shop:
    def sell(quantity):  # ❌ selfがない
        pass

# エラー: sell() takes 1 positional argument but 2 were given
```

#### 注意2: デコレーターを忘れる
```python
class Shop:
    # @classmethod を忘れている
    def get_total(cls):  # ❌ デコレーターなし
        return cls.total

# 呼び出すとエラー
```

#### 注意3: 間違ったメソッドタイプを選ぶ
```python
class Shop:
    @staticmethod
    def sell(self, quantity):  # ❌ staticなのにselfがある
        pass
```

### 🎯 使い分けの判断チャート

```
Q: このメソッドは何をする？

├─ インスタンスのデータを使う？
│  └─ YES → インスタンスメソッド（self）
│
├─ クラス全体に関わる処理？
│  ├─ インスタンスを作る？
│  │  └─ YES → クラスメソッド（@classmethod）
│  └─ クラス変数を操作？
│     └─ YES → クラスメソッド（@classmethod）
│
└─ インスタンスもクラスも使わない？
   └─ YES → スタティックメソッド（@staticmethod）
```

---

## 2. アクセス制御（public/private）

### 📖 Pythonのアクセス制御

**重要:** Pythonには厳密なprivate/protectedは存在しません！  
命名規則による「紳士協定」です。

### 🎯 3つのアクセスレベル

| 命名 | 意味 | アクセス | 例 |
|------|------|---------|-----|
| `name` | public（公開） | どこからでも | `self.stock` |
| `_name` | protected（保護） | クラス内と継承先 | `self._price` |
| `__name` | private（非公開） | クラス内のみ | `self.__secret` |

### 💻 実際のコード

```python
class DaifukuShop:
    """アクセス制御のデモ"""
    
    def __init__(self, owner_name, stock):
        # ========================================
        # public（公開変数）
        # ========================================
        self.owner_name = owner_name  # 外部からアクセスOK
        self.stock = stock            # 外部からアクセスOK
        
        # ========================================
        # protected（保護変数）
        # ========================================
        # 慣習: クラス内と継承先でのみ使用すべき
        # 技術的には外部からもアクセス可能
        self._base_price = 150        # 基本価格
        self._cost = 80               # 原価
        
        # ========================================
        # private（非公開変数）
        # ========================================
        # 慣習: クラス内でのみ使用すべき
        # 名前マングリングで外部からアクセスしにくくなる
        self.__secret_recipe = "特製餡の秘密"
        self.__profit_margin = 0.5    # 利益率
    
    # ========================================
    # public メソッド
    # ========================================
    def sell(self, quantity):
        """公開メソッド: 誰でも呼べる"""
        if not self._check_stock(quantity):  # protectedメソッドを呼ぶ
            return False
        
        self.stock -= quantity
        price = self._calculate_price(quantity)  # protectedメソッドを呼ぶ
        print(f"💰 {quantity}個販売: ¥{price}")
        return True
    
    # ========================================
    # protected メソッド
    # ========================================
    def _check_stock(self, quantity):
        """
        保護メソッド: クラス内と継承先で使用
        
        命名規則:
        - 先頭に _ を1つ付ける
        - 外部から呼ばないでほしいという意思表示
        - 技術的には呼べるが、呼ぶべきではない
        """
        if quantity > self.stock:
            print(f"❌ 在庫不足！")
            return False
        return True
    
    def _calculate_price(self, quantity):
        """
        保護メソッド: 価格計算
        
        継承先でオーバーライドすることを想定
        """
        return quantity * self._base_price
    
    # ========================================
    # private メソッド
    # ========================================
    def __calculate_profit(self, quantity):
        """
        非公開メソッド: クラス内でのみ使用
        
        命名規則:
        - 先頭に __ を2つ付ける
        - 名前マングリング（変換）が行われる
        - 外部から呼ぶのは非常に困難
        """
        revenue = quantity * self._base_price
        cost = quantity * self._cost
        return revenue - cost
    
    def show_profit(self, quantity):
        """公開メソッド: 利益を表示"""
        profit = self.__calculate_profit(quantity)  # privateメソッドを呼ぶ
        print(f"💵 {quantity}個の利益: ¥{profit}")


# ========================================
# アクセス制御のテスト
# ========================================

shop = DaifukuShop("うさうさ", 20)

# ========================================
# public: 問題なくアクセスできる
# ========================================
print(f"店長: {shop.owner_name}")  # ✅ OK
print(f"在庫: {shop.stock}")       # ✅ OK
shop.sell(5)                        # ✅ OK

# ========================================
# protected: アクセスできるが、すべきではない
# ========================================
print(f"基本価格: {shop._base_price}")  # ⚠️ 可能だが非推奨
shop._check_stock(10)                    # ⚠️ 可能だが非推奨

# ========================================
# private: アクセスは困難
# ========================================
# print(shop.__secret_recipe)  # ❌ エラー: AttributeError

# 名前マングリングで変換されている
print(shop._DaifukuShop__secret_recipe)  # 😈 技術的には可能だが、やるべきではない

# shop.__calculate_profit(5)  # ❌ エラー: AttributeError
```

### ⚠️ アクセス制御での注意点

#### 注意1: Pythonにはガチガチのprivateはない

```python
# 他の言語（Java等）: 完全にアクセス不可
# Python: 慣習的に「触らないでね」というだけ

class Shop:
    def __init__(self):
        self.__secret = "秘密"  # privateのつもり

shop = Shop()
# 技術的にはアクセス可能（名前マングリング）
print(shop._Shop__secret)  # "秘密" ← アクセスできてしまう
```

#### 注意2: _(アンダースコア1つ) は完全に慣習

```python
class Shop:
    def _internal_method(self):
        pass

# 何も防げない
shop = Shop()
shop._internal_method()  # 呼べてしまう（でも呼ぶべきではない）
```

#### 注意3: privateは継承先でも使えない

```python
class Parent:
    def __init__(self):
        self.__private = "秘密"
    
    def __private_method(self):
        return "秘密のメソッド"

class Child(Parent):
    def use_parent_private(self):
        print(self.__private)  # ❌ エラー！継承先でも使えない
        self.__private_method()  # ❌ エラー！
```

### 📊 アクセス制御のベストプラクティス

| 用途 | 使うべき | 理由 |
|------|---------|------|
| **外部API** | public | 利用者に使ってほしい |
| **内部実装** | protected `_` | 変更する可能性がある |
| **継承で使う** | protected `_` | 子クラスで使える |
| **絶対に隠したい** | private `__` | 名前の衝突を避ける |

### 💡 推奨パターン

```python
class DaifukuShop:
    """推奨されるアクセス制御パターン"""
    
    def __init__(self, owner_name):
        # public: 外部から使ってほしい
        self.owner_name = owner_name
        self.stock = 20
        
        # protected: 内部実装（変更する可能性あり）
        self._base_price = 150
        self._cost = 80
        
        # private: 本当に隠したい（名前衝突を避ける）
        self.__secret_key = "xyz123"
    
    # public API
    def sell(self, quantity):
        """外部から呼んでほしいメソッド"""
        return self._execute_sale(quantity)
    
    # protected: 継承先でカスタマイズできる
    def _execute_sale(self, quantity):
        """継承先でオーバーライド可能"""
        self.stock -= quantity
        return self._base_price * quantity
    
    # private: 絶対に触らせたくない
    def __encrypt_data(self, data):
        """内部でのみ使用する暗号化処理"""
        return data + self.__secret_key
```

---

## 3. 継承での注意点

### 📖 継承の基本ルール

継承は強力ですが、誤用すると複雑化します。

### ⚠️ 10の重要な注意点

#### 注意1: is-a関係が成り立つかチェック

```python
# ❌ 悪い例: 「車はエンジンである」は成り立たない
class Car(Engine):  # 間違った継承
    pass

# ✅ 良い例: 「車はエンジンを持つ」（コンポジション）
class Car:
    def __init__(self):
        self.engine = Engine()  # has-a関係
```

#### 注意2: 継承は浅く（2-3階層まで）

```python
# ❌ 悪い例: 深すぎる継承
class A:
    pass
class B(A):
    pass
class C(B):
    pass
class D(C):
    pass
class E(D):  # 5階層は深すぎる！
    pass

# ✅ 良い例: 浅い継承
class Shop:
    pass
class PremiumShop(Shop):  # 2階層で十分
    pass
```

#### 注意3: super()を忘れない

```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        # ❌ 悪い例: 親の初期化を忘れる
        self.age = age  # nameが初期化されない！
        
    # ✅ 良い例
    def __init__(self, name, age):
        super().__init__(name)  # 親を初期化
        self.age = age
```

#### 注意4: メソッド名の衝突

```python
class Parent:
    def process(self):
        print("親の処理")

class Child(Parent):
    def process(self):  # 親のメソッドを上書き
        print("子の処理")
        # 親の処理を呼びたい場合はsuper()を使う
        super().process()  # 親も呼ぶ
```

#### 注意5: 親のprivateメソッドは使えない

```python
class Parent:
    def __private_method(self):  # private
        return "秘密"

class Child(Parent):
    def use_parent(self):
        return self.__private_method()  # ❌ エラー！使えない
```

#### 注意6: 多重継承のMRO（メソッド解決順序）

```python
class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")

class C(A):
    def method(self):
        print("C")

class D(B, C):  # 多重継承
    pass

# MRO（解決順序）を確認
print(D.__mro__)
# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)

d = D()
d.method()  # "B" が出力される（MROの順番）
```

#### 注意7: コンストラクタの引数の変更

```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    # ❌ 悪い例: 引数を勝手に変更
    def __init__(self, name, age, address):  # 増やしすぎ
        super().__init__(name)
        self.age = age
        self.address = address

# ✅ 良い例: 最小限の追加
class Child(Parent):
    def __init__(self, name, age):  # 1つだけ追加
        super().__init__(name)
        self.age = age
```

#### 注意8: Liskovの置換原則

```python
# 親クラスを使える場所では、子クラスも使えるべき

class Bird:
    def fly(self):
        return "飛ぶ"

class Penguin(Bird):
    def fly(self):
        raise Exception("ペンギンは飛べない！")  # ❌ 原則違反

# 親クラスの動作を壊している
```

#### 注意9: 属性の追加は慎重に

```python
class Parent:
    def __init__(self):
        self.value = 10

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.value = 20  # 親の属性を上書き
        self.new_value = 30  # ✅ 新しい属性を追加

# 上書きは注意が必要
```

#### 注意10: 抽象メソッドの実装忘れ

```python
from abc import ABC, abstractmethod

class Shop(ABC):
    @abstractmethod
    def sell(self):
        """子クラスで必ず実装すること"""
        pass

class MyShop(Shop):
    pass  # ❌ sellを実装していない

# インスタンス化しようとするとエラー
# shop = MyShop()  # TypeError
```

### 💻 継承の良い例・悪い例

```python
# ========================================
# 悪い例
# ========================================

class BadExample1(list, dict):  # ❌ 意味のない多重継承
    pass

class BadExample2:
    """❌ 巨大な神クラス"""
    def method1(self): pass
    def method2(self): pass
    # ... 50個のメソッド
    def method50(self): pass

class BadExample3(Parent):
    """❌ 親のメソッドをすべてオーバーライド"""
    # 親の機能をほとんど使っていない
    # → 継承ではなくコンポジションを使うべき
    pass


# ========================================
# 良い例
# ========================================

class DaifukuShop:
    """✅ シンプルな親クラス"""
    def __init__(self, owner_name, stock):
        self.owner_name = owner_name
        self.stock = stock
    
    def sell(self, quantity):
        """基本的な販売処理"""
        if quantity > self.stock:
            return False
        self.stock -= quantity
        return True

class PremiumDaifukuShop(DaifukuShop):
    """✅ 明確なis-a関係"""
    def __init__(self, owner_name, stock, vip_count=0):
        super().__init__(owner_name, stock)  # 親を初期化
        self.vip_count = vip_count  # 子クラス固有の属性
    
    def sell(self, quantity, is_vip=False):
        """親のメソッドを拡張"""
        result = super().sell(quantity)  # 親の処理を呼ぶ
        if result and is_vip:
            print(f"VIP特典: ポイント2倍！")
        return result
```

---

## 4. メソッドのオーバーライド

### 📖 オーバーライドとは

親クラスのメソッドを子クラスで上書きすること。

### 🎯 オーバーライドのルール

1. メソッド名を同じにする
2. 引数の数を勝手に変えない（増やすのはOK）
3. 親の機能を壊さない
4. 必要なら`super()`で親を呼ぶ

### 💻 正しいオーバーライド

```python
class DaifukuShop:
    """親クラス"""
    
    def __init__(self, owner_name):
        self.owner_name = owner_name
        self.stock = 20
    
    def sell(self, quantity):
        """販売メソッド（基本）"""
        if quantity > self.stock:
            print("❌ 在庫不足")
            return False
        
        self.stock -= quantity
        price = quantity * 150
        print(f"💰 {quantity}個販売: ¥{price}")
        return True
    
    def show_info(self):
        """情報表示"""
        print(f"🏪 {self.owner_name}店長の店")
        print(f"📦 在庫: {self.stock}個")


class PremiumDaifukuShop(DaifukuShop):
    """子クラス"""
    
    def __init__(self, owner_name, vip_count=0):
        # ✅ 正しい: 親の初期化を呼ぶ
        super().__init__(owner_name)
        self.vip_count = vip_count
    
    # ========================================
    # パターン1: 完全に置き換える
    # ========================================
    def sell(self, quantity, discount=0):
        """
        販売メソッドを完全にオーバーライド
        親の処理を呼ばずに、独自実装
        """
        if quantity > self.stock:
            print("❌ 在庫不足")
            return False
        
        self.stock -= quantity
        price = quantity * 150 * (1 - discount)  # 割引機能追加
        print(f"✨ {quantity}個販売: ¥{int(price)} (割引{discount*100}%)")
        return True
    
    # ========================================
    # パターン2: 親の処理を拡張（推奨）
    # ========================================
    def show_info(self):
        """
        情報表示をオーバーライド
        親の処理を呼んでから、追加情報を表示
        """
        # 親の処理を実行
        super().show_info()
        
        # 追加情報を表示
        print(f"👑 VIP会員: {self.vip_count}名")


# 使用例
shop = PremiumDaifukuShop("うさうさ", vip_count=5)
shop.sell(3, discount=0.1)  # オーバーライドされたメソッド
shop.show_info()  # 親+子の処理
```

### ⚠️ オーバーライドの注意点

#### 注意1: 引数を減らさない

```python
class Parent:
    def method(self, a, b, c):
        pass

class Child(Parent):
    def method(self, a):  # ❌ 引数を減らしている
        pass

# 親クラスを期待するコードが壊れる
```

#### 注意2: 返り値の型を変えない

```python
class Parent:
    def get_value(self):
        return 10  # int を返す

class Child(Parent):
    def get_value(self):
        return "10"  # ❌ str を返している
```

#### 注意3: 例外の種類を変えない

```python
class Parent:
    def process(self):
        raise ValueError("エラー")

class Child(Parent):
    def process(self):
        raise TypeError("エラー")  # ❌ 例外の種類を変えている
```

---

## 5. super()の正しい使い方

### 📖 super()とは

親クラスのメソッドを呼び出すための関数。

### 🎯 super()の3つの用途

#### 用途1: コンストラクタで親を初期化

```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # 親を初期化
        self.age = age
```

#### 用途2: オーバーライドしたメソッドで親を呼ぶ

```python
class Parent:
    def greet(self):
        print("こんにちは")

class Child(Parent):
    def greet(self):
        super().greet()  # 親のgreetを呼ぶ
        print("私は子です")
```

#### 用途3: 多重継承でMROに従って呼ぶ

```python
class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")
        super().method()  # MROに従ってAを呼ぶ

class C(A):
    def method(self):
        print("C")
        super().method()

class D(B, C):
    def method(self):
        print("D")
        super().method()  # MRO: D → B → C → A

d = D()
d.method()
# 出力:
# D
# B
# C
# A
```

### ⚠️ super()の注意点

#### 注意1: super().__init__()を忘れる

```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, age):
        # super().__init__()を忘れている
        self.age = age

child = Child(10)
print(child.





#===================
#最後途切れ



# 🐰 デコレーターとメソッドの種類 完全ガイド

**ふわふわ大福店のうさうさ店長で学ぶ、ゼロからわかる実践的解説**

---

## 📚 目次

1. [そもそもデコレーターとは](#1-そもそもデコレーターとは)
2. [デコレーターの仕組み](#2-デコレーターの仕組み)
3. [3つのメソッド完全比較](#3-3つのメソッド完全比較)
4. [インスタンスメソッド詳細](#4-インスタンスメソッド詳細)
5. [クラスメソッド詳細](#5-クラスメソッド詳細)
6. [スタティックメソッド詳細](#6-スタティックメソッド詳細)
7. [使い分け判断フローチャート](#7-使い分け判断フローチャート)

---

## 1. そもそもデコレーターとは

### 📖 超シンプルな定義

**デコレーター = 関数やメソッドに「魔法」をかける記号**

`@` マークで始まる、関数の直前に書く特別な記法。

### 🎯 デコレーターの例え話

```
たい焼き屋での「ラッピング」

🥮 たい焼き（本体）
  ↓
📦 箱に入れる（デコレーター）
  ↓
🎀 リボンをつける（別のデコレーター）
  ↓
✨ 完成品（装飾された関数）

たい焼き自体は変わらないが、
見た目や機能が追加される！
```

### 💻 デコレーターの基本構文

```python
# デコレーターなし（普通の関数）
def hello():
    print("こんにちは")

hello()  # こんにちは

# ==========================================

# デコレーターあり
@some_decorator  # ← これがデコレーター
def hello():
    print("こんにちは")

# some_decorator が hello に「魔法」をかける
```

### 🔍 Pythonでよく使うデコレーター

| デコレーター | 何をする？ | 使う場面 |
|------------|----------|---------|
| `@property` | メソッドを属性のように使える | `obj.price` で呼べる |
| `@classmethod` | クラスメソッドに変換 | クラス全体の処理 |
| `@staticmethod` | スタティックメソッドに変換 | 補助関数 |
| `@abstractmethod` | 抽象メソッド（実装を強制） | 継承先で必ず実装 |
| `@dataclass` | データクラスを自動生成 | 簡単なクラス定義 |

---

## 2. デコレーターの仕組み

### 📖 デコレーターの正体

デコレーターは「関数を受け取って、新しい関数を返す関数」

### 💻 デコレーターの内部動作

```python
# ==========================================
# デコレーターの仕組みを理解する
# ==========================================

def my_decorator(func):
    """
    デコレーター本体
    
    引数:
        func: デコレートされる関数
    
    返り値:
        wrapper: 新しい関数
    """
    def wrapper(*args, **kwargs):
        """ラッパー関数（本体を包む）"""
        print("🎀 前処理: 関数の実行前")
        
        # 元の関数を実行
        result = func(*args, **kwargs)
        
        print("🎀 後処理: 関数の実行後")
        return result
    
    return wrapper


# ==========================================
# 使い方1: @を使う（推奨）
# ==========================================
@my_decorator
def greet(name):
    """挨拶する関数"""
    print(f"こんにちは、{name}さん！")

greet("うさうさ")

# 出力:
# 🎀 前処理: 関数の実行前
# こんにちは、うさうささん！
# 🎀 後処理: 関数の実行後


# ==========================================
# 使い方2: 手動で適用（@の正体）
# ==========================================
def greet2(name):
    print(f"こんにちは、{name}さん！")

# これは↑の @my_decorator と同じ意味
greet2 = my_decorator(greet2)

greet2("もちもち")
# 同じ出力が得られる


# ==========================================
# @記号は構文糖衣（シンタックスシュガー）
# ==========================================
# @my_decorator
# def func():
#     pass
#
# ↓ これと同じ意味
#
# def func():
#     pass
# func = my_decorator(func)
```

### 🎯 デコレーターの実用例

```python
# ==========================================
# 例1: 実行時間を測定するデコレーター
# ==========================================
import time

def measure_time(func):
    """実行時間を測定"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"⏱️ 実行時間: {end - start:.4f}秒")
        return result
    return wrapper

@measure_time
def slow_function():
    """重い処理"""
    time.sleep(1)
    print("処理完了")

slow_function()
# 出力:
# 処理完了
# ⏱️ 実行時間: 1.0012秒


# ==========================================
# 例2: ログを記録するデコレーター
# ==========================================
def log_function(func):
    """関数の呼び出しをログに記録"""
    def wrapper(*args, **kwargs):
        print(f"📝 関数 {func.__name__} を呼び出し")
        print(f"   引数: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"   結果: {result}")
        return result
    return wrapper

@log_function
def add(a, b):
    return a + b

add(5, 3)
# 出力:
# 📝 関数 add を呼び出し
#    引数: (5, 3), {}
#    結果: 8


# ==========================================
# 例3: 認証チェックをするデコレーター
# ==========================================
def require_auth(func):
    """認証が必要な処理"""
    def wrapper(self, *args, **kwargs):
        if not hasattr(self, 'is_authenticated') or not self.is_authenticated:
            print("❌ 認証されていません")
            return None
        return func(self, *args, **kwargs)
    return wrapper

class Shop:
    def __init__(self):
        self.is_authenticated = False
    
    @require_auth
    def sell(self, quantity):
        """認証が必要な販売処理"""
        print(f"✅ {quantity}個販売しました")

shop = Shop()
shop.sell(5)  # ❌ 認証されていません

shop.is_authenticated = True
shop.sell(5)  # ✅ 5個販売しました
```

### ⚠️ デコレーターの注意点

```python
# 注意1: デコレーターの順番は重要
@decorator1
@decorator2
def func():
    pass

# これは以下と同じ:
# func = decorator1(decorator2(func))
# 下から順番に適用される！


# 注意2: 複数のデコレーターを重ねられる
@log_function
@measure_time
def process():
    time.sleep(0.5)
    print("処理中")

# まずmeasure_timeが適用され、次にlog_functionが適用される


# 注意3: functools.wraps を使うべき
from functools import wraps

def my_decorator(func):
    @wraps(func)  # ← これを付けないと、元の関数の情報が失われる
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

---

## 3. 3つのメソッド完全比較

### 📊 一覧比較表

| 項目 | インスタンスメソッド | クラスメソッド | スタティックメソッド |
|------|-------------------|--------------|-------------------|
| **デコレーター** | なし | `@classmethod` | `@staticmethod` |
| **第一引数** | `self`（自分） | `cls`（クラス） | なし（自由） |
| **呼び出し方** | `obj.method()` | `Class.method()` | `Class.method()` |
| **インスタンス変数** | ✅ 使える | ❌ 使えない | ❌ 使えない |
| **クラス変数** | ✅ 使える | ✅ 使える | ❌ 使えない |
| **インスタンス必要？** | ✅ 必要 | ❌ 不要 | ❌ 不要 |
| **用途** | 個別の処理 | クラス全体の処理 | 補助関数 |
| **例** | 在庫を減らす | 統計を取る | 税額を計算 |

### 💻 3つのメソッドを一度に見る

```python
class DaifukuShop:
    """
    大福店クラス
    3つのメソッドの違いを理解する
    """
    
    # ========================================
    # クラス変数（全店舗共通）
    # ========================================
    total_shops = 0    # 総店舗数
    base_price = 150   # 基本価格
    tax_rate = 0.10    # 消費税率
    
    def __init__(self, owner_name, stock):
        """コンストラクタ"""
        # ========================================
        # インスタンス変数（各店舗個別）
        # ========================================
        self.owner_name = owner_name  # 店長名
        self.stock = stock            # 在庫数
        self.sold = 0                 # 販売数
        
        # クラス変数を更新
        DaifukuShop.total_shops += 1
    
    # ========================================
    # 1️⃣ インスタンスメソッド（デコレーターなし）
    # ========================================
    def sell(self, quantity):
        """
        販売処理（個別の店舗の処理）
        
        特徴:
        - デコレーターなし
        - 第一引数は self（必須）
        - self.xxx でインスタンス変数にアクセス
        - この店舗の在庫を減らす
        """
        # インスタンス変数を使う
        if quantity > self.stock:
            print(f"❌ {self.owner_name}店長: 在庫不足！")
            return False
        
        # インスタンス変数を変更
        self.stock -= quantity
        self.sold += quantity
        
        # クラス変数も使える
        price = quantity * DaifukuShop.base_price
        
        print(f"💰 {self.owner_name}店長: {quantity}個販売（¥{price}）")
        return True
    
    def show_status(self):
        """この店舗の状態を表示"""
        print(f"\n{'='*40}")
        print(f"🏪 {self.owner_name}店長の店")
        print(f"📦 在庫: {self.stock}個")
        print(f"💰 累計販売: {self.sold}個")
        print(f"{'='*40}\n")
    
    # ========================================
    # 2️⃣ クラスメソッド（@classmethod）
    # ========================================
    @classmethod
    def get_stats(cls):
        """
        全店舗の統計（クラス全体の処理）
        
        特徴:
        - @classmethod デコレーター必須
        - 第一引数は cls（クラス自身）
        - cls.xxx でクラス変数にアクセス
        - インスタンスを作らずに呼べる
        """
        # クラス変数にアクセス
        return f"📊 総店舗数: {cls.total_shops}店"
    
    @classmethod
    def from_dict(cls, data):
        """
        辞書からインスタンスを生成（ファクトリーメソッド）
        
        特徴:
        - 代替コンストラクタ
        - cls() でインスタンスを作成
        - 別の方法でオブジェクトを作れる
        """
        # cls() はクラス名() と同じ
        return cls(
            owner_name=data["owner"],
            stock=data.get("stock", 10)
        )
    
    @classmethod
    def change_price(cls, new_price):
        """
        基本価格を変更（全店舗に影響）
        
        特徴:
        - クラス変数を変更
        - すべてのインスタンスに影響する
        """
        cls.base_price = new_price
        print(f"📢 基本価格を¥{new_price}に変更しました")
    
    # ========================================
    # 3️⃣ スタティックメソッド（@staticmethod）
    # ========================================
    @staticmethod
    def calculate_tax(price):
        """
        税込価格を計算（補助関数）
        
        特徴:
        - @staticmethod デコレーター必須
        - 第一引数なし（self も cls も不要）
        - インスタンス変数もクラス変数も使わない
        - 純粋な計算処理
        - インスタンスを作らずに呼べる
        """
        # 引数だけを使う
        return int(price * 1.1)
    
    @staticmethod
    def validate_stock(stock):
        """
        在庫数のバリデーション（検証）
        
        特徴:
        - インスタンスに依存しない検証
        - インスタンス作成前にチェックできる
        """
        return isinstance(stock, int) and stock >= 0
    
    @staticmethod
    def format_price(price):
        """
        価格をフォーマット（文字列整形）
        
        特徴:
        - 単純な変換処理
        - ユーティリティ関数
        """
        return f"¥{price:,}"


# ==========================================
# 使い方の違いを実演
# ==========================================

print("="*60)
print("3つのメソッドの使い方の違い")
print("="*60)

# ========================================
# 1️⃣ インスタンスメソッド: インスタンスから呼ぶ
# ========================================
print("\n【1️⃣ インスタンスメソッド】")
shop = DaifukuShop("うさうさ", 20)
shop.sell(5)         # インスタンスから呼ぶ
shop.show_status()   # この店舗の情報

# ========================================
# 2️⃣ クラスメソッド: クラスから呼べる
# ========================================
print("\n【2️⃣ クラスメソッド】")

# インスタンス不要で呼べる
print(DaifukuShop.get_stats())

# ファクトリーメソッド
data = {"owner": "もちもち", "stock": 15}
shop2 = DaifukuShop.from_dict(data)
print(DaifukuShop.get_stats())  # 店舗数が増えた

# 全店舗に影響
DaifukuShop.change_price(180)

# ========================================
# 3️⃣ スタティックメソッド: クラスから呼べる
# ========================================
print("\n【3️⃣ スタティックメソッド】")

# インスタンス不要で呼べる
price = 1000
tax_price = DaifukuShop.calculate_tax(price)
print(f"税込価格: {DaifukuShop.format_price(tax_price)}")

# バリデーション（インスタンス作成前）
is_valid = DaifukuShop.validate_stock(20)
print(f"在庫数20は有効？ {is_valid}")

is_valid = DaifukuShop.validate_stock(-5)
print(f"在庫数-5は有効？ {is_valid}")
```

### 🎯 動作の違いを図解

```
┌────────────────────────────────────────┐
│ DaifukuShop クラス                      │
├────────────────────────────────────────┤
│ クラス変数:                             │
│  - total_shops = 2                     │
│  - base_price = 150                    │
│  - tax_rate = 0.10                     │
├────────────────────────────────────────┤
│ メソッド:                               │
│                                         │
│ インスタンスメソッド sell(self, qty)    │
│  ├─ self.stock にアクセス              │
│  └─ インスタンスが必要 ✅               │
│                                         │
│ @classmethod get_stats(cls)            │
│  ├─ cls.total_shops にアクセス         │
│  └─ インスタンス不要 ❌                 │
│                                         │
│ @staticmethod calculate_tax(price)     │
│  ├─ 引数だけ使う                        │
│  └─ インスタンス不要 ❌                 │
└────────────────────────────────────────┘
         │                    │
         ↓                    ↓
  ┌──────────┐        ┌──────────┐
  │ shop1    │        │ shop2    │
  ├──────────┤        ├──────────┤
  │ owner:   │        │ owner:   │
  │ うさうさ  │        │ もちもち  │
  │ stock: 15│        │ stock: 12│
  └──────────┘        └──────────┘
```

---

## 4. インスタンスメソッド詳細

### 📖 定義

**インスタンスメソッド = 各オブジェクト（インスタンス）の処理**

### 🎯 特徴5つ

1. **デコレーター不要**（何も付けない）
2. **第一引数は self**（必須）
3. **インスタンス変数にアクセス可能**
4. **クラス変数にもアクセス可能**
5. **最も一般的なメソッド**

### 💻 詳細な例

```python
class DaifukuShop:
    """インスタンスメソッドの詳細"""
    
    # クラス変数
    base_price = 150
    
    def __init__(self, owner_name, stock):
        # インスタンス変数
        self.owner_name = owner_name
        self.stock = stock
        self.sold = 0
        self.revenue = 0
    
    # ========================================
    # インスタンスメソッド
    # ========================================
    
    def sell(self, quantity):
        """
        販売処理
        
        selfで何ができる？
        - self.xxx でインスタンス変数にアクセス
        - self.method() で他のメソッドを呼ぶ
        - ClassName.xxx でクラス変数にアクセス
        """
        # 1. インスタンス変数を参照
        if quantity > self.stock:
            return False
        
        # 2. インスタンス変数を変更
        self.stock -= quantity
        self.sold += quantity
        
        # 3. クラス変数を参照
        price = quantity * DaifukuShop.base_price
        
        # 4. インスタンス変数を更新
        self.revenue += price
        
        # 5. 他のインスタンスメソッドを呼ぶ
        self._log_sale(quantity, price)
        
        return True
    
    def _log_sale(self, quantity, price):
        """
        内部メソッド（protected）
        
        _（アンダースコア）で始まる = 内部用
        """
        print(f"📝 {self.owner_name}店長: {quantity}個販売（¥{price}）")
    
    def get_profit_rate(self):
        """
        利益率を計算
        
        インスタンスメソッドは:
        - この店舗のデータを使う
        - 計算結果を返す
        """
        if self.revenue == 0:
            return 0.0
        
        cost = self.sold * 80  # 原価80円と仮定
        profit = self.revenue - cost
        return (profit / self.revenue) * 100
    
    def transfer_stock(self, other_shop, quantity):
        """
        他の店舗に在庫を譲渡
        
        インスタンスメソッドは:
        - 自分（self）のデータを操作
        - 他のインスタンス（other_shop）も操作できる
        """
        if quantity > self.stock:
            print("❌ 在庫不足")
            return False
        
        # 自分の在庫を減らす
        self.stock -= quantity
        
        # 相手の在庫を増やす
        other_shop.stock += quantity
        
        print(f"📦 {self.owner_name} → {other_shop.owner_name}: {quantity}個譲渡")
        return True


# 使用例
shop1 = DaifukuShop("うさうさ", 20)
shop2 = DaifukuShop("もちもち", 10)

shop1.sell(5)
print(f"利益率: {shop1.get_profit_rate():.1f}%")

shop1.transfer_stock(shop2, 5)
print(f"うさうさ店: {shop1.stock}個")
print(f"もちもち店: {shop2.stock}個")
```

### ⚠️ インスタンスメソッドの注意点

```python
class Shop:
    def sell(quantity):  # ❌ selfを忘れている
        pass

shop = Shop()
# shop.sell(5)  # エラー！

# 正しくは:
class Shop:
    def sell(self, quantity):  # ✅ selfが必要
        pass
```

---

## 5. クラスメソッド詳細

### 📖 定義

**クラスメソッド = クラス全体に関わる処理**

### 🎯 特徴5つ

1. **@classmethod デコレーター必須**
2. **第一引数は cls**（クラス自身）
3. **クラス変数にアクセス可能**
4. **インスタンス不要で呼べる**
5. **ファクトリーメソッドに最適**

### 💻 詳細な例

```python
class DaifukuShop:
    """クラスメソッドの詳細"""
    
    # クラス変数
    total_shops = 0
    total_revenue = 0
    company_name = "ふわふわ大福株式会社"
    
    def __init__(self, owner_name, stock):
        self.owner_name = owner_name
        self.stock = stock
        
        # クラス変数を更新
        DaifukuShop.total_shops += 1
    
    # ========================================
    # クラスメソッド
    # ========================================
    
    @classmethod
    def get_company_info(cls):
        """
        会社情報を取得
        
        clsで何ができる？
        - cls.xxx でクラス変数にアクセス
        - cls() でインスタンスを作成
        - cls.method() で他のクラスメソッドを呼ぶ
        """
        return f"{cls.company_name}（店舗数: {cls.total_shops}店）"
    
    @classmethod
    def from_dict(cls, data):
        """
        辞書からインスタンスを作成（ファクトリーメソッド）
        
        用途:
        - JSONデータからオブジェクト生成
        - 別の形式からの変換
        - 代替コンストラクタ
        """
        return cls(
            owner_name=data["owner"],
            stock=data.get("stock", 10)
        )
    
    @classmethod
    def from_csv(cls, csv_line):
        """
        CSV行からインスタンスを作成
        
        クラスメソッドは:
        - 様々な形式からインスタンスを作れる
        - __init__とは違う作り方を提供
        """
        parts = csv_line.split(',')
        return cls(
            owner_name=parts[0].strip(),
            stock=int(parts[1].strip())
        )
    
    @classmethod
    def create_franchise(cls, owner_name):
        """
        フランチャイズ店舗を作成
        
        クラスメソッドは:
        - 標準的な設定でインスタンスを作る
        - ビジネスロジックを含む
        """
        print(f"🏪 {owner_name}様、フランチャイズ契約ありがとうございます！")
        return cls(owner_name, stock=20)  # 標準在庫20個
    
    @classmethod
    def get_total_revenue(cls):
        """
        全店舗の総売上を取得
        
        クラスメソッドは:
        - クラス全体の統計を取る
        - すべてのインスタンスに関わる情報
        """
        return f"総売上: ¥{cls.total_revenue:,}"
    
    @classmethod
    def reset_stats(cls):
        """
        統計をリセット
        
        クラスメソッドは:
        - クラス変数を変更できる
        - 全インスタンスに影響する
        """
        cls.total_shops = 0
        cls.total_revenue = 0
        print("📊 統計をリセットしました")


# ========================================
# 使用例
# ========================================

# インスタンスを作らずに呼べる
print(DaifukuShop.get_company_info())

# ファクトリーメソッド（様々な形式から作成）
data = {"owner": "うさうさ", "stock": 25}
shop1 = DaifukuShop.from_dict(data)

csv = "もちもち,15"
shop2 = DaifukuShop.from_csv(csv)

shop3 = DaifukuShop.create_franchise("ぴょんぴょん")

# 統計情報
print(DaifukuShop.get_company_info())
```

### ⚠️ クラスメソッドの注意点

```python
class Shop:
    # @classmethod を忘れている
    def get_total(cls):  # ❌ デコレーターなし
        return cls.total

# Shop.get_total()  # エラー！

# 正しくは:
class Shop:
    @classmethod  # ✅ デコレーター必須
    def get_total(cls):
        return cls.total
```

---

## 6. スタティックメソッド詳細

### 📖 定義

**スタティックメソッド = クラスに属する補助関数**

### 🎯 特徴5つ

1. **@staticmethod デコレーター必須**
2. **第一引数なし**（self も cls も不要）
3. **インスタンス変数もクラス変数も使わない**
4. **純粋な計算・変換処理**
5. **名前空間の整理に便利**

### 💻 詳細な例

```python
class DaifukuShop:
    """スタティックメ
