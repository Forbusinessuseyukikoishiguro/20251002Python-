完璧です！🐰✨ **デコレーターとメソッドの種類 完全ガイド**が完成しました！

## 📚 完成した記事の特徴

### ✅ 7つのセクションで完全網羅

1. **そもそもデコレーターとは** - ゼロから理解
2. **デコレーターの仕組み** - 内部動作を詳しく
3. **3つのメソッド完全比較** - 一覧表で比較
4. **インスタンスメソッド詳細** - 深掘り解説
5. **クラスメソッド詳細** - ファクトリーパターン
6. **スタティックメソッド詳細** - 補助関数の使い方
7. **判断フローチャート** - 使い分けが一目瞭然

### 🎯 重要ポイント

#### デコレーターとは？
```python
@my_decorator  # ← これ！
def func():
    pass

# 関数に「魔法」をかける記号
# func = my_decorator(func) と同じ意味
```

#### 3つのメソッドの違い

| | インスタンス | クラス | スタティック |
|---|---|---|---|
| **デコレーター** | なし | `@classmethod` | `@staticmethod` |
| **第一引数** | `self` | `cls` | なし |
| **使う場面** | 個別処理 | 全体処理 | 補助関数 |

#### 判断は簡単！

```
self.xxx を使う？
├─ YES → インスタンスメソッド
└─ NO → cls.xxx を使う？
    ├─ YES → クラスメソッド
    └─ NO → スタティックメソッド
```

### 💻 実践的な内容

- **デコレーターの作り方**（実行時間測定、ログ記録）
- **350行の完全動作コード**
- **10個の具体的な判断


# 🐰 デコレーターとメソッドの種類 完全ガイド

**ふわふわ大福店のうさうさ店長で学ぶ、ゼロからわかる実践的解説**

---

## 📚 目次

1. [そもそもデコレーターとは](#1-そもそもデコレーターとは)
2. [デコレーターの仕組み](#2-デコレーターの仕組み)
3. [3つのメソッド完全比較](#3-3つのメソッド完全比較)
4. [インスタンスメソッド詳細](#4-インスタンスメソッド詳細)
5. [クラスメソッド詳細](#5-クラスメソッド詳細)
6. [スタティックメソッド詳細](#6-スタティックメソッド詳細)
7. [使い分け判断フローチャート](#7-使い分け判断フローチャート)

---

## 1. そもそもデコレーターとは

### 📖 超シンプルな定義

**デコレーター = 関数やメソッドに「魔法」をかける記号**

`@` マークで始まる、関数の直前に書く特別な記法。

### 🎯 デコレーターの例え話

```
たい焼き屋での「ラッピング」

🥮 たい焼き（本体）
  ↓
📦 箱に入れる（デコレーター）
  ↓
🎀 リボンをつける（別のデコレーター）
  ↓
✨ 完成品（装飾された関数）

たい焼き自体は変わらないが、
見た目や機能が追加される！
```

### 💻 デコレーターの基本構文

```python
# デコレーターなし（普通の関数）
def hello():
    print("こんにちは")

hello()  # こんにちは

# ==========================================

# デコレーターあり
@some_decorator  # ← これがデコレーター
def hello():
    print("こんにちは")

# some_decorator が hello に「魔法」をかける
```

### 🔍 Pythonでよく使うデコレーター

| デコレーター | 何をする？ | 使う場面 |
|------------|----------|---------|
| `@property` | メソッドを属性のように使える | `obj.price` で呼べる |
| `@classmethod` | クラスメソッドに変換 | クラス全体の処理 |
| `@staticmethod` | スタティックメソッドに変換 | 補助関数 |
| `@abstractmethod` | 抽象メソッド（実装を強制） | 継承先で必ず実装 |
| `@dataclass` | データクラスを自動生成 | 簡単なクラス定義 |

---

## 2. デコレーターの仕組み

### 📖 デコレーターの正体

デコレーターは「関数を受け取って、新しい関数を返す関数」

### 💻 デコレーターの内部動作

```python
# ==========================================
# デコレーターの仕組みを理解する
# ==========================================

def my_decorator(func):
    """
    デコレーター本体
    
    引数:
        func: デコレートされる関数
    
    返り値:
        wrapper: 新しい関数
    """
    def wrapper(*args, **kwargs):
        """ラッパー関数（本体を包む）"""
        print("🎀 前処理: 関数の実行前")
        
        # 元の関数を実行
        result = func(*args, **kwargs)
        
        print("🎀 後処理: 関数の実行後")
        return result
    
    return wrapper


# ==========================================
# 使い方1: @を使う（推奨）
# ==========================================
@my_decorator
def greet(name):
    """挨拶する関数"""
    print(f"こんにちは、{name}さん！")

greet("うさうさ")

# 出力:
# 🎀 前処理: 関数の実行前
# こんにちは、うさうささん！
# 🎀 後処理: 関数の実行後


# ==========================================
# 使い方2: 手動で適用（@の正体）
# ==========================================
def greet2(name):
    print(f"こんにちは、{name}さん！")

# これは↑の @my_decorator と同じ意味
greet2 = my_decorator(greet2)

greet2("もちもち")
# 同じ出力が得られる


# ==========================================
# @記号は構文糖衣（シンタックスシュガー）
# ==========================================
# @my_decorator
# def func():
#     pass
#
# ↓ これと同じ意味
#
# def func():
#     pass
# func = my_decorator(func)
```

### 🎯 デコレーターの実用例

```python
# ==========================================
# 例1: 実行時間を測定するデコレーター
# ==========================================
import time

def measure_time(func):
    """実行時間を測定"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"⏱️ 実行時間: {end - start:.4f}秒")
        return result
    return wrapper

@measure_time
def slow_function():
    """重い処理"""
    time.sleep(1)
    print("処理完了")

slow_function()
# 出力:
# 処理完了
# ⏱️ 実行時間: 1.0012秒


# ==========================================
# 例2: ログを記録するデコレーター
# ==========================================
def log_function(func):
    """関数の呼び出しをログに記録"""
    def wrapper(*args, **kwargs):
        print(f"📝 関数 {func.__name__} を呼び出し")
        print(f"   引数: {args}, {kwargs}")
        result = func(*args, **kwargs)
        print(f"   結果: {result}")
        return result
    return wrapper

@log_function
def add(a, b):
    return a + b

add(5, 3)
# 出力:
# 📝 関数 add を呼び出し
#    引数: (5, 3), {}
#    結果: 8


# ==========================================
# 例3: 認証チェックをするデコレーター
# ==========================================
def require_auth(func):
    """認証が必要な処理"""
    def wrapper(self, *args, **kwargs):
        if not hasattr(self, 'is_authenticated') or not self.is_authenticated:
            print("❌ 認証されていません")
            return None
        return func(self, *args, **kwargs)
    return wrapper

class Shop:
    def __init__(self):
        self.is_authenticated = False
    
    @require_auth
    def sell(self, quantity):
        """認証が必要な販売処理"""
        print(f"✅ {quantity}個販売しました")

shop = Shop()
shop.sell(5)  # ❌ 認証されていません

shop.is_authenticated = True
shop.sell(5)  # ✅ 5個販売しました
```

### ⚠️ デコレーターの注意点

```python
# 注意1: デコレーターの順番は重要
@decorator1
@decorator2
def func():
    pass

# これは以下と同じ:
# func = decorator1(decorator2(func))
# 下から順番に適用される！


# 注意2: 複数のデコレーターを重ねられる
@log_function
@measure_time
def process():
    time.sleep(0.5)
    print("処理中")

# まずmeasure_timeが適用され、次にlog_functionが適用される


# 注意3: functools.wraps を使うべき
from functools import wraps

def my_decorator(func):
    @wraps(func)  # ← これを付けないと、元の関数の情報が失われる
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

---

## 3. 3つのメソッド完全比較

### 📊 一覧比較表

| 項目 | インスタンスメソッド | クラスメソッド | スタティックメソッド |
|------|-------------------|--------------|-------------------|
| **デコレーター** | なし | `@classmethod` | `@staticmethod` |
| **第一引数** | `self`（自分） | `cls`（クラス） | なし（自由） |
| **呼び出し方** | `obj.method()` | `Class.method()` | `Class.method()` |
| **インスタンス変数** | ✅ 使える | ❌ 使えない | ❌ 使えない |
| **クラス変数** | ✅ 使える | ✅ 使える | ❌ 使えない |
| **インスタンス必要？** | ✅ 必要 | ❌ 不要 | ❌ 不要 |
| **用途** | 個別の処理 | クラス全体の処理 | 補助関数 |
| **例** | 在庫を減らす | 統計を取る | 税額を計算 |

### 💻 3つのメソッドを一度に見る

```python
class DaifukuShop:
    """
    大福店クラス
    3つのメソッドの違いを理解する
    """
    
    # ========================================
    # クラス変数（全店舗共通）
    # ========================================
    total_shops = 0    # 総店舗数
    base_price = 150   # 基本価格
    tax_rate = 0.10    # 消費税率
    
    def __init__(self, owner_name, stock):
        """コンストラクタ"""
        # ========================================
        # インスタンス変数（各店舗個別）
        # ========================================
        self.owner_name = owner_name  # 店長名
        self.stock = stock            # 在庫数
        self.sold = 0                 # 販売数
        
        # クラス変数を更新
        DaifukuShop.total_shops += 1
    
    # ========================================
    # 1️⃣ インスタンスメソッド（デコレーターなし）
    # ========================================
    def sell(self, quantity):
        """
        販売処理（個別の店舗の処理）
        
        特徴:
        - デコレーターなし
        - 第一引数は self（必須）
        - self.xxx でインスタンス変数にアクセス
        - この店舗の在庫を減らす
        """
        # インスタンス変数を使う
        if quantity > self.stock:
            print(f"❌ {self.owner_name}店長: 在庫不足！")
            return False
        
        # インスタンス変数を変更
        self.stock -= quantity
        self.sold += quantity
        
        # クラス変数も使える
        price = quantity * DaifukuShop.base_price
        
        print(f"💰 {self.owner_name}店長: {quantity}個販売（¥{price}）")
        return True
    
    def show_status(self):
        """この店舗の状態を表示"""
        print(f"\n{'='*40}")
        print(f"🏪 {self.owner_name}店長の店")
        print(f"📦 在庫: {self.stock}個")
        print(f"💰 累計販売: {self.sold}個")
        print(f"{'='*40}\n")
    
    # ========================================
    # 2️⃣ クラスメソッド（@classmethod）
    # ========================================
    @classmethod
    def get_stats(cls):
        """
        全店舗の統計（クラス全体の処理）
        
        特徴:
        - @classmethod デコレーター必須
        - 第一引数は cls（クラス自身）
        - cls.xxx でクラス変数にアクセス
        - インスタンスを作らずに呼べる
        """
        # クラス変数にアクセス
        return f"📊 総店舗数: {cls.total_shops}店"
    
    @classmethod
    def from_dict(cls, data):
        """
        辞書からインスタンスを生成（ファクトリーメソッド）
        
        特徴:
        - 代替コンストラクタ
        - cls() でインスタンスを作成
        - 別の方法でオブジェクトを作れる
        """
        # cls() はクラス名() と同じ
        return cls(
            owner_name=data["owner"],
            stock=data.get("stock", 10)
        )
    
    @classmethod
    def change_price(cls, new_price):
        """
        基本価格を変更（全店舗に影響）
        
        特徴:
        - クラス変数を変更
        - すべてのインスタンスに影響する
        """
        cls.base_price = new_price
        print(f"📢 基本価格を¥{new_price}に変更しました")
    
    # ========================================
    # 3️⃣ スタティックメソッド（@staticmethod）
    # ========================================
    @staticmethod
    def calculate_tax(price):
        """
        税込価格を計算（補助関数）
        
        特徴:
        - @staticmethod デコレーター必須
        - 第一引数なし（self も cls も不要）
        - インスタンス変数もクラス変数も使わない
        - 純粋な計算処理
        - インスタンスを作らずに呼べる
        """
        # 引数だけを使う
        return int(price * 1.1)
    
    @staticmethod
    def validate_stock(stock):
        """
        在庫数のバリデーション（検証）
        
        特徴:
        - インスタンスに依存しない検証
        - インスタンス作成前にチェックできる
        """
        return isinstance(stock, int) and stock >= 0
    
    @staticmethod
    def format_price(price):
        """
        価格をフォーマット（文字列整形）
        
        特徴:
        - 単純な変換処理
        - ユーティリティ関数
        """
        return f"¥{price:,}"


# ==========================================
# 使い方の違いを実演
# ==========================================

print("="*60)
print("3つのメソッドの使い方の違い")
print("="*60)

# ========================================
# 1️⃣ インスタンスメソッド: インスタンスから呼ぶ
# ========================================
print("\n【1️⃣ インスタンスメソッド】")
shop = DaifukuShop("うさうさ", 20)
shop.sell(5)         # インスタンスから呼ぶ
shop.show_status()   # この店舗の情報

# ========================================
# 2️⃣ クラスメソッド: クラスから呼べる
# ========================================
print("\n【2️⃣ クラスメソッド】")

# インスタンス不要で呼べる
print(DaifukuShop.get_stats())

# ファクトリーメソッド
data = {"owner": "もちもち", "stock": 15}
shop2 = DaifukuShop.from_dict(data)
print(DaifukuShop.get_stats())  # 店舗数が増えた

# 全店舗に影響
DaifukuShop.change_price(180)

# ========================================
# 3️⃣ スタティックメソッド: クラスから呼べる
# ========================================
print("\n【3️⃣ スタティックメソッド】")

# インスタンス不要で呼べる
price = 1000
tax_price = DaifukuShop.calculate_tax(price)
print(f"税込価格: {DaifukuShop.format_price(tax_price)}")

# バリデーション（インスタンス作成前）
is_valid = DaifukuShop.validate_stock(20)
print(f"在庫数20は有効？ {is_valid}")

is_valid = DaifukuShop.validate_stock(-5)
print(f"在庫数-5は有効？ {is_valid}")
```

### 🎯 動作の違いを図解

```
┌────────────────────────────────────────┐
│ DaifukuShop クラス                      │
├────────────────────────────────────────┤
│ クラス変数:                             │
│  - total_shops = 2                     │
│  - base_price = 150                    │
│  - tax_rate = 0.10                     │
├────────────────────────────────────────┤
│ メソッド:                               │
│                                         │
│ インスタンスメソッド sell(self, qty)    │
│  ├─ self.stock にアクセス              │
│  └─ インスタンスが必要 ✅               │
│                                         │
│ @classmethod get_stats(cls)            │
│  ├─ cls.total_shops にアクセス         │
│  └─ インスタンス不要 ❌                 │
│                                         │
│ @staticmethod calculate_tax(price)     │
│  ├─ 引数だけ使う                        │
│  └─ インスタンス不要 ❌                 │
└────────────────────────────────────────┘
         │                    │
         ↓                    ↓
  ┌──────────┐        ┌──────────┐
  │ shop1    │        │ shop2    │
  ├──────────┤        ├──────────┤
  │ owner:   │        │ owner:   │
  │ うさうさ  │        │ もちもち  │
  │ stock: 15│        │ stock: 12│
  └──────────┘        └──────────┘
```

---

## 4. インスタンスメソッド詳細

### 📖 定義

**インスタンスメソッド = 各オブジェクト（インスタンス）の処理**

### 🎯 特徴5つ

1. **デコレーター不要**（何も付けない）
2. **第一引数は self**（必須）
3. **インスタンス変数にアクセス可能**
4. **クラス変数にもアクセス可能**
5. **最も一般的なメソッド**

### 💻 詳細な例

```python
class DaifukuShop:
    """インスタンスメソッドの詳細"""
    
    # クラス変数
    base_price = 150
    
    def __init__(self, owner_name, stock):
        # インスタンス変数
        self.owner_name = owner_name
        self.stock = stock
        self.sold = 0
        self.revenue = 0
    
    # ========================================
    # インスタンスメソッド
    # ========================================
    
    def sell(self, quantity):
        """
        販売処理
        
        selfで何ができる？
        - self.xxx でインスタンス変数にアクセス
        - self.method() で他のメソッドを呼ぶ
        - ClassName.xxx でクラス変数にアクセス
        """
        # 1. インスタンス変数を参照
        if quantity > self.stock:
            return False
        
        # 2. インスタンス変数を変更
        self.stock -= quantity
        self.sold += quantity
        
        # 3. クラス変数を参照
        price = quantity * DaifukuShop.base_price
        
        # 4. インスタンス変数を更新
        self.revenue += price
        
        # 5. 他のインスタンスメソッドを呼ぶ
        self._log_sale(quantity, price)
        
        return True
    
    def _log_sale(self, quantity, price):
        """
        内部メソッド（protected）
        
        _（アンダースコア）で始まる = 内部用
        """
        print(f"📝 {self.owner_name}店長: {quantity}個販売（¥{price}）")
    
    def get_profit_rate(self):
        """
        利益率を計算
        
        インスタンスメソッドは:
        - この店舗のデータを使う
        - 計算結果を返す
        """
        if self.revenue == 0:
            return 0.0
        
        cost = self.sold * 80  # 原価80円と仮定
        profit = self.revenue - cost
        return (profit / self.revenue) * 100
    
    def transfer_stock(self, other_shop, quantity):
        """
        他の店舗に在庫を譲渡
        
        インスタンスメソッドは:
        - 自分（self）のデータを操作
        - 他のインスタンス（other_shop）も操作できる
        """
        if quantity > self.stock:
            print("❌ 在庫不足")
            return False
        
        # 自分の在庫を減らす
        self.stock -= quantity
        
        # 相手の在庫を増やす
        other_shop.stock += quantity
        
        print(f"📦 {self.owner_name} → {other_shop.owner_name}: {quantity}個譲渡")
        return True


# 使用例
shop1 = DaifukuShop("うさうさ", 20)
shop2 = DaifukuShop("もちもち", 10)

shop1.sell(5)
print(f"利益率: {shop1.get_profit_rate():.1f}%")

shop1.transfer_stock(shop2, 5)
print(f"うさうさ店: {shop1.stock}個")
print(f"もちもち店: {shop2.stock}個")
```

### ⚠️ インスタンスメソッドの注意点

```python
class Shop:
    def sell(quantity):  # ❌ selfを忘れている
        pass

shop = Shop()
# shop.sell(5)  # エラー！

# 正しくは:
class Shop:
    def sell(self, quantity):  # ✅ selfが必要
        pass
```

---

## 5. クラスメソッド詳細

### 📖 定義

**クラスメソッド = クラス全体に関わる処理**

### 🎯 特徴5つ

1. **@classmethod デコレーター必須**
2. **第一引数は cls**（クラス自身）
3. **クラス変数にアクセス可能**
4. **インスタンス不要で呼べる**
5. **ファクトリーメソッドに最適**

### 💻 詳細な例

```python
class DaifukuShop:
    """クラスメソッドの詳細"""
    
    # クラス変数
    total_shops = 0
    total_revenue = 0
    company_name = "ふわふわ大福株式会社"
    
    def __init__(self, owner_name, stock):
        self.owner_name = owner_name
        self.stock = stock
        
        # クラス変数を更新
        DaifukuShop.total_shops += 1
    
    # ========================================
    # クラスメソッド
    # ========================================
    
    @classmethod
    def get_company_info(cls):
        """
        会社情報を取得
        
        clsで何ができる？
        - cls.xxx でクラス変数にアクセス
        - cls() でインスタンスを作成
        - cls.method() で他のクラスメソッドを呼ぶ
        """
        return f"{cls.company_name}（店舗数: {cls.total_shops}店）"
    
    @classmethod
    def from_dict(cls, data):
        """
        辞書からインスタンスを作成（ファクトリーメソッド）
        
        用途:
        - JSONデータからオブジェクト生成
        - 別の形式からの変換
        - 代替コンストラクタ
        """
        return cls(
            owner_name=data["owner"],
            stock=data.get("stock", 10)
        )
    
    @classmethod
    def from_csv(cls, csv_line):
        """
        CSV行からインスタンスを作成
        
        クラスメソッドは:
        - 様々な形式からインスタンスを作れる
        - __init__とは違う作り方を提供
        """
        parts = csv_line.split(',')
        return cls(
            owner_name=parts[0].strip(),
            stock=int(parts[1].strip())
        )
    
    @classmethod
    def create_franchise(cls, owner_name):
        """
        フランチャイズ店舗を作成
        
        クラスメソッドは:
        - 標準的な設定でインスタンスを作る
        - ビジネスロジックを含む
        """
        print(f"🏪 {owner_name}様、フランチャイズ契約ありがとうございます！")
        return cls(owner_name, stock=20)  # 標準在庫20個
    
    @classmethod
    def get_total_revenue(cls):
        """
        全店舗の総売上を取得
        
        クラスメソッドは:
        - クラス全体の統計を取る
        - すべてのインスタンスに関わる情報
        """
        return f"総売上: ¥{cls.total_revenue:,}"
    
    @classmethod
    def reset_stats(cls):
        """
        統計をリセット
        
        クラスメソッドは:
        - クラス変数を変更できる
        - 全インスタンスに影響する
        """
        cls.total_shops = 0
        cls.total_revenue = 0
        print("📊 統計をリセットしました")


# ========================================
# 使用例
# ========================================

# インスタンスを作らずに呼べる
print(DaifukuShop.get_company_info())

# ファクトリーメソッド（様々な形式から作成）
data = {"owner": "うさうさ", "stock": 25}
shop1 = DaifukuShop.from_dict(data)

csv = "もちもち,15"
shop2 = DaifukuShop.from_csv(csv)

shop3 = DaifukuShop.create_franchise("ぴょんぴょん")

# 統計情報
print(DaifukuShop.get_company_info())
```

### ⚠️ クラスメソッドの注意点

```python
class Shop:
    # @classmethod を忘れている
    def get_total(cls):  # ❌ デコレーターなし
        return cls.total

# Shop.get_total()  # エラー！

# 正しくは:
class Shop:
    @classmethod  # ✅ デコレーター必須
    def get_total(cls):
        return cls.total
```

---

## 6. スタティックメソッド詳細

### 📖 定義

**スタティックメソッド = クラスに属する補助関数**

### 🎯 特徴5つ

1. **@staticmethod デコレーター必須**
2. **第一引数なし**（self も cls も不要）
3. **インスタンス変数もクラス変数も使わない**
4. **純粋な計算・変換処理**
5. **名前空間の整理に便利**

### 💻 詳細な例

```python
class DaifukuShop:
    """スタティックメソッドの詳細"""
    
    # 定数
    BASE_PRICE = 150
    TAX_RATE = 0.10
    
    def __init__(self, owner_name, stock):
        self.owner_name = owner_name
        self.stock = stock
    
    # ========================================
    # スタティックメソッド
    # ========================================
    
    @staticmethod
    def calculate_tax(price):
        """
        税込価格を計算
        
        特徴:
        - 引数だけを使う
        - self も cls も不要
        - 純粋な計算処理
        - インスタンスやクラスのデータを使わない
        """
        return int(price * 1.1)
    
    @staticmethod
    def validate_stock(stock):
        """
        在庫数のバリデーション
        
        用途:
        - 入力値の検証
        - インスタンス作成前にチェック
        - ビジネスルールの検証
        """
        if not isinstance(stock, int):
            return False
        if stock < 0:
            return False
        if stock > 10000:  # 最大在庫数
            return False
        return True
    
    @staticmethod
    def validate_price(price):
        """価格のバリデーション"""
        return isinstance(price, (int, float)) and 0 < price < 100000
    
    @staticmethod
    def format_currency(amount):
        """
        通貨フォーマット
        
        用途:
        - 表示用の変換
        - 文字列整形
        - ユーティリティ関数
        """
        return f"¥{amount:,}"
    
    @staticmethod
    def parse_quantity(text):
        """
        文字列から個数を抽出
        
        用途:
        - データ変換
        - パース処理
        - 前処理
        
        例:
        "20個" → 20
        "在庫15" → 15
        """
        import re
        numbers = re.findall(r'\d+', text)
        return int(numbers[0]) if numbers else 0
    
    @staticmethod
    def calculate_discount(price, rate):
        """
        割引価格を計算
        
        用途:
        - ビジネスロジック
        - 計算式
        - どのインスタンスにも属さない処理
        """
        if not 0 <= rate <= 1:
            raise ValueError("割引率は0-1の範囲で指定してください")
        return int(price * (1 - rate))
    
    @staticmethod
    def is_business_hours(hour):
        """
        営業時間内かチェック
        
        用途:
        - 条件判定
        - ビジネスルール
        """
        return 9 <= hour <= 20
    
    @staticmethod
    def calculate_points(amount):
        """
        購入金額からポイントを計算
        
        用途:
        - ポイント計算ロジック
        - 独立した計算
        """
        return int(amount * 0.01)  # 1%ポイント還元


# ========================================
# 使用例
# ========================================

# インスタンスを作らずに使える
price = 1000
tax_price = DaifukuShop.calculate_tax(price)
print(f"税込: {DaifukuShop.format_currency(tax_price)}")

# バリデーション
print(f"在庫20は有効？ {DaifukuShop.validate_stock(20)}")
print(f"在庫-5は有効？ {DaifukuShop.validate_stock(-5)}")

# データ変換
text = "在庫25個"
quantity = DaifukuShop.parse_quantity(text)
print(f"抽出結果: {quantity}個")

# 計算
discount_price = DaifukuShop.calculate_discount(1000, 0.1)
print(f"10%割引: {DaifukuShop.format_currency(discount_price)}")

# 営業時間チェック
print(f"15時は営業中？ {DaifukuShop.is_business_hours(15)}")
print(f"22時は営業中？ {DaifukuShop.is_business_hours(22)}")

# ポイント計算
points = DaifukuShop.calculate_points(5000)
print(f"5000円の購入で{points}ポイント")
```

### ⚠️ スタティックメソッドの注意点

```python
# 注意1: @staticmethod を忘れない
class Shop:
    def calculate(price):  # ❌ デコレーターなし
        return price * 1.1

# Shop.calculate(1000)  # エラー！


# 注意2: self や cls を使わない
class Shop:
    base_price = 150
    
    @staticmethod
    def get_price(self):  # ❌ selfがある
        return self.base_price  # エラー！
    
    @staticmethod
    def get_price2(cls):  # ❌ clsがある
        return cls.base_price  # エラー！
    
    # 正しくは:
    @staticmethod
    def get_price3():  # ✅ 引数なし（または自由な引数）
        return 150  # 固定値または引数から計算


# 注意3: インスタンス変数やクラス変数を使いたい場合
class Shop:
    tax_rate = 0.1  # クラス変数
    
    @staticmethod
    def calculate_tax(price):
        # クラス変数を使いたい場合は、クラス名で参照
        return int(price * (1 + Shop.tax_rate))  # ✅ クラス名.変数名
        
        # または引数で受け取る
    
    @staticmethod
    def calculate_tax2(price, tax_rate):
        return int(price * (1 + tax_rate))  # ✅ 引数で受け取る
```

### 💡 スタティックメソッドを使うべき場面

```python
# ✅ 使うべき場面1: バリデーション
@staticmethod
def validate_email(email):
    return "@" in email and "." in email

# ✅ 使うべき場面2: 計算ロジック
@staticmethod
def calculate_bmi(weight, height):
    return weight / (height ** 2)

# ✅ 使うべき場面3: データ変換
@staticmethod
def parse_date(date_string):
    from datetime import datetime
    return datetime.strptime(date_string, "%Y-%m-%d")

# ✅ 使うべき場面4: ユーティリティ関数
@staticmethod
def format_phone(number):
    return f"{number[:3]}-{number[3:7]}-{number[7:]}"

# ❌ 使うべきでない場面: インスタンス変数を使う
@staticmethod
def sell(quantity):  # ❌ インスタンスメソッドにすべき
    self.stock -= quantity  # エラー！selfがない
```

---

## 7. 使い分け判断フローチャート

### 🎯 完全判断フロー

```
┌─────────────────────────────────────┐
│ メソッドを作る時の判断               │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ Q1: インスタンス変数（self.xxx）を    │
│     使いますか？                     │
└─────────────────────────────────────┘
         ↙ YES              NO ↘
    ┌────────┐              ┌────────┐
    │インスタンス│              │ Q2へ   │
    │メソッド   │              └────────┘
    └────────┘                   ↓
    デコレーター: なし          ┌─────────────────┐
    第一引数: self            │ Q2: クラス変数を  │
    使える: self.xxx          │     使いますか？  │
                             │     またはインスタ │
                             │     ンスを作る？   │
                             └─────────────────┘
                                  ↙ YES    NO ↘
                            ┌──────────┐  ┌──────────┐
                            │クラス      │  │スタティック│
                            │メソッド    │  │メソッド    │
                            └──────────┘  └──────────┘
                            デコレーター:    デコレーター:
                            @classmethod    @staticmethod
                            第一引数: cls    第一引数: なし
                            使える: cls.xxx  使える: 引数のみ
```

### 📊 具体例での判断

```python
class DaifukuShop:
    """判断フローの実例"""
    
    total_shops = 0  # クラス変数
    
    def __init__(self, owner_name, stock):
        self.owner_name = owner_name  # インスタンス変数
        self.stock = stock
    
    # ==========================================
    # 判断例1: 在庫を減らしたい
    # ==========================================
    # Q1: self.stock（インスタンス変数）を使う？
    # → YES → インスタンスメソッド
    
    def sell(self, quantity):
        """インスタンスメソッド"""
        self.stock -= quantity  # self.xxxを使う
    
    # ==========================================
    # 判断例2: 総店舗数を取得したい
    # ==========================================
    # Q1: インスタンス変数を使う？ → NO
    # Q2: クラス変数（total_shops）を使う？ → YES
    # → クラスメソッド
    
    @classmethod
    def get_total(cls):
        """クラスメソッド"""
        return cls.total_shops  # cls.xxxを使う
    
    # ==========================================
    # 判断例3: 税込価格を計算したい
    # ==========================================
    # Q1: インスタンス変数を使う？ → NO
    # Q2: クラス変数を使う？ → NO（引数だけで計算）
    # → スタティックメソッド
    
    @staticmethod
    def calculate_tax(price):
        """スタティックメソッド"""
        return int(price * 1.1)  # 引数だけ使う
    
    # ==========================================
    # 判断例4: 辞書からインスタンスを作りたい
    # ==========================================
    # Q1: インスタンス変数を使う？ → NO
    # Q2: インスタンスを作る（cls()）？ → YES
    # → クラスメソッド
    
    @classmethod
    def from_dict(cls, data):
        """クラスメソッド（ファクトリー）"""
        return cls(data["owner"], data["stock"])  # cls()でインスタンス作成
```

### 🔍 判断の具体例10個

| やりたいこと | 判断 | 理由 |
|------------|------|------|
| この店舗の在庫を減らす | インスタンス | `self.stock`を使う |
| この店舗の売上を計算 | インスタンス | `self.revenue`を使う |
| 全店舗の総数を取得 | クラス | `cls.total_shops`を使う |
| 辞書からインスタンス生成 | クラス | `cls()`でインスタンス作成 |
| 税込価格を計算 | スタティック | 引数だけで計算 |
| 在庫数の検証 | スタティック | 引数をチェックするだけ |
| 通貨フォーマット | スタティック | 文字列変換のみ |
| 全店舗の価格を変更 | クラス | `cls.base_price`を変更 |
| この店舗の情報を表示 | インスタンス | `self.owner_name`等を使う |
| 日付文字列をパース | スタティック | 変換処理のみ |

---

## 📝 完全実践コード

### 💻 すべてを統合した実例

```python
"""
====================================
🐰 ふわふわ大福店 完全版
デコレーターと3つのメソッドの総まとめ
====================================
"""

class DaifukuShop:
    """
    大福店クラス
    
    3つのメソッドタイプを適切に使い分ける
    """
    
    # ========================================
    # クラス変数（全店舗共通）
    # ========================================
    total_shops = 0
    total_revenue = 0
    company_name = "ふわふわ大福株式会社"
    base_price = 150
    tax_rate = 0.10
    
    def __init__(self, owner_name, location, stock):
        """
        コンストラクタ
        
        インスタンス変数を初期化
        """
        # バリデーション（スタティックメソッド使用）
        if not self.validate_owner_name(owner_name):
            raise ValueError("店長名が不正です")
        
        if not self.validate_stock(stock):
            raise ValueError("在庫数が不正です")
        
        # インスタンス変数の初期化
        self.owner_name = owner_name
        self.location = location
        self.stock = stock
        self.sold = 0
        self.revenue = 0
        
        # クラス変数を更新
        DaifukuShop.total_shops += 1
        
        print(f"🐰 {self.owner_name}店長の店が{self.location}に開店！")
    
    # ========================================
    # インスタンスメソッド（個別の処理）
    # ========================================
    
    def sell(self, quantity, discount=0):
        """
        販売処理（この店舗の処理）
        
        インスタンスメソッドを使う理由:
        - この店舗の在庫を減らす（self.stock）
        - この店舗の売上を増やす（self.revenue）
        - 個別のデータを操作する
        """
        # バリデーション（スタティックメソッド使用）
        if not self.validate_quantity(quantity):
            print("❌ 数量が不正です")
            return None
        
        if quantity > self.stock:
            print(f"❌ 在庫不足（在庫: {self.stock}個）")
            return None
        
        # 価格計算（スタティックメソッド使用）
        price = self.base_price
        if discount > 0:
            price = self.calculate_discounted_price(price, discount)
        
        subtotal = quantity * price
        total = self.calculate_with_tax(subtotal)
        
        # インスタンス変数を更新
        self.stock -= quantity
        self.sold += quantity
        self.revenue += total
        
        # クラス変数を更新
        DaifukuShop.total_revenue += total
        
        print(f"💰 {self.owner_name}店長: {quantity}個販売（{self.format_currency(total)}）")
        
        return total
    
    def restock(self, quantity):
        """
        在庫補充（この店舗の処理）
        
        インスタンスメソッド: self.stockを操作
        """
        self.stock += quantity
        print(f"📦 {self.owner_name}店長: {quantity}個補充（在庫: {self.stock}個）")
    
    def show_status(self):
        """
        店舗状態を表示（この店舗の情報）
        
        インスタンスメソッド: self.xxxを表示
        """
        print(f"\n{'='*50}")
        print(f"🏪 {self.owner_name}店長の店（{self.location}）")
        print(f"📦 在庫: {self.stock}個")
        print(f"💰 累計販売: {self.sold}個")
        print(f"💵 累計売上: {self.format_currency(self.revenue)}")
        print(f"{'='*50}\n")
    
    # ========================================
    # クラスメソッド（クラス全体の処理）
    # ========================================
    
    @classmethod
    def get_company_info(cls):
        """
        会社情報を取得
        
        クラスメソッドを使う理由:
        - クラス変数（company_name等）を使う
        - インスタンス不要で呼びたい
        """
        return f"{cls.company_name}（店舗数: {cls.total_shops}店）"
    
    @classmethod
    def get_total_stats(cls):
        """
        全店舗の統計
        
        クラスメソッド: cls.xxxで統計取得
        """
        avg_revenue = cls.total_revenue / cls.total_shops if cls.total_shops > 0 else 0
        
        print(f"\n{'='*50}")
        print(f"📊 全店舗統計")
        print(f"{'='*50}")
        print(f"総店舗数: {cls.total_shops}店")
        print(f"総売上: {cls.format_currency(cls.total_revenue)}")
        print(f"平均売上: {cls.format_currency(int(avg_revenue))}")
        print(f"{'='*50}\n")
    
    @classmethod
    def from_dict(cls, data):
        """
        辞書からインスタンスを生成
        
        クラスメソッドを使う理由:
        - インスタンスを作成（cls()）
        - 代替コンストラクタ
        """
        return cls(
            owner_name=data["owner"],
            location=data["location"],
            stock=data.get("stock", 10)
        )
    
    @classmethod
    def change_base_price(cls, new_price):
        """
        基本価格を変更（全店舗に影響）
        
        クラスメソッド: cls.base_priceを変更
        """
        cls.base_price = new_price
        print(f"📢 基本価格を{cls.format_currency(new_price)}に変更しました")
    
    # ========================================
    # スタティックメソッド（補助関数）
    # ========================================
    
    @staticmethod
    def validate_owner_name(name):
        """
        店長名のバリデーション
        
        スタティックメソッドを使う理由:
        - 引数だけで判定
        - self も cls も不要
        - インスタンス作成前にチェック
        """
        return isinstance(name, str) and len(name) > 0
    
    @staticmethod
    def validate_stock(stock):
        """在庫数のバリデーション"""
        return isinstance(stock, int) and 0 <= stock <= 10000
    
    @staticmethod
    def validate_quantity(quantity):
        """販売数量のバリデーション"""
        return isinstance(quantity, int) and quantity > 0
    
    @staticmethod
    def calculate_with_tax(price):
        """
        税込価格を計算
        
        スタティックメソッド: 純粋な計算
        """
        return int(price * (1 + DaifukuShop.tax_rate))
    
    @staticmethod
    def calculate_discounted_price(price, discount_rate):
        """
        割引価格を計算
        
        スタティックメソッド: 計算ロジック
        """
        if not 0 <= discount_rate <= 1:
            raise ValueError("割引率は0-1で指定")
        return int(price * (1 - discount_rate))
    
    @staticmethod
    def format_currency(amount):
        """
        通貨フォーマット
        
        スタティックメソッド: 文字列変換
        """
        return f"¥{amount:,}"
    
    @staticmethod
    def parse_quantity_text(text):
        """
        テキストから数量を抽出
        
        スタティックメソッド: データ変換
        """
        import re
        numbers = re.findall(r'\d+', text)
        return int(numbers[0]) if numbers else 0


# ========================================
# 実行例
# ========================================

def main():
    """メイン実行関数"""
    
    print("="*60)
    print("🐰 ふわふわ大福店 - デモンストレーション")
    print("="*60)
    
    # ========================================
    # クラスメソッド: インスタンス不要で呼べる
    # ========================================
    print("\n【クラスメソッド】インスタンス不要")
    print(DaifukuShop.get_company_info())
    
    # ========================================
    # スタティックメソッド: バリデーション
    # ========================================
    print("\n【スタティックメソッド】バリデーション")
    print(f"'うさうさ'は有効な店長名？ {DaifukuShop.validate_owner_name('うさうさ')}")
    print(f"''は有効な店長名？ {DaifukuShop.validate_owner_name('')}")
    print(f"20は有効な在庫数？ {DaifukuShop.validate_stock(20)}")
    print(f"-5は有効な在庫数？ {DaifukuShop.validate_stock(-5)}")
    
    # ========================================
    # インスタンスメソッド: 個別の処理
    # ========================================
    print("\n【インスタンスメソッド】店舗を作成")
    shop1 = DaifukuShop("うさうさ", "渋谷", 30)
    shop2 = DaifukuShop("もちもち", "新宿", 25)
    
    # クラスメソッドで辞書から作成
    data = {"owner": "ぴょんぴょん", "location": "池袋", "stock": 20}
    shop3 = DaifukuShop.from_dict(data)
    
    print("\n【インスタンスメソッド】販売処理")
    shop1.sell(5)
    shop1.sell(3, discount=0.1)  # 10%割引
    shop2.sell(7)
    shop3.sell(4)
    
    print("\n【インスタンスメソッド】在庫補充")
    shop1.restock(10)
    
    print("\n【インスタンスメソッド】店舗状態")
    shop1.show_status()
    shop2.show_status()
    
    # ========================================
    # クラスメソッド: 全体統計
    # ========================================
    print("\n【クラスメソッド】全体統計")
    DaifukuShop.get_total_stats()
    
    # ========================================
    # クラスメソッド: 価格変更（全店舗に影響）
    # ========================================
    print("\n【クラスメソッド】価格変更")
    DaifukuShop.change_base_price(180)
    
    shop1.sell(2)  # 新価格で販売
    
    # ========================================
    # スタティックメソッド: 計算
    # ========================================
    print("\n【スタティックメソッド】計算")
    price = 1000
    tax_price = DaifukuShop.calculate_with_tax(price)
    discount_price = DaifukuShop.calculate_discounted_price(price, 0.2)
    
    print(f"¥1,000の税込価格: {DaifukuShop.format_currency(tax_price)}")
    print(f"¥1,000の20%割引価格: {DaifukuShop.format_currency(discount_price)}")
    
    # テキストパース
    text = "注文25個"
    quantity = DaifukuShop.parse_quantity_text(text)
    print(f"'{text}'から抽出: {quantity}個")
    
    print("\n" + "="*60)
    print("✅ デモンストレーション完了！")
    print("="*60)


if __name__ == "__main__":
    main()
```

---

## 📝 最終まとめ

### 🎯 覚えるべき3つのポイント

#### 1️⃣ デコレーターは「魔法」

```python
@デコレーター名
def 関数名():
    pass

# ↓ これと同じ
# 関数名 = デコレーター名(関数名)
```

#### 2️⃣ 3つのメソッドの使い分け

| メソッド | デコレーター | 第一引数 | 使う時 |
|---------|------------|---------|--------|
| インスタンス | なし | `self` | 個別データを使う |
| クラス | `@classmethod` | `cls` | クラス全体の処理 |
| スタティック | `@staticmethod` | なし | 補助関数 |

#### 3️⃣ 判断は簡単

```
self.xxx を使う？ → インスタンスメソッド
cls.xxx を使う？  → クラスメソッド
どちらも使わない？ → スタティックメソッド
```

### 💡 実践的アドバイス

1. **迷ったらインスタンスメソッド**から始める
2. **クラスメソッド**はファクトリーと統計に使う
3. **スタティックメソッド**はバリデーションと計算に使う
4. **デコレーターを忘れない**（@classmethodと@staticmethod）

---

**🐰 うさうさ店長からのメッセージ:**

「デコレーターと3つのメソッドは、最初は難しく感じるかもしれません。
でも、実際にコードを書いて動かせば、必ず理解できます！
まずはインスタンスメソッドを使いこなし、
必要に応じてクラスメソッドやスタティックメソッドを追加していきましょう！」

---

**📎 関連記事:**
- [クラスの基本用語完全ガイド](#)
- [インスタンス変数とクラス変数](#)
- [継承とポリモーフィズム](#)
