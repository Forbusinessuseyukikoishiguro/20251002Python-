# ==========================================================
# Python継承トラブルシューティング完全ガイド
# ==========================================================

"""
【よくある継承のトラブル】

1. super()を使わない（親の初期化忘れ）
2. メソッドのオーバーライドミス
3. 多重継承の順序問題（MRO）
4. 親のメソッドを呼び出せない
5. AttributeError（属性が見つからない）
6. isinstance() vs type()
7. 抽象クラスの実装忘れ
8. クラス変数とインスタンス変数の混同
9. プライベート属性の継承問題
10. 循環参照
"""

print("=" * 70)
print("Python継承トラブルシューティング完全ガイド")
print("=" * 70)

# ==========================================================
# 【1】super()を使わない - 最頻出！
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル1】super()を使わない（親の初期化忘れ）")
print("=" * 70)

trouble1 = """
■ 問題：親クラスの__init__が呼ばれない
-----------------------------------------------------------
# ❌ 間違い
class Animal:
    def __init__(self, name):
        self.name = name
        self.energy = 100

class Dog(Animal):
    def __init__(self, name, breed):
        # super()を呼んでいない！
        self.breed = breed

dog = Dog("ポチ", "柴犬")
print(dog.breed)   # OK
print(dog.name)    # AttributeError! nameが初期化されていない
print(dog.energy)  # AttributeError! energyが初期化されていない
-----------------------------------------------------------

■ 解決方法：必ずsuper().__init__()を呼ぶ
-----------------------------------------------------------
# ✅ 正しい
class Animal:
    def __init__(self, name):
        self.name = name
        self.energy = 100
        print("Animalが初期化されました")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 親の初期化を呼ぶ（必須！）
        self.breed = breed
        print("Dogが初期化されました")

dog = Dog("ポチ", "柴犬")
print(f"名前: {dog.name}")      # ポチ
print(f"犬種: {dog.breed}")     # 柴犬
print(f"エネルギー: {dog.energy}")  # 100
-----------------------------------------------------------

■ super()の正しい使い方
-----------------------------------------------------------
# パターン1：基本形
class Child(Parent):
    def __init__(self, param1, param2):
        super().__init__(param1)  # 親に必要な引数を渡す
        self.child_param = param2  # 子独自の初期化

# パターン2：複数の引数
class Child(Parent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)  # 全て親に渡す
        # 子独自の処理

# パターン3：親のメソッドを拡張
class Child(Parent):
    def method(self):
        super().method()  # 親のメソッドを実行
        # 追加の処理
        print("子クラスの追加処理")
-----------------------------------------------------------

■ よくある間違いパターン
-----------------------------------------------------------
# ❌ 間違い1：super()を忘れる
class Dog(Animal):
    def __init__(self, breed):
        self.breed = breed
        # super().__init__()を忘れている

# ❌ 間違い2：引数を間違える
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__()  # nameを渡していない！
        self.breed = breed

# ❌ 間違い3：順序が逆
class Dog(Animal):
    def __init__(self, name, breed):
        self.breed = breed  # 先に子の初期化
        super().__init__(name)  # 後から親
        # これは動くが、親が子の属性を使う場合に問題

# ✅ 正しい順序（推奨）
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 先に親を初期化
        self.breed = breed      # その後、子を初期化
-----------------------------------------------------------
"""

print(trouble1)

# 実際に動作例
print("\n■ 動作例：super()の有無")

class Animal:
    def __init__(self, name):
        self.name = name
        self.energy = 100

# 間違った例
class BadDog(Animal):
    def __init__(self, name, breed):
        # super()なし
        self.breed = breed

# 正しい例
class GoodDog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed

print("【間違った例】")
try:
    bad_dog = BadDog("ポチ", "柴犬")
    print(f"名前: {bad_dog.name}")  # エラー！
except AttributeError as e:
    print(f"❌ エラー: {e}")

print("\n【正しい例】")
good_dog = GoodDog("タロー", "秋田犬")
print(f"✅ 名前: {good_dog.name}")
print(f"✅ 犬種: {good_dog.breed}")
print(f"✅ エネルギー: {good_dog.energy}")

# ==========================================================
# 【2】メソッドのオーバーライドミス
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル2】メソッドのオーバーライドミス")
print("=" * 70)

trouble2 = """
■ 問題：メソッド名のスペルミスで上書きされない
-----------------------------------------------------------
# ❌ 間違い
class Animal:
    def speak(self):
        return "何か音を出す"

class Dog(Animal):
    def speak(self):  # speakを上書き
        return "ワンワン"

class Cat(Animal):
    def speek(self):  # スペルミス！speak じゃない
        return "ニャー"

dog = Dog()
cat = Cat()
print(dog.speak())  # ワンワン（OK）
print(cat.speak())  # 何か音を出す（親のメソッドが呼ばれる）
print(cat.speek())  # ニャー（新しいメソッドになってる）
-----------------------------------------------------------

■ 解決方法1：メソッド名を確認
-----------------------------------------------------------
# ✅ 正しい
class Cat(Animal):
    def speak(self):  # 正しいスペル
        return "ニャー"

cat = Cat()
print(cat.speak())  # ニャー
-----------------------------------------------------------

■ 解決方法2：親のメソッドを呼び出す
-----------------------------------------------------------
class Animal:
    def speak(self):
        return "音"
    
    def describe(self):
        return f"{self.name}が{self.speak()}"

class Dog(Animal):
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "ワンワン"
    
    # describeは親のものを使う（オーバーライドしない）

dog = Dog("ポチ")
print(dog.describe())  # ポチがワンワン
-----------------------------------------------------------

■ 解決方法3：親のメソッドを拡張
-----------------------------------------------------------
class Animal:
    def move(self):
        print("移動する")

class Bird(Animal):
    def move(self):
        super().move()  # 親のmoveを実行
        print("そして飛ぶ")  # 追加の動作

bird = Bird()
bird.move()
# 出力：
# 移動する
# そして飛ぶ
-----------------------------------------------------------

■ よくある間違い：完全に上書きして親を呼ばない
-----------------------------------------------------------
class Animal:
    def __init__(self, name):
        self.name = name
        self.energy = 100
        self.health = 100

class Dog(Animal):
    def __init__(self, name, breed):
        # ❌ 親を呼ばずに全部自分で書く
        self.name = name
        self.breed = breed
        # energyとhealthの初期化を忘れている

# ✅ 正しい方法
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 親に任せる
        self.breed = breed  # 子独自のものだけ追加
-----------------------------------------------------------
"""

print(trouble2)

# 実際に動作例
print("\n■ 動作例：オーバーライド")

class Animal:
    def speak(self):
        return "..."
    
    def introduce(self):
        return f"動物です。{self.speak()}"

class Cat(Animal):
    def speak(self):
        return "ニャー"

class Dog(Animal):
    def speak(self):
        return "ワンワン"
    
    def introduce(self):
        # 親のintroduceを拡張
        parent_intro = super().introduce()
        return f"{parent_intro}（犬です）"

cat = Cat()
dog = Dog()

print(f"猫: {cat.introduce()}")  # 動物です。ニャー
print(f"犬: {dog.introduce()}")  # 動物です。ワンワン（犬です）

# ==========================================================
# 【3】多重継承の順序問題（MRO）
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル3】多重継承の順序問題（MRO）")
print("=" * 70)

trouble3 = """
■ 問題：複数の親クラスがある時、どれが呼ばれる？
-----------------------------------------------------------
class A:
    def method(self):
        print("Aのメソッド")

class B:
    def method(self):
        print("Bのメソッド")

class C(A, B):  # AとBを両方継承
    pass

c = C()
c.method()  # どちらが呼ばれる？
# 答え：Aのメソッド（左から順に探索）
-----------------------------------------------------------

■ MRO（Method Resolution Order）とは
-----------------------------------------------------------
# メソッドを探す順序のこと
# 左から右、深さ優先で探索

class C(A, B):
    pass

# MROを確認
print(C.__mro__)
# (<class 'C'>, <class 'A'>, <class 'B'>, <class 'object'>)

# または
print(C.mro())
-----------------------------------------------------------

■ よくある問題：ダイヤモンド継承
-----------------------------------------------------------
class Animal:
    def __init__(self):
        print("Animal初期化")
        self.species = "動物"

class Mammal(Animal):
    def __init__(self):
        super().__init__()
        print("Mammal初期化")
        self.warm_blooded = True

class Carnivore(Animal):
    def __init__(self):
        super().__init__()
        print("Carnivore初期化")
        self.eats_meat = True

class Dog(Mammal, Carnivore):
    def __init__(self):
        super().__init__()
        print("Dog初期化")

# MROを確認
print(Dog.mro())
# [Dog, Mammal, Carnivore, Animal, object]

dog = Dog()
# 出力順：
# Animal初期化
# Carnivore初期化
# Mammal初期化
# Dog初期化
-----------------------------------------------------------

■ 解決方法：多重継承を避ける（推奨）
-----------------------------------------------------------
# 方法1：コンポジション（組み合わせ）を使う
class Engine:
    def start(self):
        print("エンジン始動")

class Wings:
    def fly(self):
        print("飛ぶ")

class Airplane:
    def __init__(self):
        self.engine = Engine()  # 継承ではなく保持
        self.wings = Wings()
    
    def takeoff(self):
        self.engine.start()
        self.wings.fly()

# 方法2：ミックスイン（機能追加用）
class LoggerMixin:
    def log(self, message):
        print(f"[LOG] {message}")

class TimestampMixin:
    def get_timestamp(self):
        from datetime import datetime
        return datetime.now()

class User(LoggerMixin, TimestampMixin):
    def __init__(self, name):
        self.name = name
    
    def login(self):
        self.log(f"{self.name}がログインしました")
        print(f"時刻: {self.get_timestamp()}")
-----------------------------------------------------------
"""

print(trouble3)

# 実際に動作例
print("\n■ 動作例：MRO確認")

class A:
    def method(self):
        return "A"

class B:
    def method(self):
        return "B"

class C(A, B):
    pass

class D(B, A):
    pass

c = C()
d = D()

print(f"C.method(): {c.method()}")  # A（左から優先）
print(f"D.method(): {d.method()}")  # B（左から優先）
print(f"\nCのMRO: {[cls.__name__ for cls in C.mro()]}")
print(f"DのMRO: {[cls.__name__ for cls in D.mro()]}")

# ==========================================================
# 【4】親のメソッドを呼び出せない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル4】親のメソッドを呼び出せない")
print("=" * 70)

trouble4 = """
■ 問題：親クラスのメソッドにアクセスできない
-----------------------------------------------------------
# ❌ 間違い
class Parent:
    def greet(self):
        return "こんにちは"

class Child(Parent):
    def greet(self):
        return "やあ"
    
    def formal_greet(self):
        # 親のgreetを呼びたい
        return Parent.greet()  # エラー！selfがない

child = Child()
print(child.formal_greet())  # TypeError
-----------------------------------------------------------

■ 解決方法1：super()を使う（推奨）
-----------------------------------------------------------
class Parent:
    def greet(self):
        return "こんにちは"

class Child(Parent):
    def greet(self):
        return "やあ"
    
    def formal_greet(self):
        return super().greet()  # 親のgreetを呼ぶ

child = Child()
print(child.formal_greet())  # こんにちは
-----------------------------------------------------------

■ 解決方法2：クラス名を明示（非推奨だが可能）
-----------------------------------------------------------
class Parent:
    def greet(self):
        return "こんにちは"

class Child(Parent):
    def greet(self):
        return "やあ"
    
    def formal_greet(self):
        return Parent.greet(self)  # selfを明示的に渡す

child = Child()
print(child.formal_greet())  # こんにちは
-----------------------------------------------------------

■ 解決方法3：別名をつける
-----------------------------------------------------------
class Parent:
    def process(self):
        print("基本処理")

class Child(Parent):
    def process(self):
        print("拡張処理")
    
    def base_process(self):
        '''親の処理を別名で公開'''
        super().process()

child = Child()
child.process()       # 拡張処理
child.base_process()  # 基本処理
-----------------------------------------------------------
"""

print(trouble4)

# ==========================================================
# 【5】AttributeError - 属性が見つからない
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル5】AttributeError: 属性が見つからない")
print("=" * 70)

trouble5 = """
■ 問題：子クラスで親の属性にアクセスできない
-----------------------------------------------------------
# ❌ 間違い
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, breed):
        # super().__init__()を呼んでいない
        self.breed = breed
    
    def introduce(self):
        return f"{self.name}は{self.breed}です"

dog = Dog("柴犬")
print(dog.introduce())  # AttributeError: 'Dog' has no attribute 'name'
-----------------------------------------------------------

■ 解決方法：super()で親を初期化
-----------------------------------------------------------
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 親を初期化
        self.breed = breed
    
    def introduce(self):
        return f"{self.name}は{self.breed}です"

dog = Dog("ポチ", "柴犬")
print(dog.introduce())  # ポチは柴犬です
-----------------------------------------------------------

■ よくあるパターン：条件付き属性
-----------------------------------------------------------
# ❌ 問題
class Animal:
    def __init__(self, name, can_fly=False):
        self.name = name
        if can_fly:
            self.wings = 2  # 条件付きで設定

class Bird(Animal):
    def __init__(self, name):
        super().__init__(name, can_fly=True)
    
    def flap(self):
        return f"{self.wings}枚の羽を羽ばたかせる"

bird = Bird("スズメ")
print(bird.flap())  # OK

dog = Animal("ポチ", can_fly=False)
# print(dog.wings)  # AttributeError

# ✅ 解決：hasattr()でチェック
class Animal:
    def __init__(self, name, can_fly=False):
        self.name = name
        if can_fly:
            self.wings = 2
    
    def describe_wings(self):
        if hasattr(self, 'wings'):
            return f"{self.wings}枚の羽があります"
        return "羽はありません"

bird = Animal("スズメ", can_fly=True)
dog = Animal("ポチ", can_fly=False)
print(bird.describe_wings())  # 2枚の羽があります
print(dog.describe_wings())   # 羽はありません
-----------------------------------------------------------

■ getattr()を使った安全なアクセス
-----------------------------------------------------------
class Animal:
    def __init__(self, name):
        self.name = name

animal = Animal("ポチ")

# 存在しない属性へのアクセス
age = getattr(animal, 'age', 0)  # デフォルト値0
print(age)  # 0

# 属性を設定
setattr(animal, 'age', 5)
print(animal.age)  # 5
-----------------------------------------------------------
"""

print(trouble5)

# 実際に動作例
print("\n■ 動作例：属性の安全なアクセス")

class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed
    
    def get_info(self):
        # 安全な属性アクセス
        name = getattr(self, 'name', '名無し')
        breed = getattr(self, 'breed', '不明')
        age = getattr(self, 'age', '不明')
        return f"{name}（{breed}、年齢{age}）"

dog = Dog("ポチ", "柴犬")
print(dog.get_info())  # ポチ（柴犬、年齢不明）

# 後から属性を追加
dog.age = 3
print(dog.get_info())  # ポチ（柴犬、年齢3）

# ==========================================================
# 【6】isinstance() vs type()
# ==========================================================

print("\n" + "=" * 70)
print("【トラブル6】isinstance() vs type()の使い分け")
print("=" * 70)

trouble6 = """
■ 問題：型チェックの方法を間違える
-----------------------------------------------------------
class Animal:
    pass

class Dog(Animal):
    pass

dog = Dog()

# type()は厳密（継承を考慮しない）
print(type(dog) == Dog)     # True
print(type(dog) == Animal)  # False ← 親クラスではFalse

# isinstance()は継承を考慮（推奨）
print(isinstance(dog, Dog))     # True
print(isinstance(dog, Animal))  # True ← 親クラスでもTrue
-----------------------------------------------------------

■ 使い分け
-----------------------------------------------------------
# ✅ isinstance()を使うべき場合（ほとんど）
def process_animal(obj):
    if isinstance(obj, Animal):  # 推奨
        obj.speak()

# ❌ type()を使うべきでない場合
def process_animal(obj):
    if type(obj) == Animal:  # 非推奨
        obj.speak()  # 子クラスが弾かれる

# ✅ type()を使う場合（まれ）
# 厳密に特定のクラスかチェックしたい時
def process_only_dog(obj):
    if type(obj) == Dog:  # 犬だけ、子クラスは除外
        pass
-----------------------------------------------------------

■ 複数の型チェック
-----------------------------------------------------------
# isinstance()は複数型チェック可能
value = 123
if isinstance(value, (int, float)):  # intかfloatか
    print("数値です")

# type()では不可
if type(value) in (int, float):  # これは動くが冗長
    print("数値です")
-----------------------------------------------------------
"""

print(trouble6)

# 実際に動作例
print("\n■ 動作例：型チェック")

class Animal:
    pass

class Dog(Animal):
    pass

class Cat(Animal):
    pass

dog = Dog()
cat = Cat()

print("【isinstance()】")
print(f"dog is Dog: {isinstance(dog, Dog)}")
print(f"dog is Animal: {isinstance(dog, Animal)}")
print(f"dog is Cat: {isinstance(dog, Cat)}")

print("\n【type()】")
print(f"type(dog) == Dog: {type(dog) == Dog}")
print(f"type(dog) == Animal: {type(dog) == Animal}")

# ==========================================================
# 【7】チートシート
# ==========================================================

print("\n" + "=" * 70)
print("【チートシート】継承トラブル解決法")
print("=" * 70)

cheatsheet = """
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃          継承トラブル解決チートシート                  ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■ トラブル1: 親の属性にアクセスできない
┌────────────────────────────────────────────────┐
│ 原因: super().__init__()を呼んでいない        │
│ 解決: 必ずsuper().__init__()を最初に呼ぶ      │
│                                               │
│ class Child(Parent):                          │
│     def __init__(self, params):               │
│         super().__init__(params)  # 必須！    │
│         # 子の初期化                          │
└────────────────────────────────────────────────┘

■ トラブル2: メソッドが上書きされない
┌────────────────────────────────────────────────┐
│ 原因: メソッド名のスペルミス                   │
│ 解決: 正しいメソッド名を確認                   │
│                                               │
│ # ❌ speek → ✅ speak                         │
└────────────────────────────────────────────────┘

■ トラブル3: 多重継承で混乱
┌────────────────────────────────────────────────┐
│ 原因: MRO（メソッド解決順序）を理解していない │
│ 解決1: print(Class.mro()) で確認             │
│ 解決2: 多重継承を避ける（コンポジション使用） │
└────────────────────────────────────────────────┘

■ トラブル4: 親のメソッドを呼べない
┌────────────────────────────────────────────────┐
│ 原因: super()を使っていない                   │
│ 解決: super().method() で親を呼ぶ            │
│                                               │
│ def method(self):                             │
│     super().method()  # 親を実行              │
│     # 追加処理                                │
└────────────────────────────────────────────────┘

■ トラブル5: 型チェックが動かない
┌────────────────────────────────────────────────┐
│ 原因: type()を使っている                      │
│ 解決: isinstance()を使う（継承を考慮）        │
│                                               │
│ # ❌ type(obj) == Parent                      │
│ # ✅ isinstance(obj, Parent)                  │
└────────────────────────────────────────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 継承の黄金ルール

1. 必ずsuper().__init__()を呼ぶ
2. 親を呼ぶ時はsuper()を使う
3. 型チェックはisinstance()
4. 多重継承は避ける
5. MROを確認する（Class.mro()）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 継承チェックリスト

□ super().__init__()を呼んでいるか？
□ メソッド名のスペルは正しいか？
□ 親のメソッドを呼ぶ時super()を使っているか？
□ isinstance()で型チェックしているか？
□ 必要な属性は初期化されているか？

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 正しい継承の基本形

class Parent:
    def __init__(self, param1):
        self.param1 = param1
    
    def method(self):
        return "親の処理"

class Child(Parent):
    def __init__(self, param1, param2):
        super().__init__(param1)  # 親を初期化
        self.param2 = param2      # 子の初期化
    
    def method(self):
        result = super().method()  # 親を呼ぶ
        return f"{result} + 子の処理"
"""

print(cheatsheet)

print("\n" + "=" * 70)
print("これで継承のトラブルは解決！")
print("=" * 70)

ーーーーー
親のまま！

# ✅ 解決
class Cat(Animal):
    def speak(self):  # 正しいスペル
        return "ニャー"

cat = Cat()
print(cat.speak())  # "ニャー" ← 正しく上書き
```

### 3️⃣ **親のメソッドを呼べない**

```python
# ❌ エラー
class Parent:
    def greet(self):
        return "こんにちは"

class Child(Parent):
    def greet(self):
        return "やあ"
    
    def formal_greet(self):
        return Parent.greet()  # エラー！selfがない

# ✅ 解決
class Child(Parent):
    def greet(self):
        return "やあ"
    
    def formal_greet(self):
        return super().greet()  # super()を使う

child = Child()
print(child.formal_greet())  # こんにちは
```

### 4️⃣ **type() vs isinstance()**

```python
class Animal:
    pass

class Dog(Animal):
    pass

dog = Dog()

# ❌ 間違い（継承を考慮しない）
print(type(dog) == Animal)  # False

# ✅ 正しい（継承を考慮）
print(isinstance(dog, Animal))  # True
print(isinstance(dog, Dog))     # True
```

### 5️⃣ **AttributeError**

```python
# ❌ エラー
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, breed):
        self.breed = breed  # super()なし
    
    def introduce(self):
        return f"{self.name}です"  # nameがない！

# ✅ 解決
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 親を初期化
        self.breed = breed
    
    def introduce(self):
        return f"{self.name}です"

dog = Dog("ポチ", "柴犬")
print(dog.introduce())  # ポチです
```

## 📋 継承の基本テンプレート

```python
# ===== 基本形 =====
class Parent:
    def __init__(self, param1):
        self.param1 = param1
    
    def method(self):
        return "親の処理"

class Child(Parent):
    def __init__(self, param1, param2):
        super().__init__(param1)  # ① 親を初期化
        self.param2 = param2      # ② 子の初期化
    
    def method(self):
        result = super().method()  # ③ 親のメソッドを呼ぶ
        return f"{result} + 子の処理"

# ===== 使用 =====
child = Child("値1", "値2")
print(child.method())
```

## 🔍 デバッグテクニック

### 1. MRO（メソッド解決順序）確認

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

# MROを確認
print(D.mro())
# [D, B, C, A, object]

# わかりやすく表示
for cls in D.mro():
    print(cls.__name__)
# D
# B
# C
# A
# object
```

### 2. 属性の存在確認

```python
class Animal:
    def __init__(self, name):
        self.name = name

dog = Animal("ポチ")

# 方法1: hasattr()
if hasattr(dog, 'name'):
    print(dog.name)

if hasattr(dog, 'age'):
    print(dog.age)
else:
    print("ageがありません")

# 方法2: getattr()（デフォルト値付き）
name = getattr(dog, 'name', '名無し')
age = getattr(dog, 'age', 0)
print(f"{name}、年齢{age}")

# 方法3: __dict__で全属性確認
print(dog.__dict__)  # {'name': 'ポチ'}
```

### 3. 継承チェーン確認

```python
class Animal:
    pass

class Mammal(Animal):
    pass

class Dog(Mammal):
    pass

dog = Dog()

# 親クラスをすべて確認
print(Dog.__bases__)  # (<class '__main__.Mammal'>,)
print(Mammal.__bases__)  # (<class '__main__.Animal'>,)

# isinstance()で確認
print(isinstance(dog, Dog))     # True
print(isinstance(dog, Mammal))  # True
print(isinstance(dog, Animal))  # True
print(isinstance(dog, object))  # True（すべてのクラスはobjectを継承）
```

## 🛠️ よくある間違いと修正

### 間違い1: 初期化の順序ミス

```python
# ❌ 間違い
class Dog(Animal):
    def __init__(self, name, breed):
        self.breed = breed  # 子を先に初期化
        super().__init__(name)  # 後から親

# ✅ 正しい（推奨）
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 親を先に初期化
        self.breed = breed  # その後、子
```

### 間違い2: 親の引数を渡さない

```python
# ❌ 間違い
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__()  # nameを渡していない
        self.breed = breed

# ✅ 正しい
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 引数を渡す
        self.breed = breed
```

### 間違い3: 親のメソッドを完全上書き

```python
# ❌ 非推奨（親の処理が失われる）
class Animal:
    def move(self):
        print("移動")
        self.energy -= 10

class Dog(Animal):
    def move(self):
        print("走る")  # 親の処理を無視

# ✅ 推奨（親を拡張）
class Dog(Animal):
    def move(self):
        super().move()  # 親の処理を実行
        print("しっぽを振る")  # 追加処理
```

### 間違い4: クラス変数の上書き

```python
# ❌ 意図しない動作
class Animal:
    count = 0  # クラス変数
    
    def __init__(self):
        Animal.count += 1

class Dog(Animal):
    count = 0  # 別のクラス変数になる
    
    def __init__(self):
        super().__init__()
        Dog.count += 1

# AnimalとDogで別々にカウント
a1 = Animal()
d1 = Dog()
print(Animal.count)  # 2（AnimalとDogの両方）
print(Dog.count)     # 1（Dogだけ）

# ✅ 正しい（クラス変数を共有）
class Dog(Animal):
    def __init__(self):
        super().__init__()
        # Animal.countを使う（上書きしない）
```

## 🎯 多重継承のトラブル

```python
# ダイヤモンド継承問題
class A:
    def method(self):
        print("A")

class B(A):
    def method(self):
        print("B")
        super().method()

class C(A):
    def method(self):
        print("C")
        super().method()

class D(B, C):
    def method(self):
        print("D")
        super().method()

# MRO確認
print([c.__name__ for c in D.mro()])
# ['D', 'B', 'C', 'A', 'object']

d = D()
d.method()
# 出力:
# D
# B
# C
# A

# ✅ 解決：多重継承を避ける
class D:
    def __init__(self):
        self.b = B()  # コンポジション
        self.c = C()
    
    def method(self):
        self.b.method()
        self.c.method()
```

## 📝 トラブルシューティングフローチャート

```
継承でエラーが出た！
│
├─ AttributeError?
│  ├─ super().__init__()を呼んだ？
│  │  └─ NO → 追加する
│  └─ 親に属性がある？
│     └─ hasattr()で確認
│
├─ メソッドが上書きされない？
│  ├─ メソッド名は正しい？
│  │  └─ スペルチェック
│  └─ 引数は合っている？
│
├─ 親のメソッドを呼べない？
│  └─ super().method()を使う
│
├─ 型チェックが動かない？
│  └─ isinstance()を使う（type()ではなく）
│
└─ 多重継承で混乱？
   ├─ MROを確認（Class.mro()）
   └─ コンポジションを検討
```

## ✅ 継承チェックリスト

```python
class Child(Parent):
    def __init__(self, param1, param2):
        # ☑ super().__init__()を呼んでいるか？
        super().__init__(param1)
        
        # ☑ 親の引数を渡しているか？
        # ☑ 子の初期化は親の後か？
        self.param2 = param2
    
    def method(self):
        # ☑ 親のメソッドを呼ぶ必要があるか？
        result = super().method()
        
        # ☑ メソッド名のスペルは正しいか？
        return f"{result} + 追加処理"

# ☑ 型チェックにisinstance()を使っているか？
if isinstance(obj, Parent):
    obj.method()

# ☑ MROは想定通りか？
print(Child.mro())
```

## 💡 ベストプラクティス

```python
# 1. 常にsuper()を使う
class Child(Parent):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

# 2. 親を拡張する（完全上書きしない）
def method(self):
    super().method()  # 親の処理を実行
    # 追加処理

# 3. 型チェックはisinstance()
if isinstance(obj, ParentClass):
    pass

# 4. 多重継承は避ける
# コンポジション（組み合わせ）を使う
class MyClass:
    def __init__(self):
        self.component1 = Component1()
        self.component2 = Component2()

# 5. 継承の深さは3階層まで
# 深すぎる継承は避ける
Animal → Mammal → Dog  # OK
Animal → ... → ... → ... → Dog  # 深すぎ
```

## 🎓 まとめ：5つの鉄則

```
1. 必ずsuper().__init__()
   → 親の初期化を忘れない

2. super()でメソッド呼び出し
   → 親のメソッドを呼ぶ時

3. isinstance()で型チェック
   → type()ではなく

4. MROを理解する
   → Class.mro()で確認

5. 多重継承は避ける
   → コンポジションを使う
```

これでPython継承のトラブルは完全解決！super()を忘れずに使えば、ほとんどの問題は防げます 🎉
