Pythonのデータ型を完全網羅したチートシート

📊 Pythonデータ型チートシート

1️⃣ 基本データ型一覧

# 数値型
int        # 整数: 1, 100, -50
float      # 浮動小数点: 3.14, -0.5
complex    # 複素数: 3+4j

# 文字列型
str        # 文字列: "hello", 'world'

# ブール型
bool       # 真偽値: True, False

# None型
NoneType   # None（値がない状態）


2️⃣ コレクション型

# シーケンス型（順序あり）
list       # リスト: [1, 2, 3]
tuple      # タプル: (1, 2, 3)
range      # 範囲: range(10)
str        # 文字列: "abc"

# マッピング型
dict       # 辞書: {"key": "value"}

# セット型
set        # セット: {1, 2, 3}
frozenset  # 不変セット: frozenset({1, 2, 3})


3️⃣ 数値型（int, float, complex）

基本操作

# 整数（int）
x = 10
y = -5
z = 0

# 浮動小数点（float）
a = 3.14
b = -0.5
c = 2.0

# 複素数（complex）
comp = 3 + 4j

# 演算
x + y      # 加算: 5
x - y      # 減算: 15
x * y      # 乗算: -50
x / y      # 除算: -2.0
x // y     # 整数除算: -2
x % y      # 剰余: 0
x ** 2     # べき乗: 100

# 型変換
int(3.14)      # 3
float(10)      # 10.0
str(100)       # "100"

# 便利な関数
abs(-10)       # 10（絶対値）
round(3.14159, 2)  # 3.14（四捨五入）
max(1, 5, 3)   # 5
min(1, 5, 3)   # 1
pow(2, 3)      # 8（2の3乗）


メリット・デメリット

# ✅ メリット
- 計算が速い
- メモリ効率が良い
- 演算が簡単

# ❌ デメリット
- floatは誤差がある（0.1 + 0.2 != 0.3）
- 大きな小数は扱いにくい


いつ使う？

# int: カウント、ID、年齢など
count = 0
user_id = 12345

# float: 価格、温度、重さなど
price = 99.99
temperature = 36.5

# complex: 科学計算（一般的には使わない）


4️⃣ 文字列（str）

基本操作

# 作成
s = "Hello"
s = 'Hello'
s = """複数行
文字列"""

# 結合
"Hello" + " " + "World"  # "Hello World"
"Python" * 3             # "PythonPythonPython"

# インデックス・スライス
s = "Python"
s[0]       # "P"
s[-1]      # "n"
s[0:3]     # "Pyt"
s[:3]      # "Pyt"
s[3:]      # "hon"
s[::-1]    # "nohtyP"（逆順）

# 長さ
len("Hello")  # 5

# 検索
"Hello".find("l")      # 2（最初の位置）
"Hello".index("l")     # 2（ない場合エラー）
"Hello".count("l")     # 2（個数）
"l" in "Hello"         # True

# 置換・分割・結合
"Hello World".replace("World", "Python")  # "Hello Python"
"a,b,c".split(",")     # ["a", "b", "c"]
"-".join(["a", "b"])   # "a-b"

# 大文字・小文字
"hello".upper()        # "HELLO"
"HELLO".lower()        # "hello"
"hello".capitalize()   # "Hello"
"hello world".title()  # "Hello World"

# 空白削除
"  hello  ".strip()    # "hello"
"  hello".lstrip()     # "hello"
"hello  ".rstrip()     # "hello"

# 判定
"123".isdigit()        # True
"abc".isalpha()        # True
"abc123".isalnum()     # True
"   ".isspace()        # True

# フォーマット
name = "Alice"
age = 25
f"Name: {name}, Age: {age}"           # "Name: Alice, Age: 25"
"Name: {}, Age: {}".format(name, age) # 同上
"Name: %s, Age: %d" % (name, age)     # 同上（古い方法）


メリット・デメリット

# ✅ メリット
- 豊富なメソッド
- 文字列操作が簡単
- イミュータブル（変更不可）で安全

# ❌ デメリット
- 変更するたびに新しいオブジェクト作成
- 大量の文字列結合は遅い


いつ使う？

# テキスト全般
name = "Alice"
message = "Hello, World!"
email = "user@example.com"


5️⃣ リスト（list）

基本操作

# 作成
lst = [1, 2, 3]
lst = []  # 空リスト
lst = list(range(5))  # [0, 1, 2, 3, 4]

# アクセス
lst = [10, 20, 30, 40]
lst[0]      # 10
lst[-1]     # 40
lst[1:3]    # [20, 30]

# 追加
lst.append(50)         # 末尾に追加
lst.insert(0, 5)       # 指定位置に挿入
lst.extend([60, 70])   # 複数追加
lst += [80, 90]        # 結合

# 削除
lst.remove(20)         # 値で削除（最初の1つ）
lst.pop()              # 末尾を削除して返す
lst.pop(0)             # 指定位置を削除して返す
del lst[0]             # 指定位置を削除
lst.clear()            # 全削除

# 検索
lst = [10, 20, 30, 20]
lst.index(20)          # 1（最初の位置）
lst.count(20)          # 2（個数）
20 in lst              # True

# ソート
lst = [3, 1, 2]
lst.sort()             # [1, 2, 3]（元を変更）
sorted(lst)            # [1, 2, 3]（新しいリスト）
lst.reverse()          # [2, 1, 3]（逆順）

# その他
len([1, 2, 3])         # 3
min([1, 2, 3])         # 1
max([1, 2, 3])         # 3
sum([1, 2, 3])         # 6

# リスト内包表記
[x * 2 for x in range(5)]           # [0, 2, 4, 6, 8]
[x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]


メリット・デメリット

# ✅ メリット
- 柔軟（追加・削除が自由）
- 順序を保持
- 異なる型を混在可能
- インデックスでアクセス可能

# ❌ デメリット
- メモリ使用量が多い
- 検索が遅い（O(n)）
- 大きなリストの操作は遅い


いつ使う？

# 順序が重要なデータ
scores = [85, 90, 78]
names = ["Alice", "Bob", "Charlie"]

# 追加・削除が頻繁
tasks = []
tasks.append("task1")
tasks.append("task2")

# 同じ型のデータ集合
numbers = [1, 2, 3, 4, 5]


6️⃣ タプル（tuple）

基本操作

# 作成
t = (1, 2, 3)
t = 1, 2, 3          # 括弧省略可
t = (1,)             # 要素1つ（カンマ必須）
t = tuple([1, 2, 3]) # リストから変換

# アクセス
t = (10, 20, 30)
t[0]       # 10
t[-1]      # 30
t[1:]      # (20, 30)

# アンパック
a, b, c = (1, 2, 3)  # a=1, b=2, c=3
a, *b, c = (1, 2, 3, 4, 5)  # a=1, b=[2,3,4], c=5

# その他
len((1, 2, 3))     # 3
(1, 2, 3) + (4, 5) # (1, 2, 3, 4, 5)
(1, 2) * 3         # (1, 2, 1, 2, 1, 2)
2 in (1, 2, 3)     # True

# ⚠️ 変更不可
t = (1, 2, 3)
t[0] = 10  # エラー！


メリット・デメリット

# ✅ メリット
- イミュータブル（変更不可）
- リストより高速
- メモリ効率が良い
- 辞書のキーに使える
- 関数の戻り値に最適

# ❌ デメリット
- 変更できない
- メソッドが少ない


いつ使う？

# 変更してはいけないデータ
coordinates = (35.6762, 139.6503)  # 座標
rgb = (255, 0, 0)                   # 色

# 複数の戻り値
def get_user():
    return "Alice", 25, "alice@example.com"

name, age, email = get_user()

# 辞書のキー
locations = {
    (35.6762, 139.6503): "Tokyo",
    (34.6937, 135.5023): "Osaka"
}


7️⃣ 辞書（dict）

基本操作

# 作成
d = {"name": "Alice", "age": 25}
d = dict(name="Alice", age=25)
d = {}  # 空の辞書

# アクセス
d = {"name": "Alice", "age": 25}
d["name"]          # "Alice"
d.get("name")      # "Alice"
d.get("email", "なし")  # "なし"（デフォルト値）

# 追加・更新
d["email"] = "alice@example.com"
d.update({"city": "Tokyo", "age": 26})

# 削除
del d["age"]
d.pop("name")           # "Alice"を削除して返す
d.popitem()             # 最後の要素を削除
d.clear()               # 全削除

# 検索
"name" in d            # True（キー）
"Alice" in d.values()  # True（値）

# 取得
d.keys()               # dict_keys(["name", "age"])
d.values()             # dict_values(["Alice", 25])
d.items()              # dict_items([("name", "Alice"), ("age", 25)])

# ループ
for key in d:
    print(key, d[key])

for key, value in d.items():
    print(key, value)

# 辞書内包表記
{x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}


メリット・デメリット

# ✅ メリット
- キーで高速アクセス（O(1)）
- 柔軟なデータ構造
- わかりやすい
- JSONと相性が良い

# ❌ デメリット
- メモリ使用量が多い
- 順序は保証される（Python 3.7+）が意識しない
- キーは変更不可の型のみ


いつ使う？

# キーと値のペア
user = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "age": 25
}

# 設定・オプション
config = {
    "debug": True,
    "timeout": 30,
    "retry": 3
}

# カウント
word_count = {}
for word in words:
    word_count[word] = word_count.get(word, 0) + 1

# マッピング
status_names = {
    0: "待機中",
    1: "処理中",
    2: "完了"
}


8️⃣ セット（set）

基本操作

# 作成
s = {1, 2, 3}
s = set([1, 2, 3])
s = set()  # 空セット（{}は辞書）

# 追加・削除
s.add(4)           # 追加
s.update([5, 6])   # 複数追加
s.remove(1)        # 削除（ない場合エラー）
s.discard(1)       # 削除（ない場合OK）
s.pop()            # ランダムに削除
s.clear()          # 全削除

# 検索
2 in {1, 2, 3}     # True

# 集合演算
a = {1, 2, 3}
b = {2, 3, 4}

a | b              # {1, 2, 3, 4}（和集合）
a & b              # {2, 3}（積集合）
a - b              # {1}（差集合）
a ^ b              # {1, 4}（対称差）

a.union(b)         # {1, 2, 3, 4}
a.intersection(b)  # {2, 3}
a.difference(b)    # {1}

# 判定
{1, 2}.issubset({1, 2, 3})      # True（部分集合）
{1, 2, 3}.issuperset({1, 2})    # True（上位集合）
{1, 2}.isdisjoint({3, 4})       # True（共通要素なし）

# セット内包表記
{x**2 for x in range(5)}  # {0, 1, 4, 9, 16}


メリット・デメリット

# ✅ メリット
- 重複を自動削除
- 高速な存在チェック（O(1)）
- 集合演算が簡単
- メモリ効率が良い

# ❌ デメリット
- 順序がない
- インデックスアクセス不可
- 要素は変更不可の型のみ


いつ使う？

# 重複削除
numbers = [1, 2, 2, 3, 3, 3]
unique = list(set(numbers))  # [1, 2, 3]

# 存在チェック
allowed_users = {"alice", "bob", "charlie"}
if user in allowed_users:
    print("許可")

# 集合演算
tags1 = {"python", "javascript", "java"}
tags2 = {"python", "ruby", "go"}
common = tags1 & tags2  # {"python"}

# ユニークな要素
visited = set()
for item in items:
    if item not in visited:
        process(item)
        visited.add(item)


9️⃣ None型

基本操作

# None
x = None

# チェック
x is None          # True（推奨）
x == None          # True（非推奨）
x is not None      # False

# デフォルト値
def greet(name=None):
    if name is None:
        name = "Guest"
    print(f"Hello, {name}")

# 関数の戻り値
def no_return():
    pass
result = no_return()  # None


いつ使う？

# 初期値
result = None

# オプション引数
def search(query, limit=None):
    if limit is None:
        limit = 10

# 値がない状態
user = get_user(id)
if user is None:
    print("ユーザーが見つかりません")


🎯 データ型選択フローチャート

データを保存したい
↓
数値？
├─ YES → int / float
└─ NO
    ↓
    テキスト？
    ├─ YES → str
    └─ NO
        ↓
        複数の要素？
        ├─ YES
        │   ↓
        │   順序が重要？
        │   ├─ YES
        │   │   ↓
        │   │   変更する？
        │   │   ├─ YES → list
        │   │   └─ NO → tuple
        │   └─ NO
        │       ↓
        │       キーと値のペア？
        │       ├─ YES → dict
        │       └─ NO
        │           ↓
        │           重複を許さない？
        │           ├─ YES → set
        │           └─ NO → list
        └─ NO → None


📊 比較表

データ型 変更可能 順序 重複 インデックス 速度（検索） メモリ list ✅ ✅ ✅ ✅ 遅い O(n) 多い tuple ❌ ✅ ✅ ✅ 遅い O(n) 少ない dict ✅ ✅ キーのみ不可 キーのみ 速い O(1) 多い set ✅ ❌ ❌ ❌ 速い O(1) 中間

💡 実践例

ユーザーデータ管理

# 辞書でユーザー情報
user = {
    "id": 1,
    "name": "Alice",
    "email": "alice@example.com",
    "tags": ["python", "javascript"],  # リスト
    "settings": {                       # ネスト辞書
        "theme": "dark",
        "notifications": True
    }
}

# リストでユーザー一覧
users = [
    {"id": 1, "name": "Alice"},
    {"id": 2, "name": "Bob"}
]

# セットで権限管理
admin_ids = {1, 5, 10}
if user["id"] in admin_ids:
    print("管理者")


データ処理

# リストで順序を保持
scores = [85, 90, 78, 92]
average = sum(scores) / len(scores)

# セットで重複削除
emails = ["a@example.com", "b@example.com", "a@example.com"]
unique_emails = list(set(emails))

# 辞書でカウント
from collections import Counter
words = ["apple", "banana", "apple", "cherry"]
count = Counter(words)  # {"apple": 2, "banana": 1, "cherry": 1}


🚀 パフォーマンス比較

# 検索速度
# list: O(n) - 遅い
100 in [1, 2, 3, ..., 1000]

# set: O(1) - 速い
100 in {1, 2, 3, ..., 1000}

# dict: O(1) - 速い
100 in {1: "a", 2: "b", ..., 1000: "z"}

# 追加速度
# list: O(1) - append は速い
lst.append(100)

# set: O(1) - 速い
s.add(100)

# dict: O(1) - 速い
d[100] = "value"


⚡ よく使うパターン

# リスト → セット（重複削除）
unique = list(set([1, 2, 2, 3]))

# リスト → 辞書（インデックス付き）
d = {i: v for i, v in enumerate(["a", "b", "c"])}

# 2つのリスト → 辞書
keys = ["name", "age"]
values = ["Alice", 25]
d = dict(zip(keys, values))

# 辞書 → リスト
keys = list(d.keys())
values = list(d.values())

# デフォルト値付き辞書
from collections import defaultdict
d = defaultdict(int)
d["count"] += 1  # 自動的に0から開始


